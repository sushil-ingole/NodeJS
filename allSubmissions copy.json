{
    "submissions_dump": [
        {
            "id": 1217090235,
            "question_id": 337,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 weeks, 5 days",
            "timestamp": 1711696446,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "21 ms",
            "url": "/submissions/detail/1217090235/",
            "is_pending": "Not Pending",
            "title": "House Robber III",
            "memory": "24.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int solve(TreeNode* root, unordered_map<TreeNode*, int>& dp) {\n        if(!root) return 0;\n        int robHouse = 0, dontRobHouse = 0;\n        if(dp[root]) return dp[root];\n        robHouse += root->val;\n        if(root->left) {\n            robHouse += solve(root->left->left, dp) + solve(root->left->right, dp);\n        }\n        if(root->right) {\n            robHouse += solve(root->right->left, dp) + solve(root->right->right, dp);\n        }\n        dontRobHouse += solve(root->left, dp) + solve(root->right, dp);\n        dp[root] = max(robHouse, dontRobHouse);\n        return dp[root];\n    }\n    int rob(TreeNode* root) {\n        unordered_map<TreeNode*, int> dp;\n        return solve(root, dp);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "house-robber-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1217088045,
            "question_id": 337,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 weeks, 5 days",
            "timestamp": 1711696272,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1217088045/",
            "is_pending": "Not Pending",
            "title": "House Robber III",
            "memory": "N/A",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int solve(TreeNode* root) {\n        if(!root) return 0;\n        int robHouse = 0, dontRobHouse = 0;\n        robHouse += root->val;\n        if(root->left) {\n            robHouse += solve(root->left->left) + solve(root->left->right);\n        }\n        if(root->right) {\n            robHouse += solve(root->right->left) + solve(root->right->right);\n        }\n        dontRobHouse += solve(root->left) + solve(root->right);\n        return max(robHouse, dontRobHouse);\n    }\n    int rob(TreeNode* root) {\n        return solve(root);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
            "title_slug": "house-robber-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1217083790,
            "question_id": 337,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 weeks, 5 days",
            "timestamp": 1711695931,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/1217083790/",
            "is_pending": "Not Pending",
            "title": "House Robber III",
            "memory": "N/A",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int solve(TreeNode* root) {\n        if(!root) return 0;\n        int robHouse = 0, dontRobHouse = 0;\n        robHouse += root->val;\n        if(root->left) {\n            robHouse += solve(root->left->left) + solve(root->left->right);\n            robHouse += solve(root->right->left) + solve(root->right->right);\n        }\n        \n        if(root->right) {\n            dontRobHouse += solve(root->left) + solve(root->right);\n        }\n        return max(robHouse, dontRobHouse);\n    }\n    int rob(TreeNode* root) {\n        return solve(root);\n    }\n};",
            "compare_result": "1111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "house-robber-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1211677548,
            "question_id": 1300,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 month",
            "timestamp": 1711202363,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "651 ms",
            "url": "/submissions/detail/1211677548/",
            "is_pending": "Not Pending",
            "title": "Critical Connections in a Network",
            "memory": "235.9 MB",
            "code": "class Solution {\npublic:\n    class Graph\n    {\n    public:\n        unordered_map<int, list<int>> adjList;\n        void addEdge(int u, int v, bool direction)\n        {\n            // Direction = 1 -> Undirected graph\n            // Direction = 0 -> Directed graph;\n            adjList[u].push_back(v);\n            if (direction)\n            {\n                adjList[v].push_back(u);\n            }\n        }\n\n        void findBridges(int src, int parent, int &timer, vector<int> &tin, vector<int> &low, unordered_map<int, bool>& vis, vector<vector<int>>& ans, unordered_map<int, list<int>>& adjList)\n        {\n            vis[src] = true;\n            tin[src] = timer;\n            low[src] = timer;\n            timer++;\n\n            for (auto nbr : adjList[src])\n            {\n                if (nbr == parent)\n                    continue;\n                if (!vis[nbr])\n                {\n                    // DFS call\n                    findBridges(nbr, src, timer, tin, low, vis, ans, adjList);\n                    // Low update\n                    low[src] = min(low[src], low[nbr]);\n                    // Check for bridge\n                    if (low[nbr] > tin[src])\n                    {\n                        vector<int> bridge;\n                        bridge.push_back(nbr);\n                        bridge.push_back(src);\n                        ans.push_back(bridge);\n                    }\n                }\n                else\n                {\n                    // Node is visited and not a parent\n                    // Low update\n                    low[src] = min(low[src], low[nbr]);\n                }\n            }\n        }\n    };\n    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n        unordered_map<int, list<int>> adjList;\n        \n        for(int i=0; i<connections.size(); i++) {\n            int u = connections[i][0];\n            int v = connections[i][1];\n            adjList[u].push_back(v);\n            adjList[v].push_back(u);\n        }\n        \n        vector<vector<int>> ans;\n        int timer = 0;\n        vector<int> tin(n);\n        vector<int> low(n);\n        unordered_map<int, bool> vis;\n        Graph g;\n        g.findBridges(0, -1, timer, tin, low, vis, ans, adjList);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111",
            "title_slug": "critical-connections-in-a-network",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1158120473,
            "question_id": 1753,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706347227,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "83 ms",
            "url": "/submissions/detail/1158120473/",
            "is_pending": "Not Pending",
            "title": "Path With Minimum Effort",
            "memory": "23.4 MB",
            "code": "class Solution {\npublic:\n    int minimumEffortPath(vector<vector<int>>& heights) {\n        priority_queue<pair<int, pair<int, int>>, \n                vector<pair<int,pair<int,int>>>, \n               greater<pair<int,pair<int,int>>>> pq;\n        vector<vector<int>> dist(heights.size(), vector<int>(heights[0].size(), INT_MAX));\n        \n        pq.push({0, {0,0}});\n        dist[0][0] = 0;\n        \n        while(!pq.empty()) {\n            auto fNode = pq.top();\n            pq.pop();\n            \n            int frontNodeDistance = fNode.first;\n            int x = fNode.second.first;\n            int y = fNode.second.second;\n            \n            // Check if reached to answer or not\n            if(x == heights.size()-1 && y == heights[0].size()-1) return dist[x][y];\n            \n            int dx[] = {-1,0,1,0};\n            int dy[] = {0,1,0,-1};\n            for(int i=0; i<4; i++) {\n                int newX = x + dx[i];\n                int newY = y + dy[i];\n                \n                if(newX >= 0 && newX < heights.size() && newY >= 0 && newY < heights[0].size()) {\n                    int currentNodeDistance = abs(heights[x][y] - heights[newX][newY]);\n                    int newMax = max(currentNodeDistance, frontNodeDistance);\n                    if(newMax < dist[newX][newY]) {\n                        dist[newX][newY] = newMax;\n                        pq.push({newMax, {newX, newY}});\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "path-with-minimum-effort",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157650695,
            "question_id": 127,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706293260,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "62 ms",
            "url": "/submissions/detail/1157650695/",
            "is_pending": "Not Pending",
            "title": "Word Ladder",
            "memory": "19.3 MB",
            "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        queue<pair<string, int>> q;\n        q.push({beginWord, 1});\n        unordered_set<string> st(wordList.begin(), wordList.end());\n        \n        // Any word inserted into queue, delete it from set\n        st.erase(beginWord);\n        \n        while(!q.empty()) {\n            pair<string, int> fNode = q.front();\n            q.pop();\n            string currString = fNode.first;\n            int currCount = fNode.second;\n            \n            // Check if not reached to destination\n            if(currString == endWord) return currCount;\n            for(int index = 0; index<currString.length(); index++) {\n                char originalChar = currString[index];\n                for(char ch='a'; ch<='z'; ch++) {\n                    currString[index] = ch;\n                    if(st.find(currString) != st.end()) {\n                        q.push({currString, currCount+1});\n                        st.erase(currString);\n                    }\n                }\n                currString[index] = originalChar;\n            }\n        }\n        return 0;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "word-ladder",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157565337,
            "question_id": 210,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706287565,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "26 ms",
            "url": "/submissions/detail/1157565337/",
            "is_pending": "Not Pending",
            "title": "Course Schedule II",
            "memory": "20 MB",
            "code": "class Solution {\nprivate:\n    vector<int> topoSortBFS(int n, unordered_map<int, list<int>> &adjList) {\n        queue<int> q;\n        vector<int> ans;\n        unordered_map<int, int> indegree;\n        \n        for(auto i: adjList) {\n            for(auto nbr: i.second) {\n                indegree[nbr]++;\n            }\n        }\n        \n        for(int i=0; i<n; i++) {\n            if(indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        while(!q.empty()) {\n            int fNode = q.front();\n            q.pop();\n            \n            ans.push_back(fNode);\n            for(auto nbr: adjList[fNode]) {\n                indegree[nbr]--;\n                \n                if(indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        if(ans.size() == n) {\n            return ans;\n        } else {\n            return {};\n        }\n    }\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        unordered_map<int, list<int>> adjList;\n        for(auto nbr: prerequisites) {\n            int u = nbr[0];\n            int v = nbr[1];\n            adjList[v].push_back(u);\n        }\n        \n        vector<int> ans = topoSortBFS(numCourses, adjList);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111",
            "title_slug": "course-schedule-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157563447,
            "question_id": 210,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706287430,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1157563447/",
            "is_pending": "Not Pending",
            "title": "Course Schedule II",
            "memory": "N/A",
            "code": "class Solution {\nprivate:\n    vector<int> topoSortBFS(int n, unordered_map<int, list<int>> &adjList) {\n        queue<int> q;\n        vector<int> ans;\n        unordered_map<int, int> indegree;\n        \n        for(auto i: adjList) {\n            for(auto nbr: i.second) {\n                indegree[nbr]++;\n            }\n        }\n        \n        for(int i=0; i<n; i++) {\n            if(indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        while(!q.empty()) {\n            int fNode = q.front();\n            q.pop();\n            \n            ans.push_back(fNode);\n            for(auto nbr: adjList[fNode]) {\n                indegree[nbr]--;\n                \n                if(indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        return ans;\n    }\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        unordered_map<int, list<int>> adjList;\n        for(auto nbr: prerequisites) {\n            int u = nbr[0];\n            int v = nbr[1];\n            adjList[v].push_back(u);\n        }\n        \n        vector<int> ans = topoSortBFS(numCourses, adjList);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111110010010001110110001011111",
            "title_slug": "course-schedule-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157549193,
            "question_id": 207,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706286448,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "27 ms",
            "url": "/submissions/detail/1157549193/",
            "is_pending": "Not Pending",
            "title": "Course Schedule",
            "memory": "20.2 MB",
            "code": "class Solution {\nprivate:\n    bool topoSortBFS(int n, unordered_map<int, list<int>> &adjList) {\n        vector<int> ans;\n        queue<int> q;\n        unordered_map<int, int> indegree;\n        \n        // Indegree calculate\n        for(auto i: adjList) {\n            for(auto nbr: i.second) {\n                indegree[nbr]++;\n            }\n        }\n        \n        // Put all nodes inside queue, which has indegree = 0\n        for(int i=0; i<n; i++) {\n            if(indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        // BFS logic\n        while(!q.empty()) {\n            int fNode = q.front();\n            q.pop();\n            \n            ans.push_back(fNode);\n            \n            for(auto nbr: adjList[fNode]) {\n                indegree[nbr]--;\n                \n                // Check for zero again\n                if(indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans.size() == n;\n        \n    }\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        unordered_map<int, list<int>> adjList;\n        for(auto task: prerequisites) {\n            int u = task[0];\n            int v = task[1];\n            adjList[v].push_back(u);\n        }\n        \n        bool ans = topoSortBFS(numCourses, adjList);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111",
            "title_slug": "course-schedule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157427863,
            "question_id": 207,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706277115,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "23 ms",
            "url": "/submissions/detail/1157427863/",
            "is_pending": "Not Pending",
            "title": "Course Schedule",
            "memory": "20.3 MB",
            "code": "class Solution {\nprivate:\n    bool topoSortBFS(int n, unordered_map<int, list<int>> &adjList) {\n        vector<int> ans;\n        queue<int> q;\n        unordered_map<int, int> indegree;\n        \n        // Indegree calculate\n        for(auto i: adjList) {\n            int src = i.first;\n            for(auto nbr: i.second) {\n                indegree[nbr]++;\n            }\n        }\n        \n        // Put all nodes inside queue, which has indegree = 0\n        for(int i=0; i<n; i++) {\n            if(indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        // BFS logic\n        while(!q.empty()) {\n            int fNode = q.front();\n            q.pop();\n            \n            ans.push_back(fNode);\n            \n            for(auto nbr: adjList[fNode]) {\n                indegree[nbr]--;\n                \n                // Check for zero again\n                if(indegree[nbr] == 0) {\n                    q.push(nbr);\n                }\n            }\n        }\n        \n        return ans.size() == n;\n        \n    }\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        unordered_map<int, list<int>> adjList;\n        for(auto task: prerequisites) {\n            int u = task[0];\n            int v = task[1];\n            adjList[v].push_back(u);\n        }\n        \n        bool ans = topoSortBFS(numCourses, adjList);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111",
            "title_slug": "course-schedule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157395756,
            "question_id": 714,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706274466,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "77 ms",
            "url": "/submissions/detail/1157395756/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock with Transaction Fee",
            "memory": "57.2 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRE(vector<int> &prices, int i, int buy, int &fee) {\n        if(i >= prices.size()) return 0;\n        int profit = 0;\n        if(buy) {\n            int buyItProfit = solveUsingRE(prices, i+1, 0, fee) - prices[i];\n            int skipProfit = solveUsingRE(prices, i+1, 1, fee);\n            profit = max(buyItProfit, skipProfit);\n        } else {\n            int sellItProfit = solveUsingRE(prices, i+1, 1, fee) + prices[i] - fee;\n            int skipProfit = solveUsingRE(prices, i+1, 0, fee);\n            profit = max(sellItProfit, skipProfit);\n        }\n        return profit;\n    }\n    int solveUsingTD(vector<int> &prices, int i, int buy, vector<vector<int>> &dp, int &fee) {\n        if(i >= prices.size()) return 0;\n        if(dp[i][buy] != -1) return dp[i][buy];\n        int profit = 0;\n        if(buy) {\n            int buyItProfit = solveUsingTD(prices, i+1, 0, dp, fee) - prices[i];\n            int skipProfit = solveUsingTD(prices, i+1, 1, dp, fee);\n            profit = max(buyItProfit, skipProfit);\n        } else {\n            int sellItProfit = solveUsingTD(prices, i+1, 1, dp, fee) + prices[i] - fee;\n            int skipProfit = solveUsingTD(prices, i+1, 0, dp, fee);\n            profit = max(sellItProfit, skipProfit);\n        }\n        dp[i][buy] = profit;\n        return profit;\n    }\n    int solveUsingBU(vector<int> &prices, int i, int buy, int &fee) {\n        vector<vector<int>> dp(prices.size()+1, vector<int>(2, 0));\n        for(int i=prices.size()-1; i>=0; i--) {\n            for(int buy=0; buy<2; buy++) {\n                int profit = 0;\n                if(buy) {\n                    int buyItProfit = dp[i+1][0] - prices[i]; //solveUsingTD(prices, i+1, 0, dp, fee) - prices[i];\n                    int skipProfit = dp[i+1][1]; //solveUsingTD(prices, i+1, 1, dp, fee);\n                    profit = max(buyItProfit, skipProfit);\n                } else {\n                    int sellItProfit = dp[i+1][1] + prices[i] - fee; //solveUsingTD(prices, i+1, 1, dp, fee) + prices[i] - fee;\n                    int skipProfit = dp[i+1][0]; //solveUsingTD(prices, i+1, 0, dp, fee);\n                    profit = max(sellItProfit, skipProfit);\n                }\n                dp[i][buy] = profit;\n            }\n        }\n        return dp[i][buy];\n    }\n    int solveUsingSO(vector<int> &prices, int i, int buy, int &fee) {\n        vector<vector<int>> dp(2, vector<int>(2, 0));\n        for(int i=prices.size()-1; i>=0; i--) {\n            for(int buy=0; buy<2; buy++) {\n                int profit = 0;\n                if(buy) {\n                    int buyItProfit = dp[1][0] - prices[i]; //solveUsingTD(prices, i+1, 0, dp, fee) - prices[i];\n                    int skipProfit = dp[1][1]; //solveUsingTD(prices, i+1, 1, dp, fee);\n                    profit = max(buyItProfit, skipProfit);\n                } else {\n                    int sellItProfit = dp[1][1] + prices[i] - fee; //solveUsingTD(prices, i+1, 1, dp, fee) + prices[i] - fee;\n                    int skipProfit = dp[1][0]; //solveUsingTD(prices, i+1, 0, dp, fee);\n                    profit = max(sellItProfit, skipProfit);\n                }\n                dp[0][buy] = profit;\n            }\n            dp[1] = dp[0];\n        }\n        return dp[i][buy];\n    }\n    int maxProfit(vector<int>& prices, int fee) {\n        int ans = 0;\n        // ans = solveUsingRE(prices, 0, 1, fee);\n        \n        // vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\n        // ans = solveUsingTD(prices, 0, 1, dp, fee);\n        \n        // ans = solveUsingBU(prices, 0, 1, fee);\n        \n        ans = solveUsingSO(prices, 0, 1, fee);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157394499,
            "question_id": 714,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706274341,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "153 ms",
            "url": "/submissions/detail/1157394499/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock with Transaction Fee",
            "memory": "93.2 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRE(vector<int> &prices, int i, int buy, int &fee) {\n        if(i >= prices.size()) return 0;\n        int profit = 0;\n        if(buy) {\n            int buyItProfit = solveUsingRE(prices, i+1, 0, fee) - prices[i];\n            int skipProfit = solveUsingRE(prices, i+1, 1, fee);\n            profit = max(buyItProfit, skipProfit);\n        } else {\n            int sellItProfit = solveUsingRE(prices, i+1, 1, fee) + prices[i] - fee;\n            int skipProfit = solveUsingRE(prices, i+1, 0, fee);\n            profit = max(sellItProfit, skipProfit);\n        }\n        return profit;\n    }\n    int solveUsingTD(vector<int> &prices, int i, int buy, vector<vector<int>> &dp, int &fee) {\n        if(i >= prices.size()) return 0;\n        if(dp[i][buy] != -1) return dp[i][buy];\n        int profit = 0;\n        if(buy) {\n            int buyItProfit = solveUsingTD(prices, i+1, 0, dp, fee) - prices[i];\n            int skipProfit = solveUsingTD(prices, i+1, 1, dp, fee);\n            profit = max(buyItProfit, skipProfit);\n        } else {\n            int sellItProfit = solveUsingTD(prices, i+1, 1, dp, fee) + prices[i] - fee;\n            int skipProfit = solveUsingTD(prices, i+1, 0, dp, fee);\n            profit = max(sellItProfit, skipProfit);\n        }\n        dp[i][buy] = profit;\n        return profit;\n    }\n    int solveUsingBU(vector<int> &prices, int i, int buy, int &fee) {\n        vector<vector<int>> dp(prices.size()+1, vector<int>(2, 0));\n        for(int i=prices.size()-1; i>=0; i--) {\n            for(int buy=0; buy<2; buy++) {\n                int profit = 0;\n                if(buy) {\n                    int buyItProfit = dp[i+1][0] - prices[i]; //solveUsingTD(prices, i+1, 0, dp, fee) - prices[i];\n                    int skipProfit = dp[i+1][1]; //solveUsingTD(prices, i+1, 1, dp, fee);\n                    profit = max(buyItProfit, skipProfit);\n                } else {\n                    int sellItProfit = dp[i+1][1] + prices[i] - fee; //solveUsingTD(prices, i+1, 1, dp, fee) + prices[i] - fee;\n                    int skipProfit = dp[i+1][0]; //solveUsingTD(prices, i+1, 0, dp, fee);\n                    profit = max(sellItProfit, skipProfit);\n                }\n                dp[i][buy] = profit;\n            }\n        }\n        return dp[i][buy];\n    }\n    int maxProfit(vector<int>& prices, int fee) {\n        int ans = 0;\n        // ans = solveUsingRE(prices, 0, 1, fee);\n        \n        // vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\n        // ans = solveUsingTD(prices, 0, 1, dp, fee);\n        \n        ans = solveUsingBU(prices, 0, 1, fee);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157390145,
            "question_id": 714,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706273941,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "175 ms",
            "url": "/submissions/detail/1157390145/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock with Transaction Fee",
            "memory": "97.9 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRE(vector<int> &prices, int i, int buy, int &fee) {\n        if(i >= prices.size()) return 0;\n        int profit = 0;\n        if(buy) {\n            int buyItProfit = solveUsingRE(prices, i+1, 0, fee) - prices[i];\n            int skipProfit = solveUsingRE(prices, i+1, 1, fee);\n            profit = max(buyItProfit, skipProfit);\n        } else {\n            int sellItProfit = solveUsingRE(prices, i+1, 1, fee) + prices[i] - fee;\n            int skipProfit = solveUsingRE(prices, i+1, 0, fee);\n            profit = max(sellItProfit, skipProfit);\n        }\n        return profit;\n    }\n    int solveUsingTD(vector<int> &prices, int i, int buy, vector<vector<int>> &dp, int &fee) {\n        if(i >= prices.size()) return 0;\n        if(dp[i][buy] != -1) return dp[i][buy];\n        int profit = 0;\n        if(buy) {\n            int buyItProfit = solveUsingTD(prices, i+1, 0, dp, fee) - prices[i];\n            int skipProfit = solveUsingTD(prices, i+1, 1, dp, fee);\n            profit = max(buyItProfit, skipProfit);\n        } else {\n            int sellItProfit = solveUsingTD(prices, i+1, 1, dp, fee) + prices[i] - fee;\n            int skipProfit = solveUsingTD(prices, i+1, 0, dp, fee);\n            profit = max(sellItProfit, skipProfit);\n        }\n        dp[i][buy] = profit;\n        return profit;\n    }\n    int maxProfit(vector<int>& prices, int fee) {\n        int ans = 0;\n        // ans = solveUsingRE(prices, 0, 1, fee);\n        \n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\n        ans = solveUsingTD(prices, 0, 1, dp, fee);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157384060,
            "question_id": 714,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706273387,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1157384060/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock with Transaction Fee",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRE(vector<int> &prices, int i, int buy, int &fee) {\n        if(i >= prices.size()) return 0;\n        int profit = 0;\n        if(buy) {\n            int buyItProfit = solveUsingRE(prices, i+1, 0, fee) - prices[i];\n            int skipProfit = solveUsingRE(prices, i+1, 1, fee);\n            profit = max(buyItProfit, skipProfit);\n        } else {\n            int sellItProfit = solveUsingRE(prices, i+1, 1, fee) + prices[i] - fee;\n            int skipProfit = solveUsingRE(prices, i+1, 0, fee);\n            profit = max(sellItProfit, skipProfit);\n        }\n        return profit;\n    }\n    int maxProfit(vector<int>& prices, int fee) {\n        int ans = 0;\n        ans = solveUsingRE(prices, 0, 1, fee);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111110000000000000000000000000",
            "title_slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157364514,
            "question_id": 188,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706271498,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/1157364514/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock IV",
            "memory": "13.1 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, int limit, vector<vector<vector<int>>> &dp)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n        if(dp[i][buy][limit] != -1) return dp[i][buy][limit];\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, limit, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, limit, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, limit-1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, limit, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n        dp[i][buy][limit] = profit;\n        return dp[i][buy][limit];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy, int lim)\n    {\n        vector<vector<vector<int>>> dp(prices.size()+1, vector<vector<int>>(2, vector<int>(lim+1,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<=lim; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[i+1][0][limit];\n                        int notBuyProfit = 0 + dp[i+1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[i+1][1][limit-1];\n                        int notSellProfit = 0 + dp[i+1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[i][buy][limit] = profit;\n                }\n            }\n        }\n        return dp[i][buy][lim];\n    }\n    int solveUsingSO(vector<int> &prices, int i, int buy, int lim)\n    {\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2, vector<int>(lim+1,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<=lim; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[1][0][limit];\n                        int notBuyProfit = 0 + dp[1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[1][1][limit-1];\n                        int notSellProfit = 0 + dp[1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[0][buy][limit] = profit;\n                }\n            }\n            dp[1] = dp[0];\n        }\n        return dp[i][buy][lim];\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1, k);\n        \n        // vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2, vector<int>(k+1,-1)));\n        // ans = solveUsingMem(prices, 0, 1, k, dp);\n        \n        // ans = solveUsingTab(prices, 0, 1, k);\n        \n        ans = solveUsingSO(prices, 0, 1, k);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-iv",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157364227,
            "question_id": 188,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706271470,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/1157364227/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock IV",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, int limit, vector<vector<vector<int>>> &dp)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n        if(dp[i][buy][limit] != -1) return dp[i][buy][limit];\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, limit, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, limit, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, limit-1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, limit, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n        dp[i][buy][limit] = profit;\n        return dp[i][buy][limit];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy, int lim)\n    {\n        vector<vector<vector<int>>> dp(prices.size()+1, vector<vector<int>>(2, vector<int>(lim+1,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<=lim; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[i+1][0][limit];\n                        int notBuyProfit = 0 + dp[i+1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[i+1][1][limit-1];\n                        int notSellProfit = 0 + dp[i+1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[i][buy][limit] = profit;\n                }\n            }\n        }\n        return dp[i][buy][lim];\n    }\n    int solveUsingSO(vector<int> &prices, int i, int buy, int lim)\n    {\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2, vector<int>(lim+1,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<3; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[1][0][limit];\n                        int notBuyProfit = 0 + dp[1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[1][1][limit-1];\n                        int notSellProfit = 0 + dp[1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[0][buy][limit] = profit;\n                }\n            }\n            dp[1] = dp[0];\n        }\n        return dp[i][buy][lim];\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1, k);\n        \n        // vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2, vector<int>(k+1,-1)));\n        // ans = solveUsingMem(prices, 0, 1, k, dp);\n        \n        // ans = solveUsingTab(prices, 0, 1, k);\n        \n        ans = solveUsingSO(prices, 0, 1, k);\n        return ans;\n    }\n};",
            "compare_result": "111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "best-time-to-buy-and-sell-stock-iv",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157363502,
            "question_id": 188,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706271405,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/1157363502/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock IV",
            "memory": "16.3 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, int limit, vector<vector<vector<int>>> &dp)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n        if(dp[i][buy][limit] != -1) return dp[i][buy][limit];\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, limit, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, limit, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, limit-1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, limit, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n        dp[i][buy][limit] = profit;\n        return dp[i][buy][limit];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy, int lim)\n    {\n        vector<vector<vector<int>>> dp(prices.size()+1, vector<vector<int>>(2, vector<int>(lim+1,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<=lim; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[i+1][0][limit];\n                        int notBuyProfit = 0 + dp[i+1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[i+1][1][limit-1];\n                        int notSellProfit = 0 + dp[i+1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[i][buy][limit] = profit;\n                }\n            }\n        }\n        return dp[i][buy][lim];\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1, k);\n        \n        // vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2, vector<int>(k+1,-1)));\n        // ans = solveUsingMem(prices, 0, 1, k, dp);\n        \n        ans = solveUsingTab(prices, 0, 1, k);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-iv",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157362255,
            "question_id": 188,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706271279,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/1157362255/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock IV",
            "memory": "16.4 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, int limit, vector<vector<vector<int>>> &dp)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n        if(dp[i][buy][limit] != -1) return dp[i][buy][limit];\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, limit, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, limit, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, limit-1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, limit, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n        dp[i][buy][limit] = profit;\n        return dp[i][buy][limit];\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1, k);\n        \n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2, vector<int>(k+1,-1)));\n        ans = solveUsingMem(prices, 0, 1, k, dp);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-iv",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157359710,
            "question_id": 188,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706271029,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1157359710/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock IV",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        int ans = 0;\n        ans = solveUsingRec(prices, 0, 1, k);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000",
            "title_slug": "best-time-to-buy-and-sell-stock-iv",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157354449,
            "question_id": 123,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706270495,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "158 ms",
            "url": "/submissions/detail/1157354449/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock III",
            "memory": "77.7 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, int limit, vector<vector<vector<int>>> &dp)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n        if(dp[i][buy][limit] != -1) return dp[i][buy][limit];\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, limit, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, limit, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, limit-1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, limit, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n        dp[i][buy][limit] = profit;\n        return dp[i][buy][limit];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy, int limit)\n    {\n        vector<vector<vector<int>>> dp(prices.size()+1, vector<vector<int>>(2, vector<int>(3,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<3; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[i+1][0][limit];\n                        int notBuyProfit = 0 + dp[i+1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[i+1][1][limit-1];\n                        int notSellProfit = 0 + dp[i+1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[i][buy][limit] = profit;\n                }\n            }\n        }\n        return dp[i][buy][limit];\n    }\n    int solveUsingSO(vector<int> &prices, int i, int buy, int limit)\n    {\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2, vector<int>(3,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<3; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[1][0][limit];\n                        int notBuyProfit = 0 + dp[1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[1][1][limit-1];\n                        int notSellProfit = 0 + dp[1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[0][buy][limit] = profit;\n                }\n            }\n            dp[1] = dp[0];\n        }\n        return dp[i][buy][limit];\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1, 2);\n        \n        // vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2, vector<int>(3,-1)));\n        // ans = solveUsingMem(prices, 0, 1, 2, dp);\n        \n        // ans = solveUsingTab(prices, 0, 1, 2);\n        ans = solveUsingSO(prices, 0, 1, 2);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1157349289,
            "question_id": 123,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "2 months, 4 weeks",
            "timestamp": 1706269983,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "455 ms",
            "url": "/submissions/detail/1157349289/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock III",
            "memory": "209.7 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, int limit, vector<vector<vector<int>>> &dp)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n        if(dp[i][buy][limit] != -1) return dp[i][buy][limit];\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, limit, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, limit, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, limit-1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, limit, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n        dp[i][buy][limit] = profit;\n        return dp[i][buy][limit];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy, int limit)\n    {\n        vector<vector<vector<int>>> dp(prices.size()+1, vector<vector<int>>(2, vector<int>(3,0)));\n        for(int i = prices.size()-1; i>=0; i--) {\n            for(int buy = 0; buy<2; buy++) {\n                for(int limit = 1; limit<3; limit++) {\n                    int profit = 0;\n                    if (buy)\n                    {\n                        int buyProfit = -prices[i] + dp[i+1][0][limit];\n                        int notBuyProfit = 0 + dp[i+1][1][limit];\n                        profit = max(buyProfit, notBuyProfit);\n                    }\n                    else\n                    {\n                        int sellProfit = prices[i] + dp[i+1][1][limit-1];\n                        int notSellProfit = 0 + dp[i+1][0][limit];\n                        profit = max(sellProfit, notSellProfit);\n                    }\n                    dp[i][buy][limit] = profit;\n                }\n            }\n        }\n        return dp[i][buy][limit];\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1, 2);\n        \n        // vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2, vector<int>(3,-1)));\n        // ans = solveUsingMem(prices, 0, 1, 2, dp);\n        \n        ans = solveUsingTab(prices, 0, 1, 2);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1153140437,
            "question_id": 123,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months",
            "timestamp": 1705891582,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "459 ms",
            "url": "/submissions/detail/1153140437/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock III",
            "memory": "222.1 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, int limit, vector<vector<vector<int>>> &dp)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n        if(dp[i][buy][limit] != -1) return dp[i][buy][limit];\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, limit, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, limit, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, limit-1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, limit, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n        dp[i][buy][limit] = profit;\n        return dp[i][buy][limit];\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1, 2);\n        \n        vector<vector<vector<int>>> dp(prices.size(), vector<vector<int>>(2, vector<int>(3,-1)));\n        ans = solveUsingMem(prices, 0, 1, 2, dp);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1153111927,
            "question_id": 123,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months",
            "timestamp": 1705888495,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1153111927/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock III",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy, int limit)\n    {\n        if (i >= prices.size() || limit == 0)\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0, limit);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1, limit);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1, limit-1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0, limit);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        ans = solveUsingRec(prices, 0, 1, 2);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000",
            "title_slug": "best-time-to-buy-and-sell-stock-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1135339932,
            "question_id": 122,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1704261790,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/1135339932/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock II",
            "memory": "13.3 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, vector<vector<int>> &dp)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        if (dp[i][buy] != -1)\n            return dp[i][buy];\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n\n        dp[i][buy] = profit;\n\n        return dp[i][buy];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy)\n    {\n        vector<vector<int>> dp(prices.size() + 1, vector<int>(2, 0));\n\n        for (int i = prices.size() - 1; i >= 0; i--)\n        {\n            for (int buy = 0; buy < 2; buy++)\n            {\n                int profit = 0;\n                if (buy)\n                {\n                    int buyProfit = -prices[i] + dp[i + 1][0];\n                    int notBuyProfit = 0 + dp[i + 1][1];\n                    profit = max(buyProfit, notBuyProfit);\n                }\n                else\n                {\n                    int sellProfit = prices[i] + dp[i + 1][1];\n                    int notSellProfit = 0 + dp[i + 1][0];\n                    profit = max(sellProfit, notSellProfit);\n                }\n                dp[i][buy] = profit;\n            }\n        }\n\n        return dp[i][buy];\n    }\n    int solveUsingSO(vector<int> &prices, int i, int buy)\n    {\n        vector<vector<int>> dp(2, vector<int>(2, 0));\n\n        for (int i = prices.size() - 1; i >= 0; i--)\n        {\n            for (int buy = 0; buy < 2; buy++)\n            {\n                int profit = 0;\n                if (buy)\n                {\n                    int buyProfit = -prices[i] + dp[1][0];\n                    int notBuyProfit = 0 + dp[1][1];\n                    profit = max(buyProfit, notBuyProfit);\n                }\n                else\n                {\n                    int sellProfit = prices[i] + dp[1][1];\n                    int notSellProfit = 0 + dp[1][0];\n                    profit = max(sellProfit, notSellProfit);\n                }\n                dp[1][buy] = profit;\n            }\n            dp[0] = dp[1];\n        }\n\n        return dp[i][buy];\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1);\n        \n        // vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\n        // ans = solveUsingMem(prices, 0, 1, dp);\n        \n        // ans = solveUsingTab(prices, 0, 1);\n        \n        ans = solveUsingSO(prices, 0, 1);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1135339088,
            "question_id": 122,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1704261733,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "18 ms",
            "url": "/submissions/detail/1135339088/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock II",
            "memory": "13.3 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, vector<vector<int>> &dp)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        if (dp[i][buy] != -1)\n            return dp[i][buy];\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n\n        dp[i][buy] = profit;\n\n        return dp[i][buy];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy)\n    {\n        vector<vector<int>> dp(prices.size() + 1, vector<int>(2, 0));\n\n        for (int i = prices.size() - 1; i >= 0; i--)\n        {\n            for (int buy = 0; buy < 2; buy++)\n            {\n                int profit = 0;\n                if (buy)\n                {\n                    int buyProfit = -prices[i] + dp[i + 1][0];\n                    int notBuyProfit = 0 + dp[i + 1][1];\n                    profit = max(buyProfit, notBuyProfit);\n                }\n                else\n                {\n                    int sellProfit = prices[i] + dp[i + 1][1];\n                    int notSellProfit = 0 + dp[i + 1][0];\n                    profit = max(sellProfit, notSellProfit);\n                }\n                dp[i][buy] = profit;\n            }\n        }\n\n        return dp[i][buy];\n    }\n    int solveUsingSO(vector<int> &prices, int i, int buy)\n    {\n        vector<vector<int>> dp(2, vector<int>(2, 0));\n\n        for (int i = prices.size() - 1; i >= 0; i--)\n        {\n            for (int buy = 0; buy < 2; buy++)\n            {\n                int profit = 0;\n                if (buy)\n                {\n                    int buyProfit = -prices[i] + dp[1][0];\n                    int notBuyProfit = 0 + dp[1][1];\n                    profit = max(buyProfit, notBuyProfit);\n                }\n                else\n                {\n                    int sellProfit = prices[i] + dp[1][1];\n                    int notSellProfit = 0 + dp[1][0];\n                    profit = max(sellProfit, notSellProfit);\n                }\n                dp[1][buy] = profit;\n            }\n            dp[0] = dp[1];\n        }\n\n        return dp[i][buy];\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1);\n        \n        // vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\n        // ans = solveUsingMem(prices, 0, 1, dp);\n        \n        // ans = solveUsingTab(prices, 0, 1);\n        \n        ans = solveUsingSO(prices, 0, 1);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1135333828,
            "question_id": 122,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1704261370,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/1135333828/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock II",
            "memory": "15.8 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, vector<vector<int>> &dp)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        if (dp[i][buy] != -1)\n            return dp[i][buy];\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n\n        dp[i][buy] = profit;\n\n        return dp[i][buy];\n    }\n    int solveUsingTab(vector<int> &prices, int i, int buy)\n    {\n        vector<vector<int>> dp(prices.size() + 1, vector<int>(2, 0));\n\n        for (int i = prices.size() - 1; i >= 0; i--)\n        {\n            for (int buy = 0; buy < 2; buy++)\n            {\n                int profit = 0;\n                if (buy)\n                {\n                    int buyProfit = -prices[i] + dp[i + 1][0];\n                    int notBuyProfit = 0 + dp[i + 1][1];\n                    profit = max(buyProfit, notBuyProfit);\n                }\n                else\n                {\n                    int sellProfit = prices[i] + dp[i + 1][1];\n                    int notSellProfit = 0 + dp[i + 1][0];\n                    profit = max(sellProfit, notSellProfit);\n                }\n                dp[i][buy] = profit;\n            }\n        }\n\n        return dp[i][buy];\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1);\n        \n        // vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\n        // ans = solveUsingMem(prices, 0, 1, dp);\n        \n        ans = solveUsingTab(prices, 0, 1);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1135326249,
            "question_id": 122,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1704260849,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "34 ms",
            "url": "/submissions/detail/1135326249/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock II",
            "memory": "17.5 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int solveUsingMem(vector<int> &prices, int i, int buy, vector<vector<int>> &dp)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        if (dp[i][buy] != -1)\n            return dp[i][buy];\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingMem(prices, i + 1, 0, dp);\n            int notBuyProfit = 0 + solveUsingMem(prices, i + 1, 1, dp);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingMem(prices, i + 1, 1, dp);\n            int notSellProfit = 0 + solveUsingMem(prices, i + 1, 0, dp);\n            profit = max(sellProfit, notSellProfit);\n        }\n\n        dp[i][buy] = profit;\n\n        return dp[i][buy];\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        // ans = solveUsingRec(prices, 0, 1);\n        \n        vector<vector<int>> dp(prices.size(), vector<int>(2, -1));\n        ans = solveUsingMem(prices, 0, 1, dp);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1135323216,
            "question_id": 122,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1704260634,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1135323216/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock II",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRec(vector<int> &prices, int i, int buy)\n    {\n        if (i >= prices.size())\n            return 0;\n\n        int profit = 0;\n        if (buy)\n        {\n            int buyProfit = -prices[i] + solveUsingRec(prices, i + 1, 0);\n            int notBuyProfit = 0 + solveUsingRec(prices, i + 1, 1);\n            profit = max(buyProfit, notBuyProfit);\n        }\n        else\n        {\n            int sellProfit = prices[i] + solveUsingRec(prices, i + 1, 1);\n            int notSellProfit = 0 + solveUsingRec(prices, i + 1, 0);\n            profit = max(sellProfit, notSellProfit);\n        }\n        return profit;\n    }\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        ans = solveUsingRec(prices, 0, 1);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
            "title_slug": "best-time-to-buy-and-sell-stock-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1132402446,
            "question_id": 1025,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1703960567,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/1132402446/",
            "is_pending": "Not Pending",
            "title": "Minimum Cost For Tickets",
            "memory": "10.1 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int>& days, vector<int>& costs, int i) {\n        if(i >= days.size()) {\n            return 0;\n        }\n        \n        int cost1 = costs[0] + solveUsingRecursion(days, costs, i+1);\n        \n        int passEndDay = days[i] + 7 - 1;\n        int j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost7 = costs[1] + solveUsingRecursion(days, costs, j);\n        \n        passEndDay = days[i] + 30 - 1;\n        j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost30 = costs[2] + solveUsingRecursion(days, costs, j);\n        \n        return min(cost1, min(cost7, cost30));\n    }\n    int solveUsingMem(vector<int>& days, vector<int>& costs, int i, vector<int> &dp) {\n        if(i >= days.size()) {\n            return 0;\n        }\n        \n        if(dp[i] != -1) return dp[i];\n        \n        int cost1 = costs[0] + solveUsingMem(days, costs, i+1, dp);\n        \n        int passEndDay = days[i] + 7 - 1;\n        int j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost7 = costs[1] + solveUsingMem(days, costs, j, dp);\n        \n        passEndDay = days[i] + 30 - 1;\n        j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost30 = costs[2] + solveUsingMem(days, costs, j, dp);\n        \n        dp[i] = min(cost1, min(cost7, cost30));\n        \n        return dp[i];\n    }\n    int solveUsingTab(vector<int>& days, vector<int>& costs, int i) {\n        vector<int> dp(days.size()+1, 0);\n        \n        for(int i=days.size()-1; i>=0; i--) {\n            int cost1 = costs[0] + dp[i+1];\n\n            int passEndDay = days[i] + 7 - 1;\n            int j = i;\n            while(j < days.size() && days[j] <= passEndDay) {\n                j++;\n            }\n\n            int cost7 = costs[1] + dp[j];\n\n            passEndDay = days[i] + 30 - 1;\n            j = i;\n            while(j < days.size() && days[j] <= passEndDay) {\n                j++;\n            }\n\n            int cost30 = costs[2] + dp[j];\n\n            dp[i] = min(cost1, min(cost7, cost30));\n        }\n        return dp[i];\n    }\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        // return solveUsingRecursion(days, costs, 0);\n        \n        // vector<int> dp(days.size(), -1);\n        // return solveUsingMem(days, costs, 0, dp);\n        \n        return solveUsingTab(days, costs, 0);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-cost-for-tickets",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1132392790,
            "question_id": 1025,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1703959769,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/1132392790/",
            "is_pending": "Not Pending",
            "title": "Minimum Cost For Tickets",
            "memory": "10.1 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int>& days, vector<int>& costs, int i) {\n        if(i >= days.size()) {\n            return 0;\n        }\n        \n        int cost1 = costs[0] + solveUsingRecursion(days, costs, i+1);\n        \n        int passEndDay = days[i] + 7 - 1;\n        int j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost7 = costs[1] + solveUsingRecursion(days, costs, j);\n        \n        passEndDay = days[i] + 30 - 1;\n        j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost30 = costs[2] + solveUsingRecursion(days, costs, j);\n        \n        return min(cost1, min(cost7, cost30));\n    }\n    int solveUsingMem(vector<int>& days, vector<int>& costs, int i, vector<int> &dp) {\n        if(i >= days.size()) {\n            return 0;\n        }\n        \n        if(dp[i] != -1) return dp[i];\n        \n        int cost1 = costs[0] + solveUsingMem(days, costs, i+1, dp);\n        \n        int passEndDay = days[i] + 7 - 1;\n        int j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost7 = costs[1] + solveUsingMem(days, costs, j, dp);\n        \n        passEndDay = days[i] + 30 - 1;\n        j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost30 = costs[2] + solveUsingMem(days, costs, j, dp);\n        \n        dp[i] = min(cost1, min(cost7, cost30));\n        \n        return dp[i];\n    }\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        // return solveUsingRecursion(days, costs, 0);\n        \n        vector<int> dp(days.size(), -1);\n        return solveUsingMem(days, costs, 0, dp);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-cost-for-tickets",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1132083083,
            "question_id": 279,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1703928312,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "123 ms",
            "url": "/submissions/detail/1132083083/",
            "is_pending": "Not Pending",
            "title": "Perfect Squares",
            "memory": "9.3 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int n) {\n        if(n <= 0) return 0;\n        int ans = INT_MAX;\n        for(int i=1; i*i<=n; ++i) {\n            int perfectSquare = i*i;\n            int noOfPerfectSquares = 1 + solveUsingRecursion(n-perfectSquare);\n            if(noOfPerfectSquares < ans) ans = noOfPerfectSquares;\n        }\n        return ans;\n    }\n    int solveUsingMem(int n, vector<int> &dp) {\n        if(n <= 0) return 0;\n        \n        if(dp[n] != -1) return dp[n];\n        \n        int ans = INT_MAX;\n        for(int i=1; i*i<=n; ++i) {\n            int perfectSquare = i*i;\n            int noOfPerfectSquares = 1 + solveUsingMem(n-perfectSquare, dp);\n            if(noOfPerfectSquares < ans) ans = noOfPerfectSquares;\n        }\n        dp[n] = ans;\n        return ans;\n    }\n    int solveUsingTab(int n) {\n        vector<int> dp(n+1, INT_MAX);\n        dp[0] = 0;\n        \n        for(int j=1; j<=n; j++) {\n            for(int i=1; i*i<=n; i++) {\n                int perfectSquare = i*i;\n                if(j-perfectSquare >= 0) {\n                    int noOfPerfectSquares = 1 + dp[j-perfectSquare];\n                    if(noOfPerfectSquares < dp[j]) dp[j] = noOfPerfectSquares;\n                }\n            }\n        }\n        return dp[n];\n    }\n    int numSquares(int n) {\n        int ans = 0;\n        // ans = solveUsingRecursion(n);\n        \n        // vector<int> dp(n+1, -1);\n        // ans = solveUsingMem(n, dp);\n        \n        ans = solveUsingTab(n);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "perfect-squares",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1132033364,
            "question_id": 279,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1703923029,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "259 ms",
            "url": "/submissions/detail/1132033364/",
            "is_pending": "Not Pending",
            "title": "Perfect Squares",
            "memory": "10 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int n) {\n        if(n <= 0) return 0;\n        int ans = INT_MAX;\n        for(int i=1; i*i<=n; ++i) {\n            int prefectSquare = i*i;\n            int noOfPerfectSquares = 1 + solveUsingRecursion(n-prefectSquare);\n            if(noOfPerfectSquares < ans) ans = noOfPerfectSquares;\n        }\n        return ans;\n    }\n    int solveUsingMem(int n, vector<int> &dp) {\n        if(n <= 0) return 0;\n        \n        if(dp[n] != -1) return dp[n];\n        \n        int ans = INT_MAX;\n        for(int i=1; i*i<=n; ++i) {\n            int prefectSquare = i*i;\n            int noOfPerfectSquares = 1 + solveUsingMem(n-prefectSquare, dp);\n            if(noOfPerfectSquares < ans) ans = noOfPerfectSquares;\n        }\n        dp[n] = ans;\n        return ans;\n    }\n    int numSquares(int n) {\n        int ans = 0;\n        // ans = solveUsingRecursion(n);\n        \n        vector<int> dp(n+1, -1);\n        ans = solveUsingMem(n, dp);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "perfect-squares",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1132032469,
            "question_id": 279,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1703922932,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1132032469/",
            "is_pending": "Not Pending",
            "title": "Perfect Squares",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int n) {\n        if(n <= 0) return 0;\n        int ans = INT_MAX;\n        for(int i=1; i*i<=n; ++i) {\n            int prefectSquare = i*i;\n            int noOfPerfectSquares = 1 + solveUsingRecursion(n-prefectSquare);\n            if(noOfPerfectSquares < ans) ans = noOfPerfectSquares;\n        }\n        return ans;\n    }\n    int numSquares(int n) {\n        int ans = 0;\n        ans = solveUsingRecursion(n);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "perfect-squares",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1132022787,
            "question_id": 279,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1703922016,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "392 ms",
            "url": "/submissions/detail/1132022787/",
            "is_pending": "Not Pending",
            "title": "Perfect Squares",
            "memory": "10 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int n)\n    {\n        if (n == 0)\n            return 1;\n        if (n < 0)\n            return 0;\n        int i = 1;\n        int end = sqrt(n);\n        int ans = INT_MAX;\n        while (i <= end)\n        {\n            int perfectSquare = i * i;\n            int noOfPerfectSqaures = 1 + solveUsingRecursion(n - perfectSquare);\n            if (noOfPerfectSqaures < ans)\n            {\n                ans = noOfPerfectSqaures;\n            }\n            ++i;\n        }\n        return ans;\n    }\n    int solveUsingMem(int n, vector<int> &dp)\n    {\n        if (n == 0)\n            return 1;\n        if (n < 0)\n            return 0;\n        if(dp[n] != -1) return dp[n];\n        int i = 1;\n        int end = sqrt(n);\n        int ans = INT_MAX;\n        while (i <= end)\n        {\n            int perfectSquare = i * i;\n            int noOfPerfectSqaures = 1 + solveUsingMem(n - perfectSquare, dp);\n            if (noOfPerfectSqaures < ans)\n            {\n                ans = noOfPerfectSqaures;\n            }\n            ++i;\n        }\n        dp[n] = ans;\n        return dp[n];\n    }\n    int numSquares(int n) {\n        // return solveUsingRecursion(n) - 1;\n        \n        vector<int> dp(n+1, -1);\n        return solveUsingMem(n,dp) - 1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "perfect-squares",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1132022452,
            "question_id": 279,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "3 months, 3 weeks",
            "timestamp": 1703921986,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1132022452/",
            "is_pending": "Not Pending",
            "title": "Perfect Squares",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int n)\n    {\n        if (n == 0)\n            return 1;\n        if (n < 0)\n            return 0;\n        int i = 1;\n        int end = sqrt(n);\n        int ans = INT_MAX;\n        while (i <= end)\n        {\n            int perfectSquare = i * i;\n            int noOfPerfectSqaures = 1 + solveUsingRecursion(n - perfectSquare);\n            if (noOfPerfectSqaures < ans)\n            {\n                ans = noOfPerfectSqaures;\n            }\n            ++i;\n        }\n        return ans;\n    }\n    int solveUsingMem(int n, vector<int> dp)\n    {\n        if (n == 0)\n            return 1;\n        if (n < 0)\n            return 0;\n        if(dp[n] != -1) return dp[n];\n        int i = 1;\n        int end = sqrt(n);\n        int ans = INT_MAX;\n        while (i <= end)\n        {\n            int perfectSquare = i * i;\n            int noOfPerfectSqaures = 1 + solveUsingMem(n - perfectSquare, dp);\n            if (noOfPerfectSqaures < ans)\n            {\n                ans = noOfPerfectSqaures;\n            }\n            ++i;\n        }\n        dp[n] = ans;\n        return dp[n];\n    }\n    int numSquares(int n) {\n        // return solveUsingRecursion(n) - 1;\n        \n        vector<int> dp(n+1, -1);\n        return solveUsingMem(n,dp) - 1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "perfect-squares",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1125035876,
            "question_id": 300,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703158678,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/1125035876/",
            "is_pending": "Not Pending",
            "title": "Longest Increasing Subsequence",
            "memory": "10.8 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int curr, int prev) {\n        if(curr >= nums.size()) return 0;\n        \n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingRecursion(nums, curr+1, curr);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingRecursion(nums, curr+1, prev);\n        \n        return max(include,exclude);\n    }\n    int solveUsingMem(vector<int> &nums, int curr, int prev, vector<vector<int>> &dp) {\n        if(curr >= nums.size()) return 0;\n        \n        if(dp[curr][prev+1] != -1) return dp[curr][prev+1];\n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingMem(nums, curr+1, curr, dp);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingMem(nums, curr+1, prev, dp);\n        dp[curr][prev+1] = max(include,exclude);\n        return dp[curr][prev+1];\n    }\n    int solveUsingTab(vector<int> &nums) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(nums.size()+1, 0));\n        \n        for(int curr = nums.size()-1; curr>=0; curr--) {\n            for(int prev = curr-1; prev>=-1; prev--) {\n                // Include\n                int include = 0;\n                if(prev == -1 || nums[curr] > nums[prev]) {\n                    include = 1 + dp[curr+1][curr+1];\n                }\n\n                // Exclude\n                int exclude = 0 + dp[curr+1][prev+1];\n                dp[curr][prev+1] = max(include,exclude);\n            }\n        }\n        return dp[0][0];\n    }\n    int solveUsingSO(vector<int> &nums) {\n        int n = nums.size();\n        vector<int> currRow(n+1, 0);\n        vector<int> nextRow(n+1, 0);\n        \n        for(int curr = nums.size()-1; curr>=0; curr--) {\n            for(int prev = curr-1; prev>=-1; prev--) {\n                // Include\n                int include = 0;\n                if(prev == -1 || nums[curr] > nums[prev]) {\n                    include = 1 + nextRow[curr+1];\n                }\n\n                // Exclude\n                int exclude = 0 + nextRow[prev+1];\n                currRow[prev+1] = max(include,exclude);\n            }\n            nextRow = currRow;\n        }\n        return nextRow[0];\n    }\n    int solveUsingSO1(vector<int> &nums) {\n        if(nums.size() <= 0) return 0;\n        \n        vector<int> ans;\n        ans.push_back(nums[0]);\n        \n        for(int i=1; i<nums.size(); i++) {\n            if(nums[i] > ans.back()) {\n                ans.push_back(nums[i]);\n            }\n            int index = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();\n            ans[index] = nums[i];\n        }\n        return ans.size();\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int prev = -1, curr = 0;\n        // int ans = solveUsingRecursion(nums, curr, prev);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(nums.size()+1, -1));\n        // int ans = solveUsingMem(nums, curr, prev, dp);\n        \n        // int ans = solveUsingTab(nums);\n        \n        // int ans = solveUsingSO(nums);\n        \n        int ans = solveUsingSO1(nums);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-increasing-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1124755540,
            "question_id": 300,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703132154,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "333 ms",
            "url": "/submissions/detail/1124755540/",
            "is_pending": "Not Pending",
            "title": "Longest Increasing Subsequence",
            "memory": "11.3 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int curr, int prev) {\n        if(curr >= nums.size()) return 0;\n        \n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingRecursion(nums, curr+1, curr);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingRecursion(nums, curr+1, prev);\n        \n        return max(include,exclude);\n    }\n    int solveUsingMem(vector<int> &nums, int curr, int prev, vector<vector<int>> &dp) {\n        if(curr >= nums.size()) return 0;\n        \n        if(dp[curr][prev+1] != -1) return dp[curr][prev+1];\n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingMem(nums, curr+1, curr, dp);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingMem(nums, curr+1, prev, dp);\n        dp[curr][prev+1] = max(include,exclude);\n        return dp[curr][prev+1];\n    }\n    int solveUsingTab(vector<int> &nums) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(nums.size()+1, 0));\n        \n        for(int curr = nums.size()-1; curr>=0; curr--) {\n            for(int prev = curr-1; prev>=-1; prev--) {\n                // Include\n                int include = 0;\n                if(prev == -1 || nums[curr] > nums[prev]) {\n                    include = 1 + dp[curr+1][curr+1];\n                }\n\n                // Exclude\n                int exclude = 0 + dp[curr+1][prev+1];\n                dp[curr][prev+1] = max(include,exclude);\n            }\n        }\n        return dp[0][0];\n    }\n    int solveUsingSO(vector<int> &nums) {\n        int n = nums.size();\n        vector<int> currRow(n+1, 0);\n        vector<int> nextRow(n+1, 0);\n        \n        for(int curr = nums.size()-1; curr>=0; curr--) {\n            for(int prev = curr-1; prev>=-1; prev--) {\n                // Include\n                int include = 0;\n                if(prev == -1 || nums[curr] > nums[prev]) {\n                    include = 1 + nextRow[curr+1];\n                }\n\n                // Exclude\n                int exclude = 0 + nextRow[prev+1];\n                currRow[prev+1] = max(include,exclude);\n            }\n            nextRow = currRow;\n        }\n        return nextRow[0];\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int prev = -1, curr = 0;\n        // int ans = solveUsingRecursion(nums, curr, prev);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(nums.size()+1, -1));\n        // int ans = solveUsingMem(nums, curr, prev, dp);\n        \n        // int ans = solveUsingTab(nums);\n        \n        int ans = solveUsingSO(nums);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-increasing-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1124745668,
            "question_id": 300,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703131119,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "491 ms",
            "url": "/submissions/detail/1124745668/",
            "is_pending": "Not Pending",
            "title": "Longest Increasing Subsequence",
            "memory": "292.8 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int curr, int prev) {\n        if(curr >= nums.size()) return 0;\n        \n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingRecursion(nums, curr+1, curr);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingRecursion(nums, curr+1, prev);\n        \n        return max(include,exclude);\n    }\n    int solveUsingMem(vector<int> &nums, int curr, int prev, vector<vector<int>> &dp) {\n        if(curr >= nums.size()) return 0;\n        \n        if(dp[curr][prev+1] != -1) return dp[curr][prev+1];\n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingMem(nums, curr+1, curr, dp);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingMem(nums, curr+1, prev, dp);\n        dp[curr][prev+1] = max(include,exclude);\n        return dp[curr][prev+1];\n    }\n    int solveUsingTab(vector<int> &nums) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(nums.size()+1, 0));\n        \n        for(int curr = nums.size()-1; curr>=0; curr--) {\n            for(int prev = curr-1; prev>=-1; prev--) {\n                // Include\n                int include = 0;\n                if(prev == -1 || nums[curr] > nums[prev]) {\n                    include = 1 + dp[curr+1][curr+1];\n                }\n\n                // Exclude\n                int exclude = 0 + dp[curr+1][prev+1];\n                dp[curr][prev+1] = max(include,exclude);\n            }\n        }\n        return dp[0][0];\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int prev = -1, curr = 0;\n        // int ans = solveUsingRecursion(nums, curr, prev);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(nums.size()+1, -1));\n        // int ans = solveUsingMem(nums, curr, prev, dp);\n        \n        int ans = solveUsingTab(nums);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-increasing-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1124741486,
            "question_id": 300,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703130664,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "504 ms",
            "url": "/submissions/detail/1124741486/",
            "is_pending": "Not Pending",
            "title": "Longest Increasing Subsequence",
            "memory": "292.7 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int curr, int prev) {\n        if(curr >= nums.size()) return 0;\n        \n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingRecursion(nums, curr+1, curr);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingRecursion(nums, curr+1, prev);\n        \n        return max(include,exclude);\n    }\n    int solveUsingMem(vector<int> &nums, int curr, int prev, vector<vector<int>> &dp) {\n        if(curr >= nums.size()) return 0;\n        \n        if(dp[curr][prev+1] != -1) return dp[curr][prev+1];\n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingMem(nums, curr+1, curr, dp);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingMem(nums, curr+1, prev, dp);\n        dp[curr][prev+1] = max(include,exclude);\n        return dp[curr][prev+1];\n    }\n    int solveUsingTab(vector<int> &nums) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(nums.size()+2, 0));\n        \n        for(int curr = nums.size()-1; curr>=0; curr--) {\n            for(int prev = curr-1; prev>=-1; prev--) {\n                // Include\n                int include = 0;\n                if(prev == -1 || nums[curr] > nums[prev]) {\n                    include = 1 + dp[curr+1][curr+1];\n                }\n\n                // Exclude\n                int exclude = 0 + dp[curr+1][prev+1];\n                dp[curr][prev+1] = max(include,exclude);\n            }\n        }\n        return dp[0][0];\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int prev = -1, curr = 0;\n        // int ans = solveUsingRecursion(nums, curr, prev);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(nums.size()+1, -1));\n        // int ans = solveUsingMem(nums, curr, prev, dp);\n        \n        int ans = solveUsingTab(nums);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-increasing-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1124734356,
            "question_id": 300,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703129822,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1040 ms",
            "url": "/submissions/detail/1124734356/",
            "is_pending": "Not Pending",
            "title": "Longest Increasing Subsequence",
            "memory": "292.6 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int curr, int prev) {\n        if(curr >= nums.size()) return 0;\n        \n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingRecursion(nums, curr+1, curr);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingRecursion(nums, curr+1, prev);\n        \n        return max(include,exclude);\n    }\n    int solveUsingMem(vector<int> &nums, int curr, int prev, vector<vector<int>> &dp) {\n        if(curr >= nums.size()) return 0;\n        \n        if(dp[curr][prev+1] != -1) return dp[curr][prev+1];\n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingMem(nums, curr+1, curr, dp);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingMem(nums, curr+1, prev, dp);\n        dp[curr][prev+1] = max(include,exclude);\n        return dp[curr][prev+1];\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int prev = -1, curr = 0;\n        // int ans = solveUsingRecursion(nums, curr, prev);\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(nums.size()+1, -1));\n        int ans = solveUsingMem(nums, curr, prev, dp);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-increasing-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1123912115,
            "question_id": 300,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703046328,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1123912115/",
            "is_pending": "Not Pending",
            "title": "Longest Increasing Subsequence",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int curr, int prev) {\n        if(curr >= nums.size()) return 0;\n        \n        // Include\n        int include = 0;\n        if(prev == -1 || nums[curr] > nums[prev]) {\n            include = 1 + solveUsingRecursion(nums, curr+1, curr);\n        }\n        \n        // Exclude\n        int exclude = 0 + solveUsingRecursion(nums, curr+1, prev);\n        \n        return max(include,exclude);\n    }\n    int lengthOfLIS(vector<int>& nums) {\n        int prev = -1, curr = 0;\n        int ans = solveUsingRecursion(nums, curr, prev);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111000000000000000000000000000000000",
            "title_slug": "longest-increasing-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1123880676,
            "question_id": 1250,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703043137,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "50 ms",
            "url": "/submissions/detail/1123880676/",
            "is_pending": "Not Pending",
            "title": "Longest Common Subsequence",
            "memory": "24.7 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(string a, string b, int i, int j) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(a[i] == b[j]) ans = 1 + solveUsingRecursion(a,b,i+1,j+1);\n        else ans = max(solveUsingRecursion(a,b,i+1,j), solveUsingRecursion(a,b,i,j+1));\n        return ans;\n    }\n    int solveUsingMem(string &a, string &b, int i, int j, vector<vector<int>> &dp) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(dp[i][j] != -1) return dp[i][j];\n        if(a[i] == b[j]) ans = 1 + solveUsingMem(a,b,i+1,j+1,dp);\n        else ans = max(solveUsingMem(a,b,i+1,j,dp), solveUsingMem(a,b,i,j+1,dp));\n        dp[i][j] = ans;\n        return dp[i][j];\n    }\n    int solveUsingTab(string &a, string &b) {\n        vector<vector<int>> dp(a.length()+1, vector<int>(b.length()+1, 0));\n        for(int i=a.length()-1; i>=0; i--) {\n            for(int j=b.length()-1; j>=0; j--) {\n                int ans = 0;\n                if(a[i] == b[j]) ans = 1 + dp[i+1][j+1];\n                else ans = max(dp[i+1][j], dp[i][j+1]);\n                dp[i][j] = ans;\n            }\n        }\n        return dp[0][0];\n    }\n    int longestCommonSubsequence(string text1, string text2) {\n        int i=0,j=0;\n        // int ans = solveUsingRecursion(text1, text2, i, j);\n        \n        // vector<vector<int>> dp(text1.length(), vector<int>(text2.length(), -1));\n        // int ans = solveUsingMem(text1, text2, i, j, dp);\n        \n        int ans = solveUsingTab(text1, text2);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1123876248,
            "question_id": 1250,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703042639,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "71 ms",
            "url": "/submissions/detail/1123876248/",
            "is_pending": "Not Pending",
            "title": "Longest Common Subsequence",
            "memory": "24.9 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(string a, string b, int i, int j) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(a[i] == b[j]) ans = 1 + solveUsingRecursion(a,b,i+1,j+1);\n        else ans = max(solveUsingRecursion(a,b,i+1,j), solveUsingRecursion(a,b,i,j+1));\n        return ans;\n    }\n    int solveUsingMem(string &a, string &b, int i, int j, vector<vector<int>> &dp) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(dp[i][j] != -1) return dp[i][j];\n        if(a[i] == b[j]) ans = 1 + solveUsingMem(a,b,i+1,j+1,dp);\n        else ans = max(solveUsingMem(a,b,i+1,j,dp), solveUsingMem(a,b,i,j+1,dp));\n        dp[i][j] = ans;\n        return dp[i][j];\n    }\n    int longestCommonSubsequence(string text1, string text2) {\n        int i=0,j=0;\n        // int ans = solveUsingRecursion(text1, text2, i, j);\n        \n        vector<vector<int>> dp(text1.length(), vector<int>(text2.length(), -1));\n        int ans = solveUsingMem(text1, text2, i, j, dp);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1123876186,
            "question_id": 1250,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703042630,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "77 ms",
            "url": "/submissions/detail/1123876186/",
            "is_pending": "Not Pending",
            "title": "Longest Common Subsequence",
            "memory": "24.9 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(string a, string b, int i, int j) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(a[i] == b[j]) ans = 1 + solveUsingRecursion(a,b,i+1,j+1);\n        else ans = max(solveUsingRecursion(a,b,i+1,j), solveUsingRecursion(a,b,i,j+1));\n        return ans;\n    }\n    int solveUsingMem(string &a, string &b, int i, int j, vector<vector<int>> &dp) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(dp[i][j] != -1) return dp[i][j];\n        if(a[i] == b[j]) ans = 1 + solveUsingMem(a,b,i+1,j+1,dp);\n        else ans = max(solveUsingMem(a,b,i+1,j,dp), solveUsingMem(a,b,i,j+1,dp));\n        dp[i][j] = ans;\n        return dp[i][j];\n    }\n    int longestCommonSubsequence(string text1, string text2) {\n        int i=0,j=0;\n        // int ans = solveUsingRecursion(text1, text2, i, j);\n        \n        vector<vector<int>> dp(text1.length(), vector<int>(text2.length(), -1));\n        int ans = solveUsingMem(text1, text2, i, j, dp);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1123876015,
            "question_id": 1250,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703042608,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1123876015/",
            "is_pending": "Not Pending",
            "title": "Longest Common Subsequence",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(string a, string b, int i, int j) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(a[i] == b[j]) ans = 1 + solveUsingRecursion(a,b,i+1,j+1);\n        else ans = max(solveUsingRecursion(a,b,i+1,j), solveUsingRecursion(a,b,i,j+1));\n        return ans;\n    }\n    int solveUsingMem(string a, string b, int i, int j, vector<vector<int>> &dp) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(dp[i][j] != -1) return dp[i][j];\n        if(a[i] == b[j]) ans = 1 + solveUsingMem(a,b,i+1,j+1,dp);\n        else ans = max(solveUsingMem(a,b,i+1,j,dp), solveUsingMem(a,b,i,j+1,dp));\n        dp[i][j] = ans;\n        return dp[i][j];\n    }\n    int longestCommonSubsequence(string text1, string text2) {\n        int i=0,j=0;\n        // int ans = solveUsingRecursion(text1, text2, i, j);\n        \n        vector<vector<int>> dp(text1.length(), vector<int>(text2.length(), -1));\n        int ans = solveUsingMem(text1, text2, i, j, dp);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111110",
            "title_slug": "longest-common-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1123862321,
            "question_id": 1250,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months",
            "timestamp": 1703040922,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1123862321/",
            "is_pending": "Not Pending",
            "title": "Longest Common Subsequence",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(string a, string b, int i, int j) {\n        // Base case\n        if(i == a.length() || j == b.length()) return 0;\n        \n        int ans = 0;\n        if(a[i] == b[j]) ans = 1 + solveUsingRecursion(a,b,i+1,j+1);\n        else ans = max(solveUsingRecursion(a,b,i+1,j), solveUsingRecursion(a,b,i,j+1));\n        return ans;\n    }\n    int longestCommonSubsequence(string text1, string text2) {\n        int i=0,j=0;\n        int ans = solveUsingRecursion(text1, text2, i, j);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111000000000000000000000000000000",
            "title_slug": "longest-common-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1122831664,
            "question_id": 1228,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702924746,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "38 ms",
            "url": "/submissions/detail/1122831664/",
            "is_pending": "Not Pending",
            "title": "Minimum Cost Tree From Leaf Values",
            "memory": "11.4 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &arr, map<pair<int,int>, int> &maxi, int left, int right) {\n        // Base case\n        if(left == right) return 0;\n        int ans = INT_MAX;\n        for(int i=left; i<right; i++) {\n            ans = min(ans, \n                       maxi[{left,i}]*maxi[{i+1,right}]\n                      +solveUsingRecursion(arr, maxi, left, i)\n                      +solveUsingRecursion(arr, maxi, i+1, right));\n        }\n        \n        return ans;\n    }\n    int solveUsingMem(vector<int> &arr, map<pair<int,int>, int> &maxi, int left, int right, vector<vector<int>> &dp) {\n        // Base case\n        if(left == right) return 0;\n        int ans = INT_MAX;\n        if(dp[left][right] != -1) return dp[left][right];\n        for(int i=left; i<right; i++) {\n            ans = min(ans, \n                       maxi[{left,i}]*maxi[{i+1,right}]\n                      +solveUsingMem(arr, maxi, left, i, dp)\n                      +solveUsingMem(arr, maxi, i+1, right, dp));\n        }\n        dp[left][right] = ans;\n        return dp[left][right];\n    }\n    int solveUsingTab(vector<int> &arr, map<pair<int,int>, int> &maxi) {\n        int n = arr.size();\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\n        \n        for(int left=n-1; left>=0; left--) {\n            for(int right=0; right<=n-1; right++) {\n                if(left >= right) continue;\n                int ans = INT_MAX;\n                for(int i=left; i<right; i++) {\n                    ans = min(ans, \n                               maxi[{left,i}]*maxi[{i+1,right}]\n                              +dp[left][i]\n                              +dp[i+1][right]);\n                }\n                dp[left][right] = ans;\n            }\n        }\n        return dp[0][n-1];\n    }\n    int mctFromLeafValues(vector<int>& arr) {\n        map<pair<int,int>, int> maxi;\n        // Pre-computation\n        int n = arr.size();\n        for(int i=0; i<n; i++) {\n            maxi[{i,i}] = arr[i];\n            for(int j=i+1; j<n; j++) {\n                maxi[{i,j}] = max(arr[j], maxi[{i,j-1}]);\n            }\n        }\n        \n        int ans = 0;\n        // ans = solveUsingRecursion(arr, maxi, 0, n-1);\n        \n//         vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\n        \n//         ans = solveUsingMem(arr, maxi, 0, n-1, dp);\n        \n        ans = solveUsingTab(arr, maxi);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-cost-tree-from-leaf-values",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1122804320,
            "question_id": 1228,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702922496,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "40 ms",
            "url": "/submissions/detail/1122804320/",
            "is_pending": "Not Pending",
            "title": "Minimum Cost Tree From Leaf Values",
            "memory": "11.3 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &arr, map<pair<int,int>, int> &maxi, int left, int right) {\n        // Base case\n        if(left == right) return 0;\n        int ans = INT_MAX;\n        for(int i=left; i<right; i++) {\n            ans = min(ans, \n                       maxi[{left,i}]*maxi[{i+1,right}]\n                      +solveUsingRecursion(arr, maxi, left, i)\n                      +solveUsingRecursion(arr, maxi, i+1, right));\n        }\n        \n        return ans;\n    }\n    int solveUsingMem(vector<int> &arr, map<pair<int,int>, int> &maxi, int left, int right, vector<vector<int>> &dp) {\n        // Base case\n        if(left == right) return 0;\n        int ans = INT_MAX;\n        if(dp[left][right] != -1) return dp[left][right];\n        for(int i=left; i<right; i++) {\n            ans = min(ans, \n                       maxi[{left,i}]*maxi[{i+1,right}]\n                      +solveUsingMem(arr, maxi, left, i, dp)\n                      +solveUsingMem(arr, maxi, i+1, right, dp));\n        }\n        dp[left][right] = ans;\n        return dp[left][right];\n    }\n    int mctFromLeafValues(vector<int>& arr) {\n        map<pair<int,int>, int> maxi;\n        // Pre-computation\n        int n = arr.size();\n        for(int i=0; i<n; i++) {\n            maxi[{i,i}] = arr[i];\n            for(int j=i+1; j<n; j++) {\n                maxi[{i,j}] = max(arr[j], maxi[{i,j-1}]);\n            }\n        }\n        \n        int ans = 0;\n        // ans = solveUsingRecursion(arr, maxi, 0, n-1);\n        \n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\n        ans = solveUsingMem(arr, maxi, 0, n-1, dp);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-cost-tree-from-leaf-values",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1122788773,
            "question_id": 1228,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702921252,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1122788773/",
            "is_pending": "Not Pending",
            "title": "Minimum Cost Tree From Leaf Values",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &arr, map<pair<int,int>, int> &maxi, int left, int right) {\n        // Base case\n        if(left == right) return 0;\n        int ans = INT_MAX;\n        for(int i=left; i<right; i++) {\n            ans = min(ans, \n                       maxi[{left,i}]*maxi[{i+1,right}]\n                      +solveUsingRecursion(arr, maxi, left, i)\n                      +solveUsingRecursion(arr, maxi, i+1, right));\n        }\n        \n        return ans;\n    }\n    int mctFromLeafValues(vector<int>& arr) {\n        map<pair<int,int>, int> maxi;\n        // Pre-computation\n        int n = arr.size();\n        for(int i=0; i<n; i++) {\n            maxi[{i,i}] = arr[i];\n            for(int j=i+1; j<n; j++) {\n                maxi[{i,j}] = max(arr[j], maxi[{i,j-1}]);\n            }\n        }\n        \n        int ans = 0;\n        ans = solveUsingRecursion(arr, maxi, 0, n-1);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000",
            "title_slug": "minimum-cost-tree-from-leaf-values",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1122583472,
            "question_id": 375,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702904181,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "77 ms",
            "url": "/submissions/detail/1122583472/",
            "is_pending": "Not Pending",
            "title": "Guess Number Higher or Lower II",
            "memory": "8.5 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int start, int end) {\n        if(start >= end) return 0;\n        \n        int ans = INT_MAX;\n        for(int i=start; i<=end; i++) {\n            ans = min(ans, i + max(solveUsingRecursion(start, i-1), solveUsingRecursion(i+1, end)));\n        }\n        return ans;\n    }\n    int solveUsingMem(int start, int end, vector<vector<int>> &dp) {\n        if(start >= end) return 0;\n        int ans = INT_MAX;\n        if(dp[start][end] != -1) return dp[start][end];\n        for(int i=start; i<=end; i++) {\n            ans = min(ans, i + max(solveUsingMem(start, i-1, dp), solveUsingMem(i+1, end, dp)));\n        }\n        dp[start][end] = ans;\n        return dp[start][end];\n    }\n    int solveUsingTabulation(int start, int end) {\n        vector<vector<int>> dp(end+2, vector<int>(end+2, 0));\n        for(int s=end; s>=1; s--) {\n            for(int e=1; e<=end; e++) {\n                if(s >= e) continue;\n                else {\n                    int ans = INT_MAX;\n                    for(int i=s; i<=e; i++) {\n                        ans = min(ans, i + max(dp[s][i-1], dp[i+1][e]));\n                    }\n                    dp[s][e] = ans;\n                }\n            }\n        }\n        return dp[start][end];\n    }\n    int getMoneyAmount(int n) {\n        int ans = 0;\n        // ans = solveUsingRecursion(1, n);\n        \n        // vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\n        // ans = solveUsingMem(1, n, dp);\n        \n        ans = solveUsingTabulation(1, n);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111",
            "title_slug": "guess-number-higher-or-lower-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1122581544,
            "question_id": 375,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702903990,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1122581544/",
            "is_pending": "Not Pending",
            "title": "Guess Number Higher or Lower II",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int start, int end) {\n        if(start >= end) return 0;\n        \n        int ans = INT_MAX;\n        for(int i=start; i<=end; i++) {\n            ans = min(ans, i + max(solveUsingRecursion(start, i-1), solveUsingRecursion(i+1, end)));\n        }\n        return ans;\n    }\n    int solveUsingMem(int start, int end, vector<vector<int>> &dp) {\n        if(start >= end) return 0;\n        int ans = INT_MAX;\n        if(dp[start][end] != -1) return dp[start][end];\n        for(int i=start; i<=end; i++) {\n            ans = min(ans, i + max(solveUsingMem(start, i-1, dp), solveUsingMem(i+1, end, dp)));\n        }\n        dp[start][end] = ans;\n        return dp[start][end];\n    }\n    int solveUsingTabulation(int start, int end) {\n        vector<vector<int>> dp(end+2, vector<int>(end+2, 0));\n        for(int s=end; s>=1; s--) {\n            for(int e=1; e<=end; e++) {\n                if(s >= e) continue;\n                else {\n                    int ans = INT_MAX;\n                    for(int i=s; i<=end; i++) {\n                        ans = min(ans, i + max(dp[s][i-1], dp[i+1][e]));\n                    }\n                    dp[s][e] = ans;\n                }\n            }\n        }\n        return dp[start][end];\n    }\n    int getMoneyAmount(int n) {\n        int ans = 0;\n        // ans = solveUsingRecursion(1, n);\n        \n        // vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\n        // ans = solveUsingMem(1, n, dp);\n        \n        ans = solveUsingTabulation(1, n);\n        return ans;\n    }\n};",
            "compare_result": "111111100000000000000000000",
            "title_slug": "guess-number-higher-or-lower-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1122569114,
            "question_id": 375,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702902732,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "185 ms",
            "url": "/submissions/detail/1122569114/",
            "is_pending": "Not Pending",
            "title": "Guess Number Higher or Lower II",
            "memory": "8.5 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int start, int end) {\n        if(start >= end) return 0;\n        \n        int ans = INT_MAX;\n        for(int i=start; i<=end; i++) {\n            ans = min(ans, i + max(solveUsingRecursion(start, i-1), solveUsingRecursion(i+1, end)));\n        }\n        return ans;\n    }\n    int solveUsingMem(int start, int end, vector<vector<int>> &dp) {\n        if(start >= end) return 0;\n        int ans = INT_MAX;\n        if(dp[start][end] != -1) return dp[start][end];\n        for(int i=start; i<=end; i++) {\n            ans = min(ans, i + max(solveUsingMem(start, i-1, dp), solveUsingMem(i+1, end, dp)));\n        }\n        dp[start][end] = ans;\n        return dp[start][end];\n    }\n    int getMoneyAmount(int n) {\n        int ans = 0;\n        // ans = solveUsingRecursion(1, n);\n        \n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\n        ans = solveUsingMem(1, n, dp);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111",
            "title_slug": "guess-number-higher-or-lower-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121722336,
            "question_id": 1263,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702809461,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "36 ms",
            "url": "/submissions/detail/1121722336/",
            "is_pending": "Not Pending",
            "title": "Number of Dice Rolls With Target Sum",
            "memory": "11 MB",
            "code": "class Solution {\npublic:\n    long long int MOD = 1000000007;\n    int solveUsingRecursion(int n, int k, int t) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += solveUsingRecursion(n-1, k, t-i);\n        }\n        return ans;\n    }\n    long long int solveUsingMem(int n, int k, int t, vector<vector<long long int>> &dp) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        if(dp[n][t] != -1) return dp[n][t];\n        long long int ans = 0;\n        for(int i=1; i<=k; i++) {\n            long long int recAns = 0;\n            if(t-i >= 0)\n                recAns = solveUsingMem(n-1, k, t-i, dp);\n            ans = (ans%MOD + recAns%MOD)%MOD;\n        }\n        dp[n][t] = ans;\n        return dp[n][t];\n    }\n    long long int solveUsingTabulation(int n, int k, int target) {\n        vector<vector<long long int>> dp(n+1, vector<long long int>(target+1, 0));\n        \n        dp[0][0] = 1;\n        \n        for(int index=1; index<=n; index++) {\n            for(int t=1; t<=target; t++) {\n                long long int ans = 0;\n                for(int i=1; i<=k; i++) {\n                    long long int recAns = 0;\n                    if(t-i >= 0)\n                        recAns = dp[index-1][t-i];\n                    ans = (ans%MOD + recAns%MOD)%MOD;\n                }\n                dp[index][t] = ans;\n            }\n        }\n        return dp[n][target];\n    }\n    long long int solveUsingSO(int n, int k, int target) {\n        vector<vector<long long int>> dp(n+1, vector<long long int>(target+1, 0));\n        vector<int> prev(target+1, 0);\n        vector<int> curr(target+1, 0);\n        \n        prev[0] = 1;\n        \n        for(int index=1; index<=n; index++) {\n            for(int t=1; t<=target; t++) {\n                long long int ans = 0;\n                for(int i=1; i<=k; i++) {\n                    long long int recAns = 0;\n                    if(t-i >= 0)\n                        recAns = prev[t-i];\n                    ans = (ans%MOD + recAns%MOD)%MOD;\n                }\n                curr[t] = ans;\n            }\n            prev = curr;\n        }\n        return curr[target];\n    }\n    int numRollsToTarget(int n, int k, int target) {\n        // return solveUsingRecursion(n, k, target);\n        \n        // vector<vector<long long int>> dp(n+1, vector<long long int>(target+1, -1));\n        // return solveUsingMem(n, k, target, dp);\n        \n        // return solveUsingTabulation(n, k, target);\n        \n        return solveUsingSO(n, k, target);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-dice-rolls-with-target-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121718480,
            "question_id": 1263,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702808997,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "46 ms",
            "url": "/submissions/detail/1121718480/",
            "is_pending": "Not Pending",
            "title": "Number of Dice Rolls With Target Sum",
            "memory": "10.8 MB",
            "code": "class Solution {\npublic:\n    long long int MOD = 1000000007;\n    int solveUsingRecursion(int n, int k, int t) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += solveUsingRecursion(n-1, k, t-i);\n        }\n        return ans;\n    }\n    long long int solveUsingMem(int n, int k, int t, vector<vector<long long int>> &dp) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        if(dp[n][t] != -1) return dp[n][t];\n        long long int ans = 0;\n        for(int i=1; i<=k; i++) {\n            long long int recAns = 0;\n            if(t-i >= 0)\n                recAns = solveUsingMem(n-1, k, t-i, dp);\n            ans = (ans%MOD + recAns%MOD)%MOD;\n        }\n        dp[n][t] = ans;\n        return dp[n][t];\n    }\n    long long int solveUsingTabulation(int n, int k, int target) {\n        vector<vector<long long int>> dp(n+1, vector<long long int>(target+1, 0));\n        \n        dp[0][0] = 1;\n        \n        for(int index=1; index<=n; index++) {\n            for(int t=1; t<=target; t++) {\n                long long int ans = 0;\n                for(int i=1; i<=k; i++) {\n                    long long int recAns = 0;\n                    if(t-i >= 0)\n                        recAns = dp[index-1][t-i];\n                    ans = (ans%MOD + recAns%MOD)%MOD;\n                }\n                dp[index][t] = ans;\n            }\n        }\n        return dp[n][target];\n    }\n    int numRollsToTarget(int n, int k, int target) {\n        // return solveUsingRecursion(n, k, target);\n        \n        // vector<vector<long long int>> dp(n+1, vector<long long int>(target+1, -1));\n        // return solveUsingMem(n, k, target, dp);\n        \n        return solveUsingTabulation(n, k, target);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-dice-rolls-with-target-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121679175,
            "question_id": 1263,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702804279,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "24 ms",
            "url": "/submissions/detail/1121679175/",
            "is_pending": "Not Pending",
            "title": "Number of Dice Rolls With Target Sum",
            "memory": "11 MB",
            "code": "class Solution {\npublic:\n    long long int MOD = 1000000007;\n    int solveUsingRecursion(int n, int k, int t) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += solveUsingRecursion(n-1, k, t-i);\n        }\n        return ans;\n    }\n    long long int solveUsingMem(int n, int k, int t, vector<vector<long long int>> &dp) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        if(dp[n][t] != -1) return dp[n][t];\n        long long int ans = 0;\n        for(int i=1; i<=k; i++) {\n            long long int recAns = 0;\n            if(t-i >= 0)\n                recAns = solveUsingMem(n-1, k, t-i, dp);\n            ans = (ans%MOD + recAns%MOD)%MOD;\n        }\n        dp[n][t] = ans;\n        return dp[n][t];\n    }\n    int numRollsToTarget(int n, int k, int target) {\n        // return solveUsingRecursion(n, k, target);\n        \n        vector<vector<long long int>> dp(n+1, vector<long long int>(target+1, -1));\n        return solveUsingMem(n, k, target, dp);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-dice-rolls-with-target-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121678992,
            "question_id": 1263,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702804254,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1121678992/",
            "is_pending": "Not Pending",
            "title": "Number of Dice Rolls With Target Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    long long int MOD = 1000000007;\n    int solveUsingRecursion(int n, int k, int t) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += solveUsingRecursion(n-1, k, t-i);\n        }\n        return ans;\n    }\n    long long int solveUsingMem(int n, int k, int t, vector<vector<long long int>> &dp) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        if(dp[n][t] != -1) return dp[n][t];\n        long long int ans = 0;\n        for(int i=1; i<=k; i++) {\n            long long int recAns = 0;\n            if(t-i >= 0)\n                recAns = solveUsingMem(n-1, k, t-i, dp);\n            ans = (ans%MOD + recAns%MOD);\n        }\n        dp[n][t] = ans;\n        return dp[n][t];\n    }\n    int numRollsToTarget(int n, int k, int target) {\n        // return solveUsingRecursion(n, k, target);\n        \n        vector<vector<long long int>> dp(n+1, vector<long long int>(target+1, -1));\n        return solveUsingMem(n, k, target, dp);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111010111111011111111",
            "title_slug": "number-of-dice-rolls-with-target-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121674001,
            "question_id": 1263,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702803635,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/1121674001/",
            "is_pending": "Not Pending",
            "title": "Number of Dice Rolls With Target Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int n, int k, int t) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += solveUsingRecursion(n-1, k, t-i);\n        }\n        return ans;\n    }\n    int solveUsingMem(int n, int k, int t, vector<vector<int>> &dp) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        if(dp[n][t] != -1) return dp[n][t];\n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += solveUsingMem(n-1, k, t-i, dp);\n        }\n        dp[n][t] = ans;\n        return dp[n][t];\n    }\n    int numRollsToTarget(int n, int k, int target) {\n        // return solveUsingRecursion(n, k, target);\n        \n        vector<vector<int>> dp(n+1, vector<int>(target+1, -1));\n        return solveUsingMem(n, k, target, dp);\n    }\n};",
            "compare_result": "11000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "number-of-dice-rolls-with-target-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121672157,
            "question_id": 1263,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702803400,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1121672157/",
            "is_pending": "Not Pending",
            "title": "Number of Dice Rolls With Target Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(int n, int k, int t) {\n        if(n == 0 && t == 0) return 1;\n        if((n != 0 && t == 0) || (n == 0 && t != 0)) return 0;\n        \n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += solveUsingRecursion(n-1, k, t-i);\n        }\n        return ans;\n    }\n    int numRollsToTarget(int n, int k, int target) {\n        return solveUsingRecursion(n, k, target);\n    }\n};",
            "compare_result": "11000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "number-of-dice-rolls-with-target-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121261670,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702753967,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "221 ms",
            "url": "/submissions/detail/1121261670/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "96.9 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool solveUsingSO1(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        vector<int> next(hSum+1, 0);\n        \n        curr[0] = 1;\n        next[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = next[t - nums[index]];\n                bool exclude = next[t];\n                curr[t] = include || exclude;\n            }\n            next = curr;\n        }\n        return next[hSum];\n    }\n    bool solveUsingSO2(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        \n        curr[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=hSum; t >= 1; t--) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = curr[t - nums[index]];\n                bool exclude = curr[t];\n                curr[t] = include || exclude;\n            }\n        }\n        return curr[hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        // return solveUsingTabulation(nums, hSum, 0);\n        \n        // return solveUsingSO1(nums, hSum, 0);\n        \n        return solveUsingSO2(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121261523,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702753949,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "226 ms",
            "url": "/submissions/detail/1121261523/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "96.7 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool solveUsingSO1(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        vector<int> next(hSum+1, 0);\n        \n        curr[0] = 1;\n        next[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = next[t - nums[index]];\n                bool exclude = next[t];\n                curr[t] = include || exclude;\n            }\n            next = curr;\n        }\n        return next[hSum];\n    }\n    bool solveUsingSO2(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        \n        curr[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=hSum; t >= 1; t--) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = curr[t - nums[index]];\n                bool exclude = curr[t];\n                curr[t] = include || exclude;\n            }\n        }\n        return curr[hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        // return solveUsingTabulation(nums, hSum, 0);\n        \n        // return solveUsingSO1(nums, hSum, 0);\n        \n        return solveUsingSO2(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121261268,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702753918,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1121261268/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool solveUsingSO1(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        vector<int> next(hSum+1, 0);\n        \n        curr[0] = 1;\n        next[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = next[t - nums[index]];\n                bool exclude = next[t];\n                curr[t] = include || exclude;\n            }\n            next = curr;\n        }\n        return next[hSum];\n    }\n    bool solveUsingSO2(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        \n        curr[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=hSum; t > 1; t--) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = curr[t - nums[index]];\n                bool exclude = curr[t];\n                curr[t] = include || exclude;\n            }\n        }\n        return curr[hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        // return solveUsingTabulation(nums, hSum, 0);\n        \n        // return solveUsingSO1(nums, hSum, 0);\n        \n        return solveUsingSO2(nums, hSum, 0);\n    }\n};",
            "compare_result": "111110111111101011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121259873,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702753755,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "243 ms",
            "url": "/submissions/detail/1121259873/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "97.4 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool solveUsingSO(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        vector<int> next(hSum+1, 0);\n        \n        curr[0] = 1;\n        next[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = next[t - nums[index]];\n                bool exclude = next[t];\n                curr[t] = include || exclude;\n            }\n            next = curr;\n        }\n        return next[hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        // return solveUsingTabulation(nums, hSum, 0);\n        \n        return solveUsingSO(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121259676,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702753732,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "227 ms",
            "url": "/submissions/detail/1121259676/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "97.5 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool solveUsingSO(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        vector<int> next(hSum+1, 0);\n        \n        curr[0] = 1;\n        next[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = next[t - nums[index]];\n                bool exclude = next[t];\n                curr[t] = include || exclude;\n            }\n            next = curr;\n        }\n        return next[hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        // return solveUsingTabulation(nums, hSum, 0);\n        \n        return solveUsingSO(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121259470,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702753706,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "230 ms",
            "url": "/submissions/detail/1121259470/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "97.7 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool solveUsingSO(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        vector<int> curr(hSum+1, 0);\n        vector<int> next(hSum+1, 0);\n        \n        curr[0] = 1;\n        next[0] = 1;\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = next[t - nums[index]];\n                bool exclude = next[t];\n                curr[t] = include || exclude;\n            }\n            next = curr;\n        }\n        return next[hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        // return solveUsingTabulation(nums, hSum, 0);\n        \n        return solveUsingSO(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121246162,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702752239,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "338 ms",
            "url": "/submissions/detail/1121246162/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "96.1 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        return solveUsingTabulation(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121246023,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702752222,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "340 ms",
            "url": "/submissions/detail/1121246023/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "96.2 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool solveUsingTabulation(vector<int>& nums, int hSum, int index) {\n        vector<vector<int>> dp(nums.size()+1, vector<int>(hSum+1, 0));\n        \n        for(int i=0; i<nums.size(); i++) {\n            dp[i][0] = 1;\n        }\n        \n        for(int index=nums.size()-1; index >= 0; index--) {\n            for(int t=1; t <= hSum; t++) {\n                bool include = false;\n                if(t - nums[index] >= 0)\n                    include = dp[index+1][t - nums[index]];\n                bool exclude = dp[index+1][t];\n                dp[index][t] = include || exclude;\n            }\n        }\n        return dp[index][hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        // vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        // return solveUsingMem(nums, hSum, 0, dp);\n        \n        return solveUsingTabulation(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121059569,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702733700,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "296 ms",
            "url": "/submissions/detail/1121059569/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "95.4 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int index, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || index >= nums.size()) return false;\n        \n        if(dp[index][hSum] != -1) return dp[index][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[index], index+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, index+1, dp);\n        dp[index][hSum] = include || exclude;\n        return dp[index][hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        return solveUsingMem(nums, hSum, 0, dp);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121052255,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702732931,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "297 ms",
            "url": "/submissions/detail/1121052255/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "95.3 MB",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int i, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        if(dp[i][hSum] != -1) return dp[i][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[i], i+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, i+1, dp);\n        dp[i][hSum] = include || exclude;\n        return dp[i][hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        return solveUsingMem(nums, hSum, 0, dp);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1121051811,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702732882,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1121051811/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool solveUsingMem(vector<int>& nums, int hSum, int i, vector<vector<int>> &dp) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        if(dp[i][hSum] != false) return dp[i][hSum];\n        \n        bool include = solveUsingMem(nums, hSum - nums[i], i+1, dp);\n        bool exclude = solveUsingMem(nums, hSum, i+1, dp);\n        dp[i][hSum] = include || exclude;\n        return dp[i][hSum];\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        \n        \n        // return solveUsingRecursion(nums, hSum, 0);\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(hSum+1, -1));\n        return solveUsingMem(nums, hSum, 0, dp);\n    }\n};",
            "compare_result": "111111000001111111111011101100111010001111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111100110110110",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1120532657,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702664851,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1120532657/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        if (tSum % 2 != 0) return false;\n        int hSum = tSum/2;\n        return solveUsingRecursion(nums, hSum, 0);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1120529637,
            "question_id": 416,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 1 week",
            "timestamp": 1702664571,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1120529637/",
            "is_pending": "Not Pending",
            "title": "Partition Equal Subset Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool solveUsingRecursion(vector<int>& nums, int hSum, int i) {\n        // Base case\n        if(hSum == 0) return true;\n        if(hSum < 0 || i >= nums.size()) return false;\n        \n        bool include = solveUsingRecursion(nums, hSum - nums[i], i+1);\n        bool exclude = solveUsingRecursion(nums, hSum, i+1);\n        return include || exclude;\n    }\n    bool canPartition(vector<int>& nums) {\n        int tSum = 0;\n        for(auto i: nums) {\n            tSum += i;\n        }\n        int hSum = tSum/2;\n        return solveUsingRecursion(nums, hSum, 0);\n    }\n};",
            "compare_result": "100001111111011110101111111111011111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "partition-equal-subset-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1115736082,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702131921,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1115736082/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "7.9 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int n) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        int include = solveUsingRecursion(nums, n-2) + nums[n];\n        int exclude = solveUsingRecursion(nums, n-1);\n        \n        return max(include, exclude);\n    }\n    int solveUsingMemoisation(vector<int> &nums, int n, vector<int> &dp) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        \n        int include = solveUsingMemoisation(nums, n-2, dp) + nums[n];\n        int exclude = solveUsingMemoisation(nums, n-1, dp);\n        \n        dp[n] = max(include, exclude); \n        \n        return dp[n];\n    }\n    int solveUsingTabulation(vector<int> &nums, int n) {\n        vector<int> dp(n+1, -1);\n        \n        // Base case\n        dp[0]= nums[0];\n        \n        for(int i=1; i<=n; i++) {\n            int temp = 0;\n            if(i-2 >= 0) {\n                temp = dp[i-2];\n            }\n            int include = temp + nums[i];\n            int exclude = dp[i-1];\n            \n            dp[i] = max(include, exclude);\n        }\n        return dp[n];\n    }\n    int solveUsingSpaceOpt(vector<int> &nums, int n) {\n        int prev2 = 0;\n        int prev1 = nums[0];\n        \n        int curr = 0;\n        for(int i=1; i<=n; i++) {\n            int temp = 0;\n            if(i-2 >= 0) {\n                temp = prev2;\n            }\n            int include = temp + nums[i];\n            int exclude = prev1;\n            \n            curr = max(include, exclude);\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        return prev1;\n    }\n    int rob(vector<int>& nums) {\n        int n = nums.size()-1;\n        // return solveUsingRecursion(nums, n);\n        \n        // vector<int> dp(n+1, -1);\n        // return solveUsingMemoisation(nums, n, dp);\n        \n        // return solveUsingTabulation(nums, n);\n        \n        return solveUsingSpaceOpt(nums, n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1115735034,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702131801,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1115735034/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int n) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        int include = solveUsingRecursion(nums, n-2) + nums[n];\n        int exclude = solveUsingRecursion(nums, n-1);\n        \n        return max(include, exclude);\n    }\n    int solveUsingMemoisation(vector<int> &nums, int n, vector<int> &dp) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        \n        int include = solveUsingMemoisation(nums, n-2, dp) + nums[n];\n        int exclude = solveUsingMemoisation(nums, n-1, dp);\n        \n        dp[n] = max(include, exclude); \n        \n        return dp[n];\n    }\n    int solveUsingTabulation(vector<int> &nums, int n) {\n        vector<int> dp(n+1, -1);\n        \n        // Base case\n        dp[0]= nums[0];\n        \n        for(int i=1; i<=n; i++) {\n            int temp = 0;\n            if(i-2 >= 0) {\n                temp = dp[i-2];\n            }\n            int include = temp + nums[i];\n            int exclude = dp[i-1];\n            \n            dp[i] = max(include, exclude);\n        }\n        return dp[n];\n    }\n    int solveUsingSpaceOpt(vector<int> &nums, int n) {\n        int prev2 = 0;\n        int prev1 = nums[0];\n        \n        int curr = 0;\n        for(int i=1; i<=n; i++) {\n            int temp = 0;\n            if(i-2 >= 0) {\n                temp = prev2;\n            }\n            int include = temp + nums[i];\n            int exclude = prev1;\n            \n            curr = max(include, exclude);\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        return curr;\n    }\n    int rob(vector<int>& nums) {\n        int n = nums.size()-1;\n        // return solveUsingRecursion(nums, n);\n        \n        // vector<int> dp(n+1, -1);\n        // return solveUsingMemoisation(nums, n, dp);\n        \n        // return solveUsingTabulation(nums, n);\n        \n        return solveUsingSpaceOpt(nums, n);\n    }\n};",
            "compare_result": "1110011111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1115727135,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702130879,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1115727135/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "8.1 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int n) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        int include = solveUsingRecursion(nums, n-2) + nums[n];\n        int exclude = solveUsingRecursion(nums, n-1);\n        \n        return max(include, exclude);\n    }\n    int solveUsingMemoisation(vector<int> &nums, int n, vector<int> &dp) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        \n        int include = solveUsingMemoisation(nums, n-2, dp) + nums[n];\n        int exclude = solveUsingMemoisation(nums, n-1, dp);\n        \n        dp[n] = max(include, exclude); \n        \n        return dp[n];\n    }\n    int solveUsingTabulation(vector<int> &nums, int n) {\n        vector<int> dp(n+1, -1);\n        \n        // Base case\n        dp[0]= nums[0];\n        \n        for(int i=1; i<=n; i++) {\n            int temp = 0;\n            if(i-2 >= 0) {\n                temp = dp[i-2];\n            }\n            int include = temp + nums[i];\n            int exclude = dp[i-1];\n            \n            dp[i] = max(include, exclude);\n        }\n        return dp[n];\n    }\n    int rob(vector<int>& nums) {\n        int n = nums.size()-1;\n        // return solveUsingRecursion(nums, n);\n        \n        // vector<int> dp(n+1, -1);\n        // return solveUsingMemoisation(nums, n, dp);\n        \n        return solveUsingTabulation(nums, n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1115727021,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702130867,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1115727021/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "8.4 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int n) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        int include = solveUsingRecursion(nums, n-2) + nums[n];\n        int exclude = solveUsingRecursion(nums, n-1);\n        \n        return max(include, exclude);\n    }\n    int solveUsingMemoisation(vector<int> &nums, int n, vector<int> &dp) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        \n        int include = solveUsingMemoisation(nums, n-2, dp) + nums[n];\n        int exclude = solveUsingMemoisation(nums, n-1, dp);\n        \n        dp[n] = max(include, exclude); \n        \n        return dp[n];\n    }\n    int solveUsingTabulation(vector<int> &nums, int n) {\n        vector<int> dp(n+1, -1);\n        \n        // Base case\n        dp[0]= nums[0];\n        \n        for(int i=1; i<=n; i++) {\n            int temp = 0;\n            if(i-2 >= 0) {\n                temp = dp[i-2];\n            }\n            int include = temp + nums[i];\n            int exclude = dp[i-1];\n            \n            dp[i] = max(include, exclude);\n        }\n        return dp[n];\n    }\n    int rob(vector<int>& nums) {\n        int n = nums.size()-1;\n        // return solveUsingRecursion(nums, n);\n        \n        // vector<int> dp(n+1, -1);\n        // return solveUsingMemoisation(nums, n, dp);\n        \n        return solveUsingTabulation(nums, n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1115726817,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702130844,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1115726817/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "8.3 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int n) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        int include = solveUsingRecursion(nums, n-2) + nums[n];\n        int exclude = solveUsingRecursion(nums, n-1);\n        \n        return max(include, exclude);\n    }\n    int solveUsingMemoisation(vector<int> &nums, int n, vector<int> &dp) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        \n        int include = solveUsingMemoisation(nums, n-2, dp) + nums[n];\n        int exclude = solveUsingMemoisation(nums, n-1, dp);\n        \n        dp[n] = max(include, exclude); \n        \n        return dp[n];\n    }\n    int solveUsingTabulation(vector<int> &nums, int n) {\n        vector<int> dp(n+1, -1);\n        \n        // Base case\n        dp[0]= nums[0];\n        \n        for(int i=1; i<=n; i++) {\n            int temp = 0;\n            if(i-2 >= 0) {\n                temp = dp[i-2];\n            }\n            int include = temp + nums[i];\n            int exclude = dp[i-1];\n            \n            dp[i] = max(include, exclude);\n        }\n        return dp[n];\n    }\n    int rob(vector<int>& nums) {\n        int n = nums.size()-1;\n        // return solveUsingRecursion(nums, n);\n        \n        // vector<int> dp(n+1, -1);\n        // return solveUsingMemoisation(nums, n, dp);\n        \n        return solveUsingTabulation(nums, n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1115722206,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702130298,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1115722206/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "8.1 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int n) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        int include = solveUsingRecursion(nums, n-2) + nums[n];\n        int exclude = solveUsingRecursion(nums, n-1);\n        \n        return max(include, exclude);\n    }\n    int solveUsingMemoisation(vector<int> &nums, int n, vector<int> &dp) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        \n        int include = solveUsingMemoisation(nums, n-2, dp) + nums[n];\n        int exclude = solveUsingMemoisation(nums, n-1, dp);\n        \n        dp[n] = max(include, exclude); \n        \n        return dp[n];\n    }\n    int rob(vector<int>& nums) {\n        int n = nums.size()-1;\n        // return solveUsingRecursion(nums, n);\n        \n        vector<int> dp(n+1, -1);\n        return solveUsingMemoisation(nums, n, dp);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1115718107,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702129808,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1115718107/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &nums, int n) {\n        // Base case\n        if(n < 0) {\n            return 0;\n        }\n        if(n == 0) {\n            return nums[0];\n        }\n        \n        int include = solveUsingRecursion(nums, n-2) + nums[n];\n        int exclude = solveUsingRecursion(nums, n-1);\n        \n        return max(include, exclude);\n    }\n    int rob(vector<int>& nums) {\n        int n = nums.size()-1;\n        return solveUsingRecursion(nums, n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111000000000000000",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114755872,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702001190,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "68 ms",
            "url": "/submissions/detail/1114755872/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "14.8 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return dp[amount];\n    }\n    int solveUsingBottomUpApproach(vector<int> &coins, int amount) {\n        // Case 1: Create DP Array\n        vector<int> dp(amount+1, INT_MAX);\n        // Case 2: Base case\n        dp[0] = 0;\n        // Case 3: Check the range and flow of Top Down approach and code accordingly.\n        for(int target = 1; target <= amount; target++) {\n            int mini = INT_MAX;\n            for(int i=0; i<coins.size(); ++i) {\n                if(target - coins[i] >= 0 && target - coins[i] != INT_MAX) {\n                    int ans = dp[target - coins[i]];\n                    if(ans != INT_MAX) {\n                        mini = min(mini, 1 + ans);\n                    }\n                }\n            }\n            dp[target] = mini;\n        }\n        return dp[amount];\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        // vector<int> dp(amount+1, -1);\n        // int ans = solveUsingTopDownApproach(coins, amount, dp);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        int ans = solveUsingBottomUpApproach(coins, amount);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114755789,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702001176,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "73 ms",
            "url": "/submissions/detail/1114755789/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "15 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return dp[amount];\n    }\n    int solveUsingBottomUpApproach(vector<int> &coins, int amount) {\n        // Case 1: Create DP Array\n        vector<int> dp(amount+1, INT_MAX);\n        // Case 2: Base case\n        dp[0] = 0;\n        // Case 3: Check the range and flow of Top Down approach and code accordingly.\n        for(int target = 1; target <= amount; target++) {\n            int mini = INT_MAX;\n            for(int i=0; i<coins.size(); ++i) {\n                if(target - coins[i] >= 0 && target - coins[i] != INT_MAX) {\n                    int ans = dp[target - coins[i]];\n                    if(ans != INT_MAX) {\n                        mini = min(mini, 1 + ans);\n                    }\n                }\n            }\n            dp[target] = mini;\n        }\n        return dp[amount];\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        // vector<int> dp(amount+1, -1);\n        // int ans = solveUsingTopDownApproach(coins, amount, dp);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        int ans = solveUsingBottomUpApproach(coins, amount);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114755682,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702001158,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "71 ms",
            "url": "/submissions/detail/1114755682/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "15 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return dp[amount];\n    }\n    int solveUsingBottomUpApproach(vector<int> &coins, int amount) {\n        // Case 1: Create DP Array\n        vector<int> dp(amount+1, INT_MAX);\n        // Case 2: Base case\n        dp[0] = 0;\n        // Case 3: Check the range and flow of Top Down approach and code accordingly.\n        for(int target = 1; target <= amount; target++) {\n            int mini = INT_MAX;\n            for(int i=0; i<coins.size(); ++i) {\n                if(target - coins[i] >= 0 && target - coins[i] != INT_MAX) {\n                    int ans = dp[target - coins[i]];\n                    if(ans != INT_MAX) {\n                        mini = min(mini, 1 + ans);\n                    }\n                }\n            }\n            dp[target] = mini;\n        }\n        return dp[amount];\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        // vector<int> dp(amount+1, -1);\n        // int ans = solveUsingTopDownApproach(coins, amount, dp);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        int ans = solveUsingBottomUpApproach(coins, amount);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114755571,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1702001142,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "62 ms",
            "url": "/submissions/detail/1114755571/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "14.7 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return dp[amount];\n    }\n    int solveUsingBottomUpApproach(vector<int> &coins, int amount) {\n        // Case 1: Create DP Array\n        vector<int> dp(amount+1, INT_MAX);\n        // Case 2: Base case\n        dp[0] = 0;\n        // Case 3: Check the range and flow of Top Down approach and code accordingly.\n        for(int target = 1; target <= amount; target++) {\n            int mini = INT_MAX;\n            for(int i=0; i<coins.size(); ++i) {\n                if(target - coins[i] >= 0 && target - coins[i] != INT_MAX) {\n                    int ans = dp[target - coins[i]];\n                    if(ans != INT_MAX) {\n                        mini = min(mini, 1 + ans);\n                    }\n                }\n            }\n            dp[target] = mini;\n        }\n        return dp[amount];\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        // vector<int> dp(amount+1, -1);\n        // int ans = solveUsingTopDownApproach(coins, amount, dp);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        int ans = solveUsingBottomUpApproach(coins, amount);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114554950,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701972559,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "58 ms",
            "url": "/submissions/detail/1114554950/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "15.7 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return dp[amount];\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        vector<int> dp(amount+1, -1);\n        int ans = solveUsingTopDownApproach(coins, amount, dp);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114553882,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701972463,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "73 ms",
            "url": "/submissions/detail/1114553882/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "17.7 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return mini;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        vector<int> dp(amount+1, -1);\n        int ans = solveUsingTopDownApproach(coins, amount, dp);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114553795,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701972454,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "77 ms",
            "url": "/submissions/detail/1114553795/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "17.9 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return mini;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        vector<int> dp(amount+1, -1);\n        int ans = solveUsingTopDownApproach(coins, amount, dp);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114553651,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701972443,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "74 ms",
            "url": "/submissions/detail/1114553651/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "17.5 MB",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    \n    int solveUsingTopDownApproach(vector<int> &coins, int amount, vector<int> &dp) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        if(dp[amount] != -1) return dp[amount];\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingTopDownApproach(coins, amount - coins[i], dp);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        dp[amount] = mini;\n        return mini;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        // int ans = solveUsingRecursion(coins, amount);\n        // if(ans == INT_MAX) {\n        //     return -1;\n        // }\n        // return ans;\n        \n        vector<int> dp(amount+1, -1);\n        int ans = solveUsingTopDownApproach(coins, amount, dp);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114544291,
            "question_id": 322,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701971647,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1114544291/",
            "is_pending": "Not Pending",
            "title": "Coin Change",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int solveUsingRecursion(vector<int> &coins, int amount) {\n        // Base case\n        if(amount == 0) return 0;\n        if(amount < 0) return INT_MAX;\n        int mini = INT_MAX;\n        for(int i=0; i<coins.size(); ++i) {\n            int ans = solveUsingRecursion(coins, amount - coins[i]);\n            if(ans != INT_MAX) {\n                mini = min(mini, 1 + ans);\n            }\n        }\n        return mini;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        int ans = solveUsingRecursion(coins, amount);\n        if(ans == INT_MAX) {\n            return -1;\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "coin-change",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114059035,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701921297,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1114059035/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.3 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    // Recursion + Memoisation\n    int topDownSolve(int n, vector<int> &dp) {\n        // Base Case\n        if(n==1 || n==0) {\n            return n;\n        }\n        // Check if ans already exist\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        // Replace ans with dp[n]\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    // Bottom Up Approach\n    int bottomUpSolve(int n) {\n        // Step 1: Create DP array\n        vector<int> dp(n+1, -1);\n        \n        // Step 2: Observe case in above situation\n        dp[0] = 0;\n        if(n==0) return dp[0];\n        dp[1] = 1;\n        if(n==1) return dp[1];\n        \n        // Step 3:\n        for(int i=2; i<=n; ++i) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n    // Space Optimization\n    int spaceOptSolve(int n) {\n        int prev2 = 0;\n        if(n==0) return prev2;\n        int prev1 = 1;\n        if(n==1) return prev1;\n        \n        int curr;\n        for(int i=2; i<=n; ++i) {\n            curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        return curr;\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        // Using DP topDown upproach\n        // vector<int> dp(n+1,-1);\n        // int ans = topDownSolve(n, dp);\n        // return ans;\n        \n        // Using DP bottomUp Approach\n        // return bottomUpSolve(n);\n        \n        return spaceOptSolve(n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114058951,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701921286,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/1114058951/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.2 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    // Recursion + Memoisation\n    int topDownSolve(int n, vector<int> &dp) {\n        // Base Case\n        if(n==1 || n==0) {\n            return n;\n        }\n        // Check if ans already exist\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        // Replace ans with dp[n]\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    // Bottom Up Approach\n    int bottomUpSolve(int n) {\n        // Step 1: Create DP array\n        vector<int> dp(n+1, -1);\n        \n        // Step 2: Observe case in above situation\n        dp[0] = 0;\n        if(n==0) return dp[0];\n        dp[1] = 1;\n        if(n==1) return dp[1];\n        \n        // Step 3:\n        for(int i=2; i<=n; ++i) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n    // Space Optimization\n    int spaceOptSolve(int n) {\n        int prev2 = 0;\n        if(n==0) return prev2;\n        int prev1 = 1;\n        if(n==1) return prev1;\n        \n        int curr;\n        for(int i=2; i<=n; ++i) {\n            curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        return curr;\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        // Using DP topDown upproach\n        // vector<int> dp(n+1,-1);\n        // int ans = topDownSolve(n, dp);\n        // return ans;\n        \n        // Using DP bottomUp Approach\n        // return bottomUpSolve(n);\n        \n        return spaceOptSolve(n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1114058813,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701921269,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1114058813/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.3 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    // Recursion + Memoisation\n    int topDownSolve(int n, vector<int> &dp) {\n        // Base Case\n        if(n==1 || n==0) {\n            return n;\n        }\n        // Check if ans already exist\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        // Replace ans with dp[n]\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    // Bottom Up Approach\n    int bottomUpSolve(int n) {\n        // Step 1: Create DP array\n        vector<int> dp(n+1, -1);\n        \n        // Step 2: Observe case in above situation\n        dp[0] = 0;\n        if(n==0) return dp[0];\n        dp[1] = 1;\n        if(n==1) return dp[1];\n        \n        // Step 3:\n        for(int i=2; i<=n; ++i) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n    // Space Optimization\n    int spaceOptSolve(int n) {\n        int prev2 = 0;\n        if(n==0) return prev2;\n        int prev1 = 1;\n        if(n==1) return prev1;\n        \n        int curr;\n        for(int i=2; i<=n; ++i) {\n            curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        return curr;\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        // Using DP topDown upproach\n        // vector<int> dp(n+1,-1);\n        // int ans = topDownSolve(n, dp);\n        // return ans;\n        \n        // Using DP bottomUp Approach\n        // return bottomUpSolve(n);\n        \n        return spaceOptSolve(n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113813341,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701886787,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1113813341/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.6 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    // Recursion + Memoisation\n    int topDownSolve(int n, vector<int> &dp) {\n        // Base Case\n        if(n==1 || n==0) {\n            return n;\n        }\n        // Check if ans already exist\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        // Replace ans with dp[n]\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    // Bottom Up Approach\n    int bottomUpSolve(int n) {\n        // Step 1: Create DP array\n        vector<int> dp(n+1, -1);\n        \n        // Step 2: Observe case in above situation\n        dp[0] = 0;\n        if(n==0) return dp[0];\n        dp[1] = 1;\n        if(n==1) return dp[1];\n        \n        // Step 3:\n        for(int i=2; i<=n; ++i) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        // Using DP topDown upproach\n        // vector<int> dp(n+1,-1);\n        // int ans = topDownSolve(n, dp);\n        // return ans;\n        \n        // Using DP bottomUp Approach\n        return bottomUpSolve(n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113813234,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701886777,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/1113813234/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.6 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    // Recursion + Memoisation\n    int topDownSolve(int n, vector<int> &dp) {\n        // Base Case\n        if(n==1 || n==0) {\n            return n;\n        }\n        // Check if ans already exist\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        // Replace ans with dp[n]\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    // Bottom Up Approach\n    int bottomUpSolve(int n) {\n        // Step 1: Create DP array\n        vector<int> dp(n+1, -1);\n        \n        // Step 2: Observe case in above situation\n        dp[0] = 0;\n        if(n==0) return dp[0];\n        dp[1] = 1;\n        if(n==1) return dp[1];\n        \n        // Step 3:\n        for(int i=2; i<=n; ++i) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        // Using DP topDown upproach\n        // vector<int> dp(n+1,-1);\n        // int ans = topDownSolve(n, dp);\n        // return ans;\n        \n        // Using DP bottomUp Approach\n        return bottomUpSolve(n);\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113788908,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701884580,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1113788908/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    // Recursion + Memoisation\n    int topDownSolve(int n, vector<int> &dp) {\n        // Base Case\n        if(n==1 || n==0) {\n            return n;\n        }\n        // Check if ans already exist\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        // Replace ans with dp[n]\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        vector<int> dp(n+1,-1);\n        int ans = topDownSolve(n, dp);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113783571,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701884098,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1113783571/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.5 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    int topDownSolve(int n, vector<int> &dp) {\n        if(n==1 || n==0) {\n            return n;\n        }\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        vector<int> dp(n+1,-1);\n        int ans = topDownSolve(n, dp);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113782596,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701884009,
            "status": 12,
            "status_display": "Memory Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1113782596/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    int topDownSolve(int n, vector<int> dp) {\n        if(n==1 || n==0) {\n            return n;\n        }\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        vector<int> dp(n+1,-1);\n        int ans = topDownSolve(n, dp);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111000",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113781641,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701883920,
            "status": 12,
            "status_display": "Memory Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1113781641/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    int topDownSolve(int n, vector<int> dp) {\n        if(n==1 || n==0) {\n            return n;\n        }\n        if(dp[n] != -1) {\n            return dp[n];\n        }\n        dp[n] = topDownSolve(n-1, dp) + topDownSolve(n-2, dp);\n        return dp[n];\n    }\n    int fib(int n) {\n        // int ans = recSolve(n);\n        // return ans;\n        \n        vector<int> dp(n+1,-1);\n        int ans = topDownSolve(n, dp);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111000",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113778242,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701883619,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "13 ms",
            "url": "/submissions/detail/1113778242/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.3 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    int fib(int n) {\n        int ans = recSolve(n);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113778145,
            "question_id": 1013,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701883610,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/1113778145/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "6.3 MB",
            "code": "class Solution {\npublic:\n    int recSolve(int n) {\n        if(n == 1 || n == 0) {\n            return n;\n        }\n        int ans = recSolve(n-1) + recSolve(n-2);\n        return ans;\n    }\n    int fib(int n) {\n        int ans = recSolve(n);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113692801,
            "question_id": 336,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701875757,
            "status": 12,
            "status_display": "Memory Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/1113692801/",
            "is_pending": "Not Pending",
            "title": "Palindrome Pairs",
            "memory": "N/A",
            "code": "class TrieNode {\n    public:\n    char data;\n    TrieNode *children[26];\n    int stringPos; // Original words array index of that string.\n    \n    TrieNode(char ch) : data(ch), stringPos(-1) {\n        for(int i=0; i<26; ++i) {\n            children[i] = 0;\n        }\n    }\n};\n\nclass Trie {\n    TrieNode *root;\n    void insertUtil(TrieNode *root, string &word, int i, int &stringPos) {\n        if(i >= word.size()) {\n            root->stringPos = stringPos;\n            return;\n        }\n        int index = word[i] - 'a';\n        if(!root->children[index]) {\n            root->children[index] = new TrieNode(word[i]);\n        }\n        insertUtil(root->children[index], word, i+1, stringPos);\n    }\npublic:\n    Trie() {\n        root = new TrieNode('\\0');\n    }\n    \n    bool isPalindrome(string &word, int low, int high) {\n        while(low<=high) {\n            if(word[low] != word[high]) return false;\n            low++, high--;\n        }\n        return true;\n    }\n    \n    void insert(string &word, int &stringPos) {\n        insertUtil(root, word, 0, stringPos);\n    }\n    \n    void searchCase2(TrieNode *curr, vector<int> &myPalindromes, string s) {\n        if(root->stringPos != -1) {\n            if(isPalindrome(s, 0, s.size()-1)) {\n                myPalindromes.push_back(root->stringPos);\n            }\n        }\n        \n        for(int i=0; i<26; ++i) {\n            if(root->children[i] != 0) {\n                s.push_back(i + 'a');\n                searchCase2(root->children[i], myPalindromes, s);\n                s.pop_back();\n            }\n        }\n    }\n    \n    void search(string &word, vector<int> &myPalindromes) {\n        TrieNode *curr = root;\n        \n        // Case 1: When a prefix of string word exactly matches with a word in Trie.\n        for(int i=0; i<word.size(); ++i) {\n            int index = word[i] - 'a';\n            \n            if(curr->stringPos != -1) {\n                // Check rest of the search word is palindrome?\n                if(isPalindrome(word, i, word.size()-1)) {\n                    myPalindromes.push_back(curr->stringPos);\n                }\n            }\n            if(curr->children[index]) {\n                curr = curr->children[index];\n            } else {\n                return;\n            }\n        }\n        \n        // Case 2: Search word is a prefix of a word in the Trie.\n        // Check remaining subtrees in the Trie for the palindrome.\n        searchCase2(curr, myPalindromes, \"\");\n    }\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        vector<vector<int>> ans;\n        Trie trie;\n        \n        // Insert all words in reverse order and mark its stringPosition as index of words array.\n        for(int i=0; i<words.size(); ++i) {\n            auto reverseWord = words[i];\n            reverse(reverseWord.begin(), reverseWord.end());\n            trie.insert(reverseWord, i);\n        }\n        \n        // Find palindromic pairs of each word.\n        for(int i=0; i<words.size(); ++i) {\n            vector<int> myPalindromes; // Array stores palindromic pairs of ith word.\n            trie.search(words[i], myPalindromes);\n            \n            for(auto it : myPalindromes) {\n                if(it != i) {\n                    ans.push_back({i, it});\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "palindrome-pairs",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113323339,
            "question_id": 1080,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701833088,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1113323339/",
            "is_pending": "Not Pending",
            "title": "Camelcase Matching",
            "memory": "8 MB",
            "code": "class TrieNode {\n    public:\n    char data;\n    TrieNode *children[58];\n    bool isTerminal;\n    \n    TrieNode(char ch) : data(ch), isTerminal(false) {\n        for(int i=0; i<58; ++i) {\n            children[i] = 0;\n        }\n    }\n};\n\nclass Trie {\n    TrieNode *root;\n    void insertUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            root->isTerminal = true;\n            return;\n        }\n        int index = word[i] - 'A';\n        if(!root->children[index]) {\n            root->children[index] = new TrieNode(word[i]);\n        }\n        insertUtil(root->children[index], word, i+1);\n    }\n    bool searchUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            return root->isTerminal;\n        }\n        int index = word[i] - 'A';\n        if(root->children[index]) {\n            return searchUtil(root->children[index], word, i+1);\n        } else if(islower(word[i])) {\n            return searchUtil(root, word, i+1);\n        }\n        return false;\n    }\npublic:\n    Trie() {\n        root = new TrieNode('\\0');\n    }\n    \n    void insert(string &word) {\n        insertUtil(root, word, 0);\n    }\n    \n    bool search(string &word) {\n        return searchUtil(root, word, 0);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> camelMatch(vector<string>& queries, string pattern) {\n        vector<bool> ans;\n        Trie trie;\n        trie.insert(pattern);\n        for(auto query: queries) {\n            ans.push_back(trie.search(query));\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "camelcase-matching",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113309344,
            "question_id": 692,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701831147,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/1113309344/",
            "is_pending": "Not Pending",
            "title": "Top K Frequent Words",
            "memory": "18.9 MB",
            "code": "class comp {\n    public:\n    bool operator()(const pair<int,string> &a, const pair<int,string> &b) {\n        return a.first == b.first ? a < b : a.first > b.first;\n    }\n};\n\nclass TrieNode {\n    public:\n    char data;\n    TrieNode *children[26];\n    bool isTerminal;\n    int freq;\n    \n    TrieNode(char ch) : data(ch), isTerminal(false) {\n        for(int i=0; i<26; ++i) {\n            children[i] = 0;\n        }\n        freq = 0;\n    }\n};\n\nclass Trie {\n    TrieNode *root;\n    void insertUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            root->isTerminal = true;\n            ++root->freq;\n            return;\n        }\n        int index = word[i] - 'a';\n        if(!root->children[index]) {\n            root->children[index] = new TrieNode(word[i]);\n        }\n        insertUtil(root->children[index], word, i+1);\n    }\n    void traverseUtil(TrieNode *root, string &s, priority_queue<pair<int,string>, vector<pair<int,string>>, comp> &pq, int &k) {\n        if(!root) {\n            return;\n        }\n        if(root->isTerminal) {\n            // cout<<s<<\" \"<<root->freq<<endl;\n            // Stores top k frequent words\n            if(pq.size() < k) {\n                pq.push({root->freq, s});\n            } else if(pq.size() == k && root->freq > pq.top().first) {\n                pq.pop();\n                pq.push({root->freq, s});\n            }\n        }\n        for(int i=0; i<26; i++) {\n            if(root->children[i]) {\n                s.push_back(i + 'a');\n                traverseUtil(root->children[i], s, pq, k);\n                s.pop_back(); // Backtracking\n            }\n        }\n    }\npublic:\n    Trie() {\n        root = new TrieNode('\\0');\n    }\n    \n    void insert(string word) {\n        insertUtil(root, word, 0);\n    }\n    \n    void traverse(priority_queue<pair<int,string>, vector<pair<int,string>>, comp> &pq, int &k) {\n        string s;\n        traverseUtil(root, s, pq, k);\n    }\n};\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n        Trie trie;\n        vector<string> ans;\n        for(auto word: words) {\n            trie.insert(word);\n        }\n        \n        priority_queue<pair<int,string>, vector<pair<int,string>>, comp> pq;\n        trie.traverse(pq, k);\n        \n        while(!pq.empty()) {\n            auto top = pq.top(); pq.pop();\n            ans.push_back(top.second);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "top-k-frequent-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1113309242,
            "question_id": 692,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 2 weeks",
            "timestamp": 1701831133,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "20 ms",
            "url": "/submissions/detail/1113309242/",
            "is_pending": "Not Pending",
            "title": "Top K Frequent Words",
            "memory": "18.8 MB",
            "code": "class comp {\n    public:\n    bool operator()(const pair<int,string> &a, const pair<int,string> &b) {\n        return a.first == b.first ? a < b : a.first > b.first;\n    }\n};\n\nclass TrieNode {\n    public:\n    char data;\n    TrieNode *children[26];\n    bool isTerminal;\n    int freq;\n    \n    TrieNode(char ch) : data(ch), isTerminal(false) {\n        for(int i=0; i<26; ++i) {\n            children[i] = 0;\n        }\n        freq = 0;\n    }\n};\n\nclass Trie {\n    TrieNode *root;\n    void insertUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            root->isTerminal = true;\n            ++root->freq;\n            return;\n        }\n        int index = word[i] - 'a';\n        if(!root->children[index]) {\n            root->children[index] = new TrieNode(word[i]);\n        }\n        insertUtil(root->children[index], word, i+1);\n    }\n    void traverseUtil(TrieNode *root, string &s, priority_queue<pair<int,string>, vector<pair<int,string>>, comp> &pq, int &k) {\n        if(!root) {\n            return;\n        }\n        if(root->isTerminal) {\n            // cout<<s<<\" \"<<root->freq<<endl;\n            // Stores top k frequent words\n            if(pq.size() < k) {\n                pq.push({root->freq, s});\n            } else if(pq.size() == k && root->freq > pq.top().first) {\n                pq.pop();\n                pq.push({root->freq, s});\n            }\n        }\n        for(int i=0; i<26; i++) {\n            if(root->children[i]) {\n                s.push_back(i + 'a');\n                traverseUtil(root->children[i], s, pq, k);\n                s.pop_back(); // Backtracking\n            }\n        }\n    }\npublic:\n    Trie() {\n        root = new TrieNode('\\0');\n    }\n    \n    void insert(string word) {\n        insertUtil(root, word, 0);\n    }\n    \n    void traverse(priority_queue<pair<int,string>, vector<pair<int,string>>, comp> &pq, int &k) {\n        string s;\n        traverseUtil(root, s, pq, k);\n    }\n};\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n        Trie trie;\n        vector<string> ans;\n        for(auto word: words) {\n            trie.insert(word);\n        }\n        \n        priority_queue<pair<int,string>, vector<pair<int,string>>, comp> pq;\n        trie.traverse(pq, k);\n        \n        while(!pq.empty()) {\n            auto top = pq.top(); pq.pop();\n            ans.push_back(top.second);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "top-k-frequent-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1112598037,
            "question_id": 648,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701747223,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "79 ms",
            "url": "/submissions/detail/1112598037/",
            "is_pending": "Not Pending",
            "title": "Replace Words",
            "memory": "71.6 MB",
            "code": "class TrieNode {\n    public:\n    char data;\n    TrieNode *children[26];\n    bool isTerminal;\n    \n    TrieNode(char ch) : data(ch), isTerminal(false) {\n        for(int i=0; i<26; ++i) {\n            children[i] = 0;\n        }\n    }\n};\n\nclass Trie {\n    TrieNode *root;\n    void insertUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            root->isTerminal = true;\n            return;\n        }\n        int index = word[i] - 'a';\n        if(!root->children[index]) {\n            root->children[index] = new TrieNode(word[i]);\n        }\n        insertUtil(root->children[index], word, i+1);\n    }\n    bool searchUtil(TrieNode *root, string &word, int &i) {\n        if(root->isTerminal) return true;\n        if(i >= word.size()) {\n            return root->isTerminal;\n        }\n        int index = word[i++] - 'a';\n        if(root->children[index]) {\n            return searchUtil(root->children[index], word, i);\n        }\n        return false;\n    }\n    bool startWithUtil(TrieNode* root, string &word, int i) {\n        if(i >= word.size()) {\n            return true;\n        }\n        int index = word[i] - 'a';\n        if(root->children[index]) {\n            return startWithUtil(root->children[index], word, i+1);\n        }\n        return false;\n    }\npublic:\n    Trie() {\n        root = new TrieNode('\\0');\n    }\n    \n    void insert(string word) {\n        insertUtil(root, word, 0);\n    }\n    \n    int search(string word) {\n        int i = 0;\n        bool gotIt = searchUtil(root, word, i);\n        return gotIt ? i : -1;\n    }\n    \n    bool startsWith(string prefix) {\n        return startWithUtil(root, prefix, 0);\n    }\n};\n\nclass Solution {\npublic:\n    string replaceWords(vector<string>& dictionary, string sentence) {\n        string ans;\n        Trie trie;\n        \n        // Insert dict into trie\n        for(auto root: dictionary) {\n            trie.insert(root);\n        }\n        \n        // Pick each word and find in Trie whether the root is available or not\n        int start = 0, end = 0;\n        while(end < sentence.size()) {\n            if(sentence[end] == ' ' || end == sentence.size() - 1) {\n                int len = end == sentence.size() - 1 ? sentence.size() : end - start;\n                const string &temp = sentence.substr(start, len);\n                int trieMatchIndex = trie.search(temp);\n                ans += trieMatchIndex != -1 ? temp.substr(0, trieMatchIndex) : temp;\n                if(sentence[end] == ' ') {\n                    ans += \" \";\n                }\n                start = end + 1;\n            }\n            ++end;\n        }\n        return ans;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "replace-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1112325177,
            "question_id": 208,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701711388,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "43 ms",
            "url": "/submissions/detail/1112325177/",
            "is_pending": "Not Pending",
            "title": "Implement Trie (Prefix Tree)",
            "memory": "44 MB",
            "code": "class TrieNode {\n    public:\n    char data;\n    TrieNode *children[26];\n    bool isTerminal;\n    \n    TrieNode(char ch) : data(ch), isTerminal(false) {\n        for(int i=0; i<26; ++i) {\n            children[i] = 0;\n        }\n    }\n};\n\nclass Trie {\n    TrieNode *root;\n    void insertUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            root->isTerminal = true;\n            return;\n        }\n        int index = word[i] - 'a';\n        if(!root->children[index]) {\n            root->children[index] = new TrieNode(word[i]);\n        }\n        insertUtil(root->children[index], word, i+1);\n    }\n    bool searchUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            return root->isTerminal;\n        }\n        int index = word[i] - 'a';\n        if(root->children[index]) {\n            return searchUtil(root->children[index], word, i+1);\n        }\n        return false;\n    }\n    bool startWithUtil(TrieNode* root, string &word, int i) {\n        if(i >= word.size()) {\n            return true;\n        }\n        int index = word[i] - 'a';\n        if(root->children[index]) {\n            return startWithUtil(root->children[index], word, i+1);\n        }\n        return false;\n    }\npublic:\n    Trie() {\n        root = new TrieNode('\\0');\n    }\n    \n    void insert(string word) {\n        insertUtil(root, word, 0);\n    }\n    \n    bool search(string word) {\n        return searchUtil(root, word, 0);\n    }\n    \n    bool startsWith(string prefix) {\n        return startWithUtil(root, prefix, 0);\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */",
            "compare_result": "1111111111111111",
            "title_slug": "implement-trie-prefix-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1112325057,
            "question_id": 208,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701711378,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "54 ms",
            "url": "/submissions/detail/1112325057/",
            "is_pending": "Not Pending",
            "title": "Implement Trie (Prefix Tree)",
            "memory": "43.9 MB",
            "code": "class TrieNode {\n    public:\n    char data;\n    TrieNode *children[26];\n    bool isTerminal;\n    \n    TrieNode(char ch) : data(ch), isTerminal(false) {\n        for(int i=0; i<26; ++i) {\n            children[i] = 0;\n        }\n    }\n};\n\nclass Trie {\n    TrieNode *root;\n    void insertUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            root->isTerminal = true;\n            return;\n        }\n        int index = word[i] - 'a';\n        if(!root->children[index]) {\n            root->children[index] = new TrieNode(word[i]);\n        }\n        insertUtil(root->children[index], word, i+1);\n    }\n    bool searchUtil(TrieNode *root, string &word, int i) {\n        if(i >= word.size()) {\n            return root->isTerminal;\n        }\n        int index = word[i] - 'a';\n        if(root->children[index]) {\n            return searchUtil(root->children[index], word, i+1);\n        }\n        return false;\n    }\n    bool startWithUtil(TrieNode* root, string &word, int i) {\n        if(i >= word.size()) {\n            return true;\n        }\n        int index = word[i] - 'a';\n        if(root->children[index]) {\n            return startWithUtil(root->children[index], word, i+1);\n        }\n        return false;\n    }\npublic:\n    Trie() {\n        root = new TrieNode('\\0');\n    }\n    \n    void insert(string word) {\n        insertUtil(root, word, 0);\n    }\n    \n    bool search(string word) {\n        return searchUtil(root, word, 0);\n    }\n    \n    bool startsWith(string prefix) {\n        return startWithUtil(root, prefix, 0);\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */",
            "compare_result": "1111111111111111",
            "title_slug": "implement-trie-prefix-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1109308917,
            "question_id": 902,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701317898,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/1109308917/",
            "is_pending": "Not Pending",
            "title": "Minimum Number of Refueling Stops",
            "memory": "16.7 MB",
            "code": "class Solution {\npublic:\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\n        int stops = 0;\n        int dist = 0;\n        int i = 0;\n        int fuel = startFuel;\n        priority_queue<pair<int,int>> pq; // {fuel, pos}\n        \n        while(true) {\n            while(i < stations.size()) {\n                // Push stations within the reach with my current fuel levels from my current pos.\n                if(stations[i][0] <= dist + fuel) {\n                    pq.push({stations[i][1], stations[i][0]});\n                } else {\n                    break;\n                }\n                ++i;\n            }\n            \n            // Travel with full fuel level\n            dist += fuel;\n            fuel = 0;\n            \n            // Reached\n            if(dist >= target) break;\n            \n            // No fuel stations within reach\n            if(pq.empty()) {\n                stops = -1;\n                break;\n            }\n            \n            // Refuel ans re-adjust dist & fuel based on the distance travelled.\n            auto &top = pq.top();\n            fuel = (dist-top.second) + top.first;\n            dist = top.second;\n            pq.pop();\n            ++stops;\n        }\n        return stops;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-number-of-refueling-stops",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1109308842,
            "question_id": 902,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701317889,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "21 ms",
            "url": "/submissions/detail/1109308842/",
            "is_pending": "Not Pending",
            "title": "Minimum Number of Refueling Stops",
            "memory": "16.8 MB",
            "code": "class Solution {\npublic:\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\n        int stops = 0;\n        int dist = 0;\n        int i = 0;\n        int fuel = startFuel;\n        priority_queue<pair<int,int>> pq; // {fuel, pos}\n        \n        while(true) {\n            while(i < stations.size()) {\n                // Push stations within the reach with my current fuel levels from my current pos.\n                if(stations[i][0] <= dist + fuel) {\n                    pq.push({stations[i][1], stations[i][0]});\n                } else {\n                    break;\n                }\n                ++i;\n            }\n            \n            // Travel with full fuel level\n            dist += fuel;\n            fuel = 0;\n            \n            // Reached\n            if(dist >= target) break;\n            \n            // No fuel stations within reach\n            if(pq.empty()) {\n                stops = -1;\n                break;\n            }\n            \n            // Refuel ans re-adjust dist & fuel based on the distance travelled.\n            auto &top = pq.top();\n            fuel = (dist-top.second) + top.first;\n            dist = top.second;\n            pq.pop();\n            ++stops;\n        }\n        return stops;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-number-of-refueling-stops",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1109308692,
            "question_id": 902,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701317870,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/1109308692/",
            "is_pending": "Not Pending",
            "title": "Minimum Number of Refueling Stops",
            "memory": "16.8 MB",
            "code": "class Solution {\npublic:\n    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {\n        int stops = 0;\n        int dist = 0;\n        int i = 0;\n        int fuel = startFuel;\n        priority_queue<pair<int,int>> pq; // {fuel, pos}\n        \n        while(true) {\n            while(i < stations.size()) {\n                // Push stations within the reach with my current fuel levels from my current pos.\n                if(stations[i][0] <= dist + fuel) {\n                    pq.push({stations[i][1], stations[i][0]});\n                } else {\n                    break;\n                }\n                ++i;\n            }\n            \n            // Travel with full fuel level\n            dist += fuel;\n            fuel = 0;\n            \n            // Reached\n            if(dist >= target) break;\n            \n            // No fuel stations within reach\n            if(pq.empty()) {\n                stops = -1;\n                break;\n            }\n            \n            // Refuel ans re-adjust dist & fuel based on the distance travelled.\n            auto &top = pq.top();\n            fuel = (dist-top.second) + top.first;\n            dist = top.second;\n            pq.pop();\n            ++stops;\n        }\n        return stops;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-number-of-refueling-stops",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1109301420,
            "question_id": 2267,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701316913,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "475 ms",
            "url": "/submissions/detail/1109301420/",
            "is_pending": "Not Pending",
            "title": "Minimum Difference in Sums After Removal of Elements",
            "memory": "159.4 MB",
            "code": "class Solution {\n#define ll long long\npublic:\n    long long minimumDifference(vector<int>& nums) {\n        int n = nums.size() / 3;\n        vector<ll> prefix(nums.size(), -1), suffix(nums.size(), -1);\n        // prefix[i] = Sum of first n elements from left side.\n        // siffix[i] = Sum of first n elements from right side.\n        \n        ll sum = 0; // Min n elements sum\n        \n        priority_queue<ll> pq; // Max heap\n        for(int i=0; i<nums.size(); ++i) {\n            sum += nums[i];\n            pq.push(nums[i]);\n            \n            // Pop out max elements\n            if(pq.size() > n) {\n                sum -= pq.top(); pq.pop();\n            }\n            if(pq.size() == n) {\n                prefix[i] = sum;\n            }\n        }\n        \n        sum = 0; // Max n elements sum\n        \n        priority_queue<ll, vector<ll>, greater<ll>> pq2; // Min heap\n        for(int i=nums.size()-1; i>=0; --i) {\n            sum += nums[i];\n            pq2.push(nums[i]);\n            \n            // Pop out min elements\n            if(pq2.size() > n) {\n                sum -= pq2.top(); pq2.pop();\n            }\n            if(pq2.size() == n) {\n                suffix[i] = sum;\n            }\n        }\n        \n        ll ans = LONG_LONG_MAX;\n        for(int i=n-1; i<2*n; ++i) {\n            ans = min(ans, prefix[i]-suffix[i+1]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-difference-in-sums-after-removal-of-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1109301308,
            "question_id": 2267,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701316899,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "482 ms",
            "url": "/submissions/detail/1109301308/",
            "is_pending": "Not Pending",
            "title": "Minimum Difference in Sums After Removal of Elements",
            "memory": "159.3 MB",
            "code": "class Solution {\n#define ll long long\npublic:\n    long long minimumDifference(vector<int>& nums) {\n        int n = nums.size() / 3;\n        vector<ll> prefix(nums.size(), -1), suffix(nums.size(), -1);\n        // prefix[i] = Sum of first n elements from left side.\n        // siffix[i] = Sum of first n elements from right side.\n        \n        ll sum = 0; // Min n elements sum\n        \n        priority_queue<ll> pq; // Max heap\n        for(int i=0; i<nums.size(); ++i) {\n            sum += nums[i];\n            pq.push(nums[i]);\n            \n            // Pop out max elements\n            if(pq.size() > n) {\n                sum -= pq.top(); pq.pop();\n            }\n            if(pq.size() == n) {\n                prefix[i] = sum;\n            }\n        }\n        \n        sum = 0; // Max n elements sum\n        \n        priority_queue<ll, vector<ll>, greater<ll>> pq2; // Min heap\n        for(int i=nums.size()-1; i>=0; --i) {\n            sum += nums[i];\n            pq2.push(nums[i]);\n            \n            // Pop out min elements\n            if(pq2.size() > n) {\n                sum -= pq2.top(); pq2.pop();\n            }\n            if(pq2.size() == n) {\n                suffix[i] = sum;\n            }\n        }\n        \n        ll ans = LONG_LONG_MAX;\n        for(int i=n-1; i<2*n; ++i) {\n            ans = min(ans, prefix[i]-suffix[i+1]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-difference-in-sums-after-removal-of-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1109300802,
            "question_id": 2267,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701316832,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1109300802/",
            "is_pending": "Not Pending",
            "title": "Minimum Difference in Sums After Removal of Elements",
            "memory": "N/A",
            "code": "class Solution {\n#define ll long long\npublic:\n    long long minimumDifference(vector<int>& nums) {\n        int n = nums.size() / 3;\n        vector<ll> prefix(nums.size(), -1), suffix(nums.size(), -1);\n        // prefix[i] = Sum of first n elements from left side.\n        // siffix[i] = Sum of first n elements from right side.\n        \n        ll sum = 0; // Min n elements sum\n        \n        priority_queue<ll> pq; // Max heap\n        for(int i=0; i<nums.size(); ++i) {\n            sum += nums[i];\n            pq.push(nums[i]);\n            \n            // Pop out max elements\n            if(pq.size() > n) {\n                sum -= pq.top(); pq.pop();\n            }\n            if(pq.size() == n) {\n                prefix[i] = sum;\n            }\n        }\n        \n        sum = 0; // Max n elements sum\n        \n        priority_queue<ll, vector<ll>, greater<ll>> pq2; // Min heap\n        for(int i=nums.size()-1; i>=0; --i) {\n            sum += nums[i];\n            pq2.push(nums[i]);\n            \n            // Pop out min elements\n            if(pq2.size() > n) {\n                sum -+ pq2.top(); pq2.pop();\n            }\n            if(pq2.size() == n) {\n                suffix[i] = sum;\n            }\n        }\n        \n        ll ans = LONG_LONG_MAX;\n        for(int i=n-1; i<2*n; ++i) {\n            ans = min(ans, prefix[i]-suffix[i+1]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "10000000000000000000010000000000000000000000000000000000000000000000000000000000000000000001100011001000000000",
            "title_slug": "minimum-difference-in-sums-after-removal-of-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1109300376,
            "question_id": 2267,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701316775,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1109300376/",
            "is_pending": "Not Pending",
            "title": "Minimum Difference in Sums After Removal of Elements",
            "memory": "N/A",
            "code": "class Solution {\n#define ll long long\npublic:\n    long long minimumDifference(vector<int>& nums) {\n        int n = nums.size() / 3;\n        vector<ll> prefix(nums.size(), -1), suffix(nums.size(), -1);\n        // prefix[i] = Sum of first n elements from left side.\n        // siffix[i] = Sum of first n elements from right side.\n        \n        ll sum = 0; // Min n elements sum\n        \n        priority_queue<ll> pq; // Max heap\n        for(int i=0; i<nums.size(); ++i) {\n            sum += nums[i];\n            pq.push(nums[i]);\n            \n            // Pop out max elements\n            if(pq.size() > n) {\n                sum -= pq.top(); pq.pop();\n            }\n            if(pq.size() == n) {\n                prefix[i] = sum;\n            }\n        }\n        \n        sum = 0; // Max n elements sum\n        \n        priority_queue<ll, vector<ll>, greater<ll>> pq2; // Min heap\n        for(int i=nums.size()-1; i>=0; --i) {\n            sum += nums[i];\n            pq2.push(nums[i]);\n            \n            // Pop out min elements\n            if(pq2.size() > n) {\n                sum -+ pq2.top(); pq2.pop();\n            }\n            if(pq2.size() == n) {\n                suffix[i] = sum;\n            }\n        }\n        \n        ll ans = LONG_LONG_MAX;\n        for(int i=n-1; i<2*n; ++i) {\n            ans = min(ans, prefix[i]-suffix[i+1]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "10000000000000000000010000000000000000000000000000000000000000000000000000000000000000000001100011001000000000",
            "title_slug": "minimum-difference-in-sums-after-removal-of-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1108565819,
            "question_id": 1990,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701224401,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "156 ms",
            "url": "/submissions/detail/1108565819/",
            "is_pending": "Not Pending",
            "title": "Get Biggest Three Rhombus Sums in a Grid",
            "memory": "27.5 MB",
            "code": "class Solution {\npublic:\n    bool checkBounds(vector<vector<int>> &grid, vector<pair<int,int>> &v) {\n        int m = grid.size();\n        int n = grid[0].size();\n        for(auto pt: v) {\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool getAllVertices(vector<vector<int>> &grid, vector<pair<int,int>> &v, pair<int,int> c, int &delta) {\n        pair<int, int> A(c.first-delta, c.second);\n        pair<int, int> B(c.first, c.second+delta);\n        pair<int, int> C(c.first+delta, c.second);\n        pair<int, int> D(c.first, c.second-delta);\n        v[0] = A;\n        v[1] = B;\n        v[2] = C;\n        v[3] = D;\n        if(checkBounds(grid, v)) {\n            return true;\n        }\n        return false;\n    }\n    void getAllSum(vector<vector<int>> &grid, int &cx, int &cy, priority_queue<int> &pq) {\n        \n        // Push RH with area 0;\n        pq.push(grid[cx][cy]);\n        int delta = 1;\n        vector<pair<int,int>>v(4);\n        while(getAllVertices(grid, v, {cx, cy}, delta)) {\n            pair<int, int> &A = v[0];\n            pair<int, int> &B = v[1];\n            pair<int, int> &C = v[2];\n            pair<int, int> &D = v[3];\n            int csum = grid[A.first][A.second] + grid[B.first][B.second] +\n                       grid[C.first][C.second] + grid[D.first][D.second];\n            \n            // All cells between AB\n            for(int i=1; i<B.first-A.first; ++i) {\n                csum += grid[A.first+i][A.second+i];\n            }\n            // All cells between BC\n            for(int i=1; i<C.first-B.first; ++i) {\n                csum += grid[B.first+i][B.second-i];\n            }\n            // All cells between CD\n            for(int i=1; i<C.first-D.first; ++i) {\n                csum += grid[C.first-i][C.second-i];\n            }\n            // All cells between DA\n            for(int i=1; i<D.first-A.first; ++i) {\n                csum += grid[D.first-i][D.second+i];\n            }\n            pq.push(csum); // RH sum has been pushed.\n            ++delta;\n        }\n    }\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\n        vector<int> ans;\n        priority_queue<int> pq;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                getAllSum(grid, i, j, pq);\n            }\n        }\n        while(!pq.empty() && ans.size() < 3) {\n            int top = pq.top();\n            pq.pop();\n            if(find(ans.begin(), ans.end(), top) == ans.end()) {\n                ans.push_back(top);\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "get-biggest-three-rhombus-sums-in-a-grid",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1108565679,
            "question_id": 1990,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "4 months, 3 weeks",
            "timestamp": 1701224382,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "167 ms",
            "url": "/submissions/detail/1108565679/",
            "is_pending": "Not Pending",
            "title": "Get Biggest Three Rhombus Sums in a Grid",
            "memory": "27.5 MB",
            "code": "class Solution {\npublic:\n    bool checkBounds(vector<vector<int>> &grid, vector<pair<int,int>> &v) {\n        int m = grid.size();\n        int n = grid[0].size();\n        for(auto pt: v) {\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool getAllVertices(vector<vector<int>> &grid, vector<pair<int,int>> &v, pair<int,int> c, int &delta) {\n        pair<int, int> A(c.first-delta, c.second);\n        pair<int, int> B(c.first, c.second+delta);\n        pair<int, int> C(c.first+delta, c.second);\n        pair<int, int> D(c.first, c.second-delta);\n        v[0] = A;\n        v[1] = B;\n        v[2] = C;\n        v[3] = D;\n        if(checkBounds(grid, v)) {\n            return true;\n        }\n        return false;\n    }\n    void getAllSum(vector<vector<int>> &grid, int &cx, int &cy, priority_queue<int> &pq) {\n        \n        // Push RH with area 0;\n        pq.push(grid[cx][cy]);\n        int delta = 1;\n        vector<pair<int,int>>v(4);\n        while(getAllVertices(grid, v, {cx, cy}, delta)) {\n            pair<int, int> &A = v[0];\n            pair<int, int> &B = v[1];\n            pair<int, int> &C = v[2];\n            pair<int, int> &D = v[3];\n            int csum = grid[A.first][A.second] + grid[B.first][B.second] +\n                       grid[C.first][C.second] + grid[D.first][D.second];\n            \n            // All cells between AB\n            for(int i=1; i<B.first-A.first; ++i) {\n                csum += grid[A.first+i][A.second+i];\n            }\n            // All cells between BC\n            for(int i=1; i<C.first-B.first; ++i) {\n                csum += grid[B.first+i][B.second-i];\n            }\n            // All cells between CD\n            for(int i=1; i<C.first-D.first; ++i) {\n                csum += grid[C.first-i][C.second-i];\n            }\n            // All cells between DA\n            for(int i=1; i<D.first-A.first; ++i) {\n                csum += grid[D.first-i][D.second+i];\n            }\n            pq.push(csum); // RH sum has been pushed.\n            ++delta;\n        }\n    }\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\n        vector<int> ans;\n        priority_queue<int> pq;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                getAllSum(grid, i, j, pq);\n            }\n        }\n        while(!pq.empty() && ans.size() < 3) {\n            int top = pq.top();\n            pq.pop();\n            if(find(ans.begin(), ans.end(), top) == ans.end()) {\n                ans.push_back(top);\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "get-biggest-three-rhombus-sums-in-a-grid",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1092168841,
            "question_id": 1990,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1699203199,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "155 ms",
            "url": "/submissions/detail/1092168841/",
            "is_pending": "Not Pending",
            "title": "Get Biggest Three Rhombus Sums in a Grid",
            "memory": "27.6 MB",
            "code": "class Solution {\npublic:\n    bool checkBounds(vector<vector<int>> &grid, vector<pair<int, int>> &v) {\n        int m = grid.size();\n        int n = grid[0].size();\n        for(auto pt:v) {\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool getAllVertices(vector<vector<int>> &grid, pair<int,int> c, int &delta, vector<pair<int,int>> &v) {\n        pair<int,int> A(c.first-delta, c.second);\n        pair<int,int> B(c.first, c.second+delta);\n        pair<int,int> C(c.first+delta, c.second);\n        pair<int,int> D(c.first, c.second-delta);\n        v[0] = A; v[1] = B; v[2] = C; v[3] = D;\n        if(checkBounds(grid, v)) {\n            return true;\n        }\n        return false;\n    }\n    void getAllSum(vector<vector<int>> &grid, int &cx, int &cy, priority_queue<int> &pq) {\n        // Push RH sum of RH with area 0\n        pq.push(grid[cx][cy]);\n        int delta = 1;\n        vector<pair<int,int>> v(4);\n        while(getAllVertices(grid, {cx, cy}, delta, v)) {\n            pair<int, int> &A = v[0];\n            pair<int, int> &B = v[1];\n            pair<int, int> &C = v[2];\n            pair<int, int> &D = v[3];\n            int csum = grid[A.first][A.second] + grid[B.first][B.second] +\n                       grid[C.first][C.second] + grid[D.first][D.second];\n            \n            // All cells between AB\n            for(int i=1; i<(B.first-A.first); ++i) {\n                csum += grid[A.first+i][A.second+i];\n            }\n            \n            // All cells between BC\n            for(int i=1; i<(C.first-B.first); ++i) {\n                csum += grid[B.first+i][B.second-i];\n            }\n            \n            // All cells between CD\n            for(int i=1; i<(C.first-D.first); ++i) {\n                csum += grid[C.first-i][C.second-i];\n            }\n            \n            // All cells between DA\n            for(int i=1; i<(D.first-A.first); ++i) {\n                csum += grid[D.first-i][D.second+i];\n            }\n            \n            pq.push(csum); // RH sum has beed pushed.\n            ++delta;\n        }\n    }\n    bool canpush(vector<int> ans, int top) {\n        for(auto val: ans) {\n            if(top == val) {\n                return false;\n            }\n        }\n        return true;\n    }\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\n        vector<int> ans;\n        priority_queue<int> pq;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        for(int i=0; i<m; ++i) {\n            for(int j=0; j<n; ++j) {\n                getAllSum(grid, i, j, pq);\n            }\n        }\n        \n        while(!pq.empty() && ans.size() < 3) {\n            int top = pq.top(); pq.pop();\n            if(find(ans.begin(), ans.end(), top) == ans.end()) {\n                ans.push_back(top);\n            }\n            // if(canpush(ans, top)) {\n            //     ans.push_back(top);\n            // }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "get-biggest-three-rhombus-sums-in-a-grid",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1092168626,
            "question_id": 1990,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1699203181,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "158 ms",
            "url": "/submissions/detail/1092168626/",
            "is_pending": "Not Pending",
            "title": "Get Biggest Three Rhombus Sums in a Grid",
            "memory": "27.3 MB",
            "code": "class Solution {\npublic:\n    bool checkBounds(vector<vector<int>> &grid, vector<pair<int, int>> &v) {\n        int m = grid.size();\n        int n = grid[0].size();\n        for(auto pt:v) {\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool getAllVertices(vector<vector<int>> &grid, pair<int,int> c, int &delta, vector<pair<int,int>> &v) {\n        pair<int,int> A(c.first-delta, c.second);\n        pair<int,int> B(c.first, c.second+delta);\n        pair<int,int> C(c.first+delta, c.second);\n        pair<int,int> D(c.first, c.second-delta);\n        v[0] = A; v[1] = B; v[2] = C; v[3] = D;\n        if(checkBounds(grid, v)) {\n            return true;\n        }\n        return false;\n    }\n    void getAllSum(vector<vector<int>> &grid, int &cx, int &cy, priority_queue<int> &pq) {\n        // Push RH sum of RH with area 0\n        pq.push(grid[cx][cy]);\n        int delta = 1;\n        vector<pair<int,int>> v(4);\n        while(getAllVertices(grid, {cx, cy}, delta, v)) {\n            pair<int, int> &A = v[0];\n            pair<int, int> &B = v[1];\n            pair<int, int> &C = v[2];\n            pair<int, int> &D = v[3];\n            int csum = grid[A.first][A.second] + grid[B.first][B.second] +\n                       grid[C.first][C.second] + grid[D.first][D.second];\n            \n            // All cells between AB\n            for(int i=1; i<(B.first-A.first); ++i) {\n                csum += grid[A.first+i][A.second+i];\n            }\n            \n            // All cells between BC\n            for(int i=1; i<(C.first-B.first); ++i) {\n                csum += grid[B.first+i][B.second-i];\n            }\n            \n            // All cells between CD\n            for(int i=1; i<(C.first-D.first); ++i) {\n                csum += grid[C.first-i][C.second-i];\n            }\n            \n            // All cells between DA\n            for(int i=1; i<(D.first-A.first); ++i) {\n                csum += grid[D.first-i][D.second+i];\n            }\n            \n            pq.push(csum); // RH sum has beed pushed.\n            ++delta;\n        }\n    }\n    bool canpush(vector<int> ans, int top) {\n        for(auto val: ans) {\n            if(top == val) {\n                return false;\n            }\n        }\n        return true;\n    }\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\n        vector<int> ans;\n        priority_queue<int> pq;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        for(int i=0; i<m; ++i) {\n            for(int j=0; j<n; ++j) {\n                getAllSum(grid, i, j, pq);\n            }\n        }\n        \n        while(!pq.empty() && ans.size() < 3) {\n            int top = pq.top(); pq.pop();\n            if(find(ans.begin(), ans.end(), top) == ans.end()) {\n                ans.push_back(top);\n            }\n            // if(canpush(ans, top)) {\n            //     ans.push_back(top);\n            // }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "get-biggest-three-rhombus-sums-in-a-grid",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1092168123,
            "question_id": 1990,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1699203137,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "164 ms",
            "url": "/submissions/detail/1092168123/",
            "is_pending": "Not Pending",
            "title": "Get Biggest Three Rhombus Sums in a Grid",
            "memory": "27.6 MB",
            "code": "class Solution {\npublic:\n    bool checkBounds(vector<vector<int>> &grid, vector<pair<int, int>> &v) {\n        int m = grid.size();\n        int n = grid[0].size();\n        for(auto pt:v) {\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool getAllVertices(vector<vector<int>> &grid, pair<int,int> c, int &delta, vector<pair<int,int>> &v) {\n        pair<int,int> A(c.first-delta, c.second);\n        pair<int,int> B(c.first, c.second+delta);\n        pair<int,int> C(c.first+delta, c.second);\n        pair<int,int> D(c.first, c.second-delta);\n        v[0] = A; v[1] = B; v[2] = C; v[3] = D;\n        if(checkBounds(grid, v)) {\n            return true;\n        }\n        return false;\n    }\n    void getAllSum(vector<vector<int>> &grid, int &cx, int &cy, priority_queue<int> &pq) {\n        // Push RH sum of RH with area 0\n        pq.push(grid[cx][cy]);\n        int delta = 1;\n        vector<pair<int,int>> v(4);\n        while(getAllVertices(grid, {cx, cy}, delta, v)) {\n            pair<int, int> &A = v[0];\n            pair<int, int> &B = v[1];\n            pair<int, int> &C = v[2];\n            pair<int, int> &D = v[3];\n            int csum = grid[A.first][A.second] + grid[B.first][B.second] +\n                       grid[C.first][C.second] + grid[D.first][D.second];\n            \n            // All cells between AB\n            for(int i=1; i<(B.first-A.first); ++i) {\n                csum += grid[A.first+i][A.second+i];\n            }\n            \n            // All cells between BC\n            for(int i=1; i<(C.first-B.first); ++i) {\n                csum += grid[B.first+i][B.second-i];\n            }\n            \n            // All cells between CD\n            for(int i=1; i<(C.first-D.first); ++i) {\n                csum += grid[C.first-i][C.second-i];\n            }\n            \n            // All cells between DA\n            for(int i=1; i<(D.first-A.first); ++i) {\n                csum += grid[D.first-i][D.second+i];\n            }\n            \n            pq.push(csum); // RH sum has beed pushed.\n            ++delta;\n        }\n    }\n    bool canpush(vector<int> ans, int top) {\n        for(auto val: ans) {\n            if(top == val) {\n                return false;\n            }\n        }\n        return true;\n    }\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\n        vector<int> ans;\n        priority_queue<int> pq;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        for(int i=0; i<m; ++i) {\n            for(int j=0; j<n; ++j) {\n                getAllSum(grid, i, j, pq);\n            }\n        }\n        \n        while(!pq.empty() && ans.size() < 3) {\n            int top = pq.top(); pq.pop();\n            // if(find(ans.begin(), ans.end(), top) == ans.end()) {\n            //     ans.push_back(top);\n            // }\n            if(canpush(ans, top)) {\n                ans.push_back(top);\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "get-biggest-three-rhombus-sums-in-a-grid",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1092167926,
            "question_id": 1990,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1699203122,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "166 ms",
            "url": "/submissions/detail/1092167926/",
            "is_pending": "Not Pending",
            "title": "Get Biggest Three Rhombus Sums in a Grid",
            "memory": "27.4 MB",
            "code": "class Solution {\npublic:\n    bool checkBounds(vector<vector<int>> &grid, vector<pair<int, int>> &v) {\n        int m = grid.size();\n        int n = grid[0].size();\n        for(auto pt:v) {\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool getAllVertices(vector<vector<int>> &grid, pair<int,int> c, int &delta, vector<pair<int,int>> &v) {\n        pair<int,int> A(c.first-delta, c.second);\n        pair<int,int> B(c.first, c.second+delta);\n        pair<int,int> C(c.first+delta, c.second);\n        pair<int,int> D(c.first, c.second-delta);\n        v[0] = A; v[1] = B; v[2] = C; v[3] = D;\n        if(checkBounds(grid, v)) {\n            return true;\n        }\n        return false;\n    }\n    void getAllSum(vector<vector<int>> &grid, int &cx, int &cy, priority_queue<int> &pq) {\n        // Push RH sum of RH with area 0\n        pq.push(grid[cx][cy]);\n        int delta = 1;\n        vector<pair<int,int>> v(4);\n        while(getAllVertices(grid, {cx, cy}, delta, v)) {\n            pair<int, int> &A = v[0];\n            pair<int, int> &B = v[1];\n            pair<int, int> &C = v[2];\n            pair<int, int> &D = v[3];\n            int csum = grid[A.first][A.second] + grid[B.first][B.second] +\n                       grid[C.first][C.second] + grid[D.first][D.second];\n            \n            // All cells between AB\n            for(int i=1; i<(B.first-A.first); ++i) {\n                csum += grid[A.first+i][A.second+i];\n            }\n            \n            // All cells between BC\n            for(int i=1; i<(C.first-B.first); ++i) {\n                csum += grid[B.first+i][B.second-i];\n            }\n            \n            // All cells between CD\n            for(int i=1; i<(C.first-D.first); ++i) {\n                csum += grid[C.first-i][C.second-i];\n            }\n            \n            // All cells between DA\n            for(int i=1; i<(D.first-A.first); ++i) {\n                csum += grid[D.first-i][D.second+i];\n            }\n            \n            pq.push(csum); // RH sum has beed pushed.\n            ++delta;\n        }\n    }\n    bool canpush(vector<int> ans, int top) {\n        for(auto val: ans) {\n            if(top == val) {\n                return false;\n            }\n        }\n        return true;\n    }\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\n        vector<int> ans;\n        priority_queue<int> pq;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        for(int i=0; i<m; ++i) {\n            for(int j=0; j<n; ++j) {\n                getAllSum(grid, i, j, pq);\n            }\n        }\n        \n        while(!pq.empty() && ans.size() < 3) {\n            int top = pq.top(); pq.pop();\n            // if(find(ans.begin(), ans.end(), top) == ans.end()) {\n            //     ans.push_back(top);\n            // }\n            if(canpush(ans, top)) {\n                ans.push_back(top);\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "get-biggest-three-rhombus-sums-in-a-grid",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1092158383,
            "question_id": 1990,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1699202288,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1092158383/",
            "is_pending": "Not Pending",
            "title": "Get Biggest Three Rhombus Sums in a Grid",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool checkBounds(vector<vector<int>> &grid, vector<pair<int, int>> &v) {\n        int m = grid.size();\n        int n = grid[0].size();\n        for(auto pt:v) {\n            if(pt.first < 0 || pt.first >= m || pt.second < 0 || pt.second >= n) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool getAllVertices(vector<vector<int>> &grid, pair<int,int> c, int &delta, vector<pair<int,int>> &v) {\n        pair<int,int> A(c.first-delta, c.second);\n        pair<int,int> B(c.first, c.second+delta);\n        pair<int,int> C(c.first+delta, c.second);\n        pair<int,int> D(c.first, c.second-delta);\n        v[0] = A; v[1] = B; v[2] = C; v[3] = D;\n        if(checkBounds(grid, v)) {\n            return true;\n        }\n        return false;\n    }\n    void getAllSum(vector<vector<int>> &grid, int &cx, int &cy, priority_queue<int> &pq) {\n        // Push RH sum of RH with area 0\n        pq.push(grid[cx][cy]);\n        int delta = 1;\n        vector<pair<int,int>> v(4);\n        while(getAllVertices(grid, {cx, cy}, delta, v)) {\n            pair<int, int> &A = v[0];\n            pair<int, int> &B = v[1];\n            pair<int, int> &C = v[2];\n            pair<int, int> &D = v[3];\n            int csum = grid[A.first][A.second] + grid[B.first][B.second] +\n                       grid[C.first][C.second] + grid[D.first][D.second];\n            \n            // All cells between AB\n            for(int i=1; i<(B.first-A.first); ++i) {\n                csum += grid[A.first+i][A.second+i];\n            }\n            \n            // All cells between BC\n            for(int i=1; i<(C.first-B.first); ++i) {\n                csum += grid[B.first+i][B.second-i];\n            }\n            \n            // All cells between CD\n            for(int i=1; i<(D.first-C.first); ++i) {\n                csum += grid[C.first-i][D.second-i];\n            }\n            \n            // All cells between DA\n            for(int i=1; i<(A.first-D.first); ++i) {\n                csum += grid[D.first-i][D.second+i];\n            }\n            \n            pq.push(csum); // RH sum has beed pushed.\n            ++delta;\n        }\n    }\n    vector<int> getBiggestThree(vector<vector<int>>& grid) {\n        vector<int> ans;\n        priority_queue<int> pq;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        for(int i=0; i<m; ++i) {\n            for(int j=0; j<n; ++j) {\n                getAllSum(grid, i, j, pq);\n            }\n        }\n        \n        while(!pq.empty() && ans.size() < 3) {\n            int top = pq.top(); pq.pop();\n            if(find(ans.begin(), ans.end(), top) == ans.end()) {\n                ans.push_back(top);\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001101111110",
            "title_slug": "get-biggest-three-rhombus-sums-in-a-grid",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1091247252,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1699099819,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "262 ms",
            "url": "/submissions/detail/1091247252/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "149.1 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> ans;\n        priority_queue<pair<int,int>> pq;\n        \n        // Consider first window\n        for(int i=0; i<k; i++) {\n            pq.push({nums[i], i});\n        }\n        \n        // Store max of first window\n        ans.push_back(pq.top().first);\n        \n        for(int i=k; i<nums.size(); ++i) {\n            pq.push({nums[i], i});\n            \n            // Remove if max if from old windows\n            while(pq.top().second <= i-k) {\n                pq.pop();\n            }\n            ans.push_back(pq.top().first);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1091247128,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1699099801,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "251 ms",
            "url": "/submissions/detail/1091247128/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "149.1 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> ans;\n        priority_queue<pair<int,int>> pq;\n        \n        // Consider first window\n        for(int i=0; i<k; i++) {\n            pq.push({nums[i], i});\n        }\n        \n        // Store max of first window\n        ans.push_back(pq.top().first);\n        \n        for(int i=k; i<nums.size(); ++i) {\n            pq.push({nums[i], i});\n            \n            // Remove if max if from old windows\n            while(pq.top().second <= i-k) {\n                pq.pop();\n            }\n            ans.push_back(pq.top().first);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1090313938,
            "question_id": 1014,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1698981335,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "170 ms",
            "url": "/submissions/detail/1090313938/",
            "is_pending": "Not Pending",
            "title": "K Closest Points to Origin",
            "memory": "70.2 MB",
            "code": "class Solution {\npublic:\n    class mycomp {\n        public:\n        bool operator()(pair<int, int> &a, pair<int, int> &b) {\n            int distA = a.first*a.first + a.second*a.second;\n            int distB = b.first*b.first + b.second*b.second;\n            return distA > distB;\n        }\n    };\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        vector<vector<int>> ans;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomp> pq;\n        for(auto p: points) {\n            pq.push({p[0], p[1]});\n        }\n        while(!pq.empty() && k--) {\n            auto &top = pq.top();\n            ans.push_back({top.first, top.second});\n            pq.pop();\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "k-closest-points-to-origin",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1090313814,
            "question_id": 1014,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "5 months, 3 weeks",
            "timestamp": 1698981320,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "177 ms",
            "url": "/submissions/detail/1090313814/",
            "is_pending": "Not Pending",
            "title": "K Closest Points to Origin",
            "memory": "70.2 MB",
            "code": "class Solution {\npublic:\n    class mycomp {\n        public:\n        bool operator()(pair<int, int> &a, pair<int, int> &b) {\n            int distA = a.first*a.first + a.second*a.second;\n            int distB = b.first*b.first + b.second*b.second;\n            return distA > distB;\n        }\n    };\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        vector<vector<int>> ans;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomp> pq;\n        for(auto p: points) {\n            pq.push({p[0], p[1]});\n        }\n        while(!pq.empty() && k--) {\n            auto &top = pq.top();\n            ans.push_back({top.first, top.second});\n            pq.pop();\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "k-closest-points-to-origin",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1070079278,
            "question_id": 14,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 2 weeks",
            "timestamp": 1696763193,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "23 ms",
            "url": "/submissions/detail/1070079278/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "17.2 MB",
            "code": "class TrieNode\n{\npublic:\n    char data;\n    TrieNode *children[26];\n    bool isTerminal;\n    int childCount;\n\n    TrieNode(char d)\n    {\n        this->data = d;\n        for (int i = 0; i < 26; i++)\n        {\n            this->children[i] = NULL;\n        }\n        this->childCount = 0;\n        this->isTerminal = false;\n    }\n};\n\nclass Solution {\npublic:\n    \n    void insertWord(TrieNode *root, string word)\n    {\n        if (word.length() == 0)\n        {\n            root->isTerminal = true;\n            return;\n        }\n\n        char ch = word[0];\n        int index = ch - 'a';\n        TrieNode *child;\n\n        // Present\n        if (root->children[index] != NULL)\n        {\n            child = root->children[index];\n        }\n        else\n        {\n            // Not Present\n            child = new TrieNode(ch);\n            root->childCount++;\n            root->children[index] = child;\n        }\n\n        // Recursion will handle\n        insertWord(child, word.substr(1));\n    }\n    \n    void findLCP(string first, string &ans, TrieNode *root)\n    {\n        // MISTAKE CAN HAPPEN HERE\n        if (root->isTerminal)\n        {\n            return;\n        }\n\n        for (int i = 0; i < first.length(); i++)\n        {\n            char ch = first[i];\n            if (root->childCount == 1)\n            {\n                ans.push_back(ch);\n                int index = ch - 'a';\n                root = root->children[index];\n            }\n            else\n                break;\n\n            if (root->isTerminal)\n                break;\n        }\n        // cout<<\"hello: \"<< ans;\n    }\n    \n    string longestCommonPrefix(vector<string>& strs) {\n        TrieNode *root = new TrieNode('-');\n\n        // Insert strings\n        for (int i = 0; i < strs.size(); i++)\n        {\n            insertWord(root, strs[i]);\n        }\n\n        string ans = \"\";\n        string first = strs[0];\n        findLCP(first, ans, root);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1070079170,
            "question_id": 14,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 2 weeks",
            "timestamp": 1696763179,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "31 ms",
            "url": "/submissions/detail/1070079170/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "17.4 MB",
            "code": "class TrieNode\n{\npublic:\n    char data;\n    TrieNode *children[26];\n    bool isTerminal;\n    int childCount;\n\n    TrieNode(char d)\n    {\n        this->data = d;\n        for (int i = 0; i < 26; i++)\n        {\n            this->children[i] = NULL;\n        }\n        this->childCount = 0;\n        this->isTerminal = false;\n    }\n};\n\nclass Solution {\npublic:\n    \n    void insertWord(TrieNode *root, string word)\n    {\n        if (word.length() == 0)\n        {\n            root->isTerminal = true;\n            return;\n        }\n\n        char ch = word[0];\n        int index = ch - 'a';\n        TrieNode *child;\n\n        // Present\n        if (root->children[index] != NULL)\n        {\n            child = root->children[index];\n        }\n        else\n        {\n            // Not Present\n            child = new TrieNode(ch);\n            root->childCount++;\n            root->children[index] = child;\n        }\n\n        // Recursion will handle\n        insertWord(child, word.substr(1));\n    }\n    \n    void findLCP(string first, string &ans, TrieNode *root)\n    {\n        // MISTAKE CAN HAPPEN HERE\n        if (root->isTerminal)\n        {\n            return;\n        }\n\n        for (int i = 0; i < first.length(); i++)\n        {\n            char ch = first[i];\n            if (root->childCount == 1)\n            {\n                ans.push_back(ch);\n                int index = ch - 'a';\n                root = root->children[index];\n            }\n            else\n                break;\n\n            if (root->isTerminal)\n                break;\n        }\n        // cout<<\"hello: \"<< ans;\n    }\n    \n    string longestCommonPrefix(vector<string>& strs) {\n        TrieNode *root = new TrieNode('-');\n\n        // Insert strings\n        for (int i = 0; i < strs.size(); i++)\n        {\n            insertWord(root, strs[i]);\n        }\n\n        string ans = \"\";\n        string first = strs[0];\n        findLCP(first, ans, root);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1067032066,
            "question_id": 1304,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 3 weeks",
            "timestamp": 1696441520,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1067032066/",
            "is_pending": "Not Pending",
            "title": "Longest Happy String",
            "memory": "6.5 MB",
            "code": "class Node {\n    public:\n    char data;\n    int count;\n    \n    Node(char d, int c) {\n        data = d; count = c;\n    }\n};\n\nclass compare {\n    public:\n    bool operator()(Node a, Node b) {\n        return a.count < b.count;\n    }\n};\n\nclass Solution {\npublic:\n    string longestDiverseString(int a, int b, int c) {\n        priority_queue<Node, vector<Node>, compare> maxHeap;\n        if(a) {\n            Node temp('a', a);\n            maxHeap.push(temp);\n        }\n        if(b) {\n            Node temp('b', b);\n            maxHeap.push(temp);\n        }\n        if(c) {\n            Node temp('c', c);\n            maxHeap.push(temp);\n        }\n        string ans = \"\";\n        while(maxHeap.size() > 1) {\n            Node first = maxHeap.top(); maxHeap.pop();\n            Node second = maxHeap.top(); maxHeap.pop();\n            \n            if(first.count >= 2) {\n                ans += first.data; ans += first.data;\n                first.count -= 2;\n            } else {\n                ans += first.data;\n                --first.count;\n            }\n            if(second.count >= 2 && second.count > first.count) {\n                ans += second.data; ans += second.data;\n                second.count -= 2;\n            } else {\n                ans += second.data;\n                --second.count;\n            }\n            \n            if(first.count > 0) {\n                maxHeap.push(first);\n            }\n            if(second.count > 0) {\n                maxHeap.push(second);\n            }\n        }\n        \n        if(maxHeap.size() == 1) {\n            Node temp = maxHeap.top(); maxHeap.pop();\n            if(temp.count >= 2) {\n                ans += temp.data; ans += temp.data;\n                temp.count -= 2;\n            } else {\n                ans += temp.data;\n                --temp.count;\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111",
            "title_slug": "longest-happy-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1067031835,
            "question_id": 1304,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 3 weeks",
            "timestamp": 1696441507,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/1067031835/",
            "is_pending": "Not Pending",
            "title": "Longest Happy String",
            "memory": "6.5 MB",
            "code": "class Node {\n    public:\n    char data;\n    int count;\n    \n    Node(char d, int c) {\n        data = d; count = c;\n    }\n};\n\nclass compare {\n    public:\n    bool operator()(Node a, Node b) {\n        return a.count < b.count;\n    }\n};\n\nclass Solution {\npublic:\n    string longestDiverseString(int a, int b, int c) {\n        priority_queue<Node, vector<Node>, compare> maxHeap;\n        if(a) {\n            Node temp('a', a);\n            maxHeap.push(temp);\n        }\n        if(b) {\n            Node temp('b', b);\n            maxHeap.push(temp);\n        }\n        if(c) {\n            Node temp('c', c);\n            maxHeap.push(temp);\n        }\n        string ans = \"\";\n        while(maxHeap.size() > 1) {\n            Node first = maxHeap.top(); maxHeap.pop();\n            Node second = maxHeap.top(); maxHeap.pop();\n            \n            if(first.count >= 2) {\n                ans += first.data; ans += first.data;\n                first.count -= 2;\n            } else {\n                ans += first.data;\n                --first.count;\n            }\n            if(second.count >= 2 && second.count > first.count) {\n                ans += second.data; ans += second.data;\n                second.count -= 2;\n            } else {\n                ans += second.data;\n                --second.count;\n            }\n            \n            if(first.count > 0) {\n                maxHeap.push(first);\n            }\n            if(second.count > 0) {\n                maxHeap.push(second);\n            }\n        }\n        \n        if(maxHeap.size() == 1) {\n            Node temp = maxHeap.top(); maxHeap.pop();\n            if(temp.count >= 2) {\n                ans += temp.data; ans += temp.data;\n                temp.count -= 2;\n            } else {\n                ans += temp.data;\n                --temp.count;\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111",
            "title_slug": "longest-happy-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1066990292,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 3 weeks",
            "timestamp": 1696438968,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1066990292/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "6.5 MB",
            "code": "class Node {\n    public:\n    char data;\n    int count;\n    \n    Node(char d, int c) {\n        data = d;\n        count = c;\n    }\n};\n\nclass compare {\n    public:\n    bool operator()(Node a, Node b) {\n        return a.count < b.count;\n    }\n};\n\nclass Solution {\npublic:\n    string reorganizeString(string s) {\n        \n        // Create mapping\n        int freq[26] = {0};\n        \n        for(int i=0; i<s.length(); i++) {\n            char ch = s[i];\n            freq[ch-'a']++;\n        }\n        \n        priority_queue<Node, vector<Node>, compare> maxHeap;\n        \n        for(int i=0; i<26; i++) {\n            if(freq[i] != 0) {\n                Node temp(i+'a', freq[i]);\n                maxHeap.push(temp);\n            }\n        }\n        \n        string ans = \"\";\n        \n        while(maxHeap.size() > 1) {\n            Node first = maxHeap.top(); maxHeap.pop();\n            Node second = maxHeap.top(); maxHeap.pop();\n            ans += first.data;\n            ans += second.data;\n            \n            first.count--; second.count--;\n            \n            if(first.count != 0) {\n                maxHeap.push(first);\n            }\n            if(second.count != 0) {\n                maxHeap.push(second);\n            }\n        }\n        \n        while(maxHeap.size() == 1) {\n            Node temp = maxHeap.top(); maxHeap.pop();\n            if(temp.count == 1) {\n                ans += temp.data;\n            } else {\n                ans = \"\";\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1066986605,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 3 weeks",
            "timestamp": 1696438735,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1066986605/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "N/A",
            "code": "class Node {\n    public:\n    char data;\n    int count;\n    \n    Node(char d, int c) {\n        data = d;\n        count = c;\n    }\n};\n\nclass compare {\n    public:\n    bool operator()(Node a, Node b) {\n        return a.count < b.count;\n    }\n};\n\nclass Solution {\npublic:\n    string reorganizeString(string s) {\n        \n        // Create mapping\n        int freq[26] = {0};\n        \n        for(int i=0; i<s.length(); i++) {\n            char ch = s[i];\n            freq[ch-'a']++;\n        }\n        \n        priority_queue<Node, vector<Node>, compare> maxHeap;\n        \n        for(int i=0; i<26; i++) {\n            if(freq[i] != 0) {\n                Node temp(i+'a', freq[i]);\n                maxHeap.push(temp);\n            }\n        }\n        \n        string ans = \"\";\n        \n        while(maxHeap.size() > 1) {\n            Node first = maxHeap.top(); maxHeap.pop();\n            Node second = maxHeap.top(); maxHeap.pop();\n            ans += first.data;\n            ans += second.data;\n            \n            first.count--; second.count--;\n            \n            if(first.count != 0) {\n                maxHeap.push(first);\n            }\n            if(second.count != 0) {\n                maxHeap.push(second);\n            }\n        }\n        \n        while(maxHeap.size() == 1) {\n            Node temp = maxHeap.top(); maxHeap.pop();\n            while(temp.count--) {\n                ans += temp.data;\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1011111110111111110111110111111111110110110110110110110110110111110111",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1066967290,
            "question_id": 2094,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 3 weeks",
            "timestamp": 1696437469,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "487 ms",
            "url": "/submissions/detail/1066967290/",
            "is_pending": "Not Pending",
            "title": "Remove Stones to Minimize the Total",
            "memory": "105.3 MB",
            "code": "class Solution {\npublic:\n    int minStoneSum(vector<int>& piles, int k) {\n        priority_queue<int> maxHeap;\n        for(int i=0; i<piles.size(); i++) {\n            maxHeap.push(piles[i]);\n        }\n        \n        while(k--) {\n            int maxEle = maxHeap.top(); maxHeap.pop();\n            maxEle = maxEle - floor(maxEle/2);\n            maxHeap.push(maxEle);\n        }\n        \n        int sum = 0;\n        while(!maxHeap.empty()) {\n            int temp = maxHeap.top(); maxHeap.pop();\n            sum += temp;\n        }\n        return sum;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-stones-to-minimize-the-total",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1066967092,
            "question_id": 2094,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "6 months, 3 weeks",
            "timestamp": 1696437456,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "525 ms",
            "url": "/submissions/detail/1066967092/",
            "is_pending": "Not Pending",
            "title": "Remove Stones to Minimize the Total",
            "memory": "105.2 MB",
            "code": "class Solution {\npublic:\n    int minStoneSum(vector<int>& piles, int k) {\n        priority_queue<int> maxHeap;\n        for(int i=0; i<piles.size(); i++) {\n            maxHeap.push(piles[i]);\n        }\n        \n        while(k--) {\n            int maxEle = maxHeap.top(); maxHeap.pop();\n            maxEle = maxEle - floor(maxEle/2);\n            maxHeap.push(maxEle);\n        }\n        \n        int sum = 0;\n        while(!maxHeap.empty()) {\n            int temp = maxHeap.top(); maxHeap.pop();\n            sum += temp;\n        }\n        return sum;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-stones-to-minimize-the-total",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1060204319,
            "question_id": 632,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months",
            "timestamp": 1695786890,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "52 ms",
            "url": "/submissions/detail/1060204319/",
            "is_pending": "Not Pending",
            "title": "Smallest Range Covering Elements from K Lists",
            "memory": "18.9 MB",
            "code": "class Node {\n    public:\n    int data, row, col;\n    \n    Node(int d, int r, int c) {\n        data = d;\n        row = r;\n        col = c;\n    }\n};\n\nclass Compare {\n    public:\n    bool operator() (Node* a, Node* b) {\n        return a->data > b->data;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> smallestRange(vector<vector<int>>& nums) {\n        int mini = INT_MAX, maxi = INT_MIN;\n        \n        priority_queue<Node*, vector<Node*>, Compare> minHeap;\n        int k = nums.size();\n        for(int i=0; i<k; i++) {\n            int ele = nums[i][0];\n            maxi = max(maxi, ele);\n            mini = min(mini, ele);\n            minHeap.push(new Node(ele, i, 0));\n        }\n        \n        int ansStart = mini;\n        int ansEnd = maxi;\n        \n        while(!minHeap.empty()) {\n            Node* top = minHeap.top();\n            int topEle = top->data;\n            int topRow = top->row;\n            int topCol = top->col;\n            minHeap.pop();\n            \n            // Mini updated\n            mini = topEle;\n            \n            // Check for answer\n            int currRange = maxi-mini;\n            int ansRange = ansEnd - ansStart;\n            if(currRange < ansRange) {\n                ansStart = mini;\n                ansEnd = maxi;\n            }\n            \n            // Check for new element in the same list\n            if(topCol + 1 < nums[topRow].size()) {\n                maxi = max(maxi, nums[topRow][topCol+1]);\n                Node* newNode = new Node(nums[topRow][topCol+1], topRow, topCol+1);\n                minHeap.push(newNode);\n            } else {\n                break;\n            }\n        }\n        \n        vector<int> ans;\n        ans.push_back(ansStart);\n        ans.push_back(ansEnd);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "smallest-range-covering-elements-from-k-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1059849213,
            "question_id": 23,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months",
            "timestamp": 1695748756,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "16 ms",
            "url": "/submissions/detail/1059849213/",
            "is_pending": "Not Pending",
            "title": "Merge k Sorted Lists",
            "memory": "13.7 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Compare {\n    public:\n    bool operator()(ListNode* a, ListNode* b) {\n        return a->val > b->val;\n    }\n};\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        priority_queue<ListNode*, vector<ListNode*>, Compare> minHeap;\n        int k = lists.size();\n        if(k == 0) return NULL;\n        for(int i=0; i<k; i++) {\n            if(lists[i] != NULL) {\n                minHeap.push(lists[i]);\n            }\n        }\n        \n        ListNode* head = NULL;\n        ListNode* tail = NULL;\n        \n        while(!minHeap.empty()) {\n            ListNode* temp = minHeap.top();\n            minHeap.pop();\n            \n            if(head == NULL) {\n                head = temp;\n                tail = temp;\n                if(tail->next != NULL) {\n                    minHeap.push(tail->next);\n                }\n            } else {\n                tail->next = temp;\n                tail = temp;\n                if(tail->next != NULL) {\n                    minHeap.push(tail->next);\n                }\n            }\n        }\n        return head;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "merge-k-sorted-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1044844116,
            "question_id": 975,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 2 weeks",
            "timestamp": 1694275436,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "99 ms",
            "url": "/submissions/detail/1044844116/",
            "is_pending": "Not Pending",
            "title": "Range Sum of BST",
            "memory": "64.7 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        if(!root) return 0;\n        int ans = 0;\n        bool wasInRange = false;\n        if(root->val >= low && root->val <= high) {\n            wasInRange = true;\n            ans += root->val;\n        }\n        if(wasInRange) {\n            ans += rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);\n        } else if(root->val < low) {\n            ans += rangeSumBST(root->right, low, high);\n        } else if(root->val > high) {\n            ans += rangeSumBST(root->left, low, high);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111",
            "title_slug": "range-sum-of-bst",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1043526453,
            "question_id": 1285,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 2 weeks",
            "timestamp": 1694140459,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "116 ms",
            "url": "/submissions/detail/1043526453/",
            "is_pending": "Not Pending",
            "title": "Balance a Binary Search Tree",
            "memory": "63.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void findInorder(TreeNode* root, vector<int> &in) {\n        if(!root) return;\n        findInorder(root->left, in);\n        in.push_back(root->val);\n        findInorder(root->right, in);\n    }\n    TreeNode* findBalancedBST(vector<int> &in, int s, int e) {\n        // Base case\n        if(s>e) return NULL;\n        // Find mid\n        int mid = (s+e) >> 1;\n        TreeNode* root = new TreeNode(in[mid]);\n        root->left = findBalancedBST(in, s, mid-1);\n        root->right = findBalancedBST(in, mid+1, e);\n        return root;\n    }\n    TreeNode* balanceBST(TreeNode* root) {\n        // Find Inorder\n        vector<int> in;\n        findInorder(root, in);\n        \n        // Find Balanced BST\n        return findBalancedBST(in, 0, in.size()-1);\n    }\n};",
            "compare_result": "11111111111111111",
            "title_slug": "balance-a-binary-search-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1042689161,
            "question_id": 1050,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 2 weeks",
            "timestamp": 1694059811,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1042689161/",
            "is_pending": "Not Pending",
            "title": "Construct Binary Search Tree from Preorder Traversal",
            "memory": "13.8 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* build(int &i, int min, int max, vector<int> &preorder) {\n        if(i >= preorder.size()) {\n            return NULL;\n        }\n        TreeNode* root = NULL;\n        if(preorder[i] > min && preorder[i] < max) {\n            root = new TreeNode(preorder[i++]);\n            root->left = build(i, min, root->val, preorder);\n            root->right = build(i, root->val, max, preorder);\n        }\n        return root;\n    }\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\n        int min = INT_MIN, max = INT_MAX, i = 0;\n        return build(i, min, max, preorder);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "construct-binary-search-tree-from-preorder-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1038771441,
            "question_id": 653,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 3 weeks",
            "timestamp": 1693679091,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "28 ms",
            "url": "/submissions/detail/1038771441/",
            "is_pending": "Not Pending",
            "title": "Two Sum IV - Input is a BST",
            "memory": "36.8 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void storeInOrder(TreeNode* root, vector<int> &inorder) {\n        if(!root) return;\n        storeInOrder(root->left, inorder);\n        inorder.push_back(root->val);\n        storeInOrder(root->right, inorder);\n    }\n    bool findTarget(TreeNode* root, int k) {\n        vector<int> inorder;\n        storeInOrder(root, inorder);\n        int s = 0, e = inorder.size()-1;\n        while(s<e) {\n            int sum = inorder[s] + inorder[e];\n            if(sum == k) return true;\n            if(sum > k) {\n                e--;\n            } else {\n                s++;\n            }\n        }\n        return false;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "two-sum-iv-input-is-a-bst",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1037885705,
            "question_id": 230,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 3 weeks",
            "timestamp": 1693592315,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/1037885705/",
            "is_pending": "Not Pending",
            "title": "Kth Smallest Element in a BST",
            "memory": "24.1 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int &k) {\n        if(root == NULL) return -1;\n        int lAns = kthSmallest(root->left, k);\n        if(lAns != -1) return lAns;\n        k--;\n        if(k==0) return root->val;\n        int rAns = kthSmallest(root->right, k);\n        return rAns;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "kth-smallest-element-in-a-bst",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1037883688,
            "question_id": 230,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 3 weeks",
            "timestamp": 1693592173,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1037883688/",
            "is_pending": "Not Pending",
            "title": "Kth Smallest Element in a BST",
            "memory": "N/A",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        if(root == NULL) return -1;\n        int lAns = kthSmallest(root->left, k);\n        if(lAns != -1) return lAns;\n        k--;\n        if(k==0) return root->val;\n        int rAns = kthSmallest(root->right, k);\n        return rAns;\n    }\n};",
            "compare_result": "101111010011100100010000100001000001100000000000000010000001001000000001000000000000000000100",
            "title_slug": "kth-smallest-element-in-a-bst",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1037862118,
            "question_id": 235,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 3 weeks",
            "timestamp": 1693590616,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "22 ms",
            "url": "/submissions/detail/1037862118/",
            "is_pending": "Not Pending",
            "title": "Lowest Common Ancestor of a Binary Search Tree",
            "memory": "23.3 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL) return NULL;\n        \n        if(p->val < root->val && q->val < root->val) {\n            return lowestCommonAncestor(root->left, p, q);\n        }\n        if(p->val > root->val && q->val > root->val) {\n            return lowestCommonAncestor(root->right, p, q);\n        }\n        return root;\n    }\n};",
            "compare_result": "111111111111111111111111111111",
            "title_slug": "lowest-common-ancestor-of-a-binary-search-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1037820788,
            "question_id": 98,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 3 weeks",
            "timestamp": 1693587633,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1037820788/",
            "is_pending": "Not Pending",
            "title": "Validate Binary Search Tree",
            "memory": "21.7 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool solve(TreeNode* root, long long int lb, long long int ub) {\n        if(root == NULL) return true;\n        if(root->val > lb && root->val < ub) {\n            bool leftAns = solve(root->left, lb, root->val);\n            bool rightAns = solve(root->right, root->val, ub);\n            return leftAns && rightAns;\n        } else {\n            return false;\n        }\n    }\n    bool isValidBST(TreeNode* root) {\n        long long int lBound = LLONG_MIN;\n        long long int uBound = LLONG_MAX;\n        bool ans = solve(root, lBound, uBound);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "validate-binary-search-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1037797928,
            "question_id": 450,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 3 weeks",
            "timestamp": 1693585937,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "26 ms",
            "url": "/submissions/detail/1037797928/",
            "is_pending": "Not Pending",
            "title": "Delete Node in a BST",
            "memory": "32.7 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxVal(TreeNode *root)\n    {\n        TreeNode *temp = root;\n        if (temp == NULL)\n        {\n            return -1;\n        }\n\n        while (temp->right != NULL)\n        {\n            temp = temp->right;\n        }\n        return temp->val;\n    }\n    TreeNode *deleteNodeInBST(TreeNode *root, int target)\n    {\n        // Base case\n        if (root == NULL)\n        {\n            return NULL;\n        }\n        if (root->val == target)\n        {\n            // Delete this node\n            // 4 cases\n            if (root->left == NULL && root->right == NULL)\n            {\n                // Leaf node\n                delete root;\n                return NULL;\n            }\n            else if (root->left == NULL && root->right != NULL)\n            {\n                TreeNode *child = root->right;\n                delete root;\n                return child;\n            }\n            else if (root->left != NULL && root->right == NULL)\n            {\n                TreeNode *child = root->left;\n                delete root;\n                return child;\n            }\n            else\n            {\n                // Both child present\n                // Find inorder predecessor in left subtree\n                int inorderPre = maxVal(root->left);\n                // Replace root->data value with inorder predecessor\n                root->val = inorderPre;\n                // Delete inorder predecessor from left subtree\n                root->left = deleteNodeInBST(root->left, inorderPre);\n                return root;\n            }\n        }\n        else if (target > root->val)\n        {\n            // Go right\n            root->right = deleteNodeInBST(root->right, target);\n        }\n        else if (target < root->val)\n        {\n            // Go left\n            root->left = deleteNodeInBST(root->left, target);\n        }\n        return root;\n    }\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        root = deleteNodeInBST(root, key);\n        return root;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "delete-node-in-a-bst",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1035314807,
            "question_id": 652,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 4 weeks",
            "timestamp": 1693333435,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "21 ms",
            "url": "/submissions/detail/1035314807/",
            "is_pending": "Not Pending",
            "title": "Find Duplicate Subtrees",
            "memory": "43.7 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> ans;\n    unordered_map<string, int> subTreeMap;\n    string preorder(TreeNode* root) {\n        if(!root) return \"N\";\n        \n        string curr = to_string(root->val);\n        string l = preorder(root->left);\n        string r = preorder(root->right);\n        string s = curr + \",\" + l + \",\" + r;\n        if(subTreeMap.find(s) != subTreeMap.end()) {\n            if(subTreeMap[s] == 1)\n                ans.push_back(root);\n            subTreeMap[s]++;\n        } else {\n            subTreeMap[s] = 1;\n        }\n        return s;\n    }\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\n        preorder(root);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-duplicate-subtrees",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1035314604,
            "question_id": 652,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 4 weeks",
            "timestamp": 1693333421,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "22 ms",
            "url": "/submissions/detail/1035314604/",
            "is_pending": "Not Pending",
            "title": "Find Duplicate Subtrees",
            "memory": "43.7 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> ans;\n    unordered_map<string, int> subTreeMap;\n    string preorder(TreeNode* root) {\n        if(!root) return \"N\";\n        \n        string curr = to_string(root->val);\n        string l = preorder(root->left);\n        string r = preorder(root->right);\n        string s = curr + \",\" + l + \",\" + r;\n        if(subTreeMap.find(s) != subTreeMap.end()) {\n            if(subTreeMap[s] == 1)\n                ans.push_back(root);\n            subTreeMap[s]++;\n        } else {\n            subTreeMap[s] = 1;\n        }\n        return s;\n    }\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\n        preorder(root);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-duplicate-subtrees",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1034606525,
            "question_id": 114,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "7 months, 4 weeks",
            "timestamp": 1693273360,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/1034606525/",
            "is_pending": "Not Pending",
            "title": "Flatten Binary Tree to Linked List",
            "memory": "12.6 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode* curr = root;\n        while(curr) {\n            if(curr->left) {\n                TreeNode* pred = curr->left;\n                while(pred->right) {\n                    pred = pred->right;\n                }\n                pred->right = curr->right;\n                curr->right = curr->left;\n                curr->left = nullptr;\n            }\n            curr = curr->right;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "flatten-binary-tree-to-linked-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033448734,
            "question_id": 94,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693161309,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1033448734/",
            "is_pending": "Not Pending",
            "title": "Binary Tree Inorder Traversal",
            "memory": "8.4 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n         vector<int> ans;\n        TreeNode* curr = root;\n        while(curr) {\n            if(curr->left == nullptr) {\n                ans.push_back(curr->val);\n                curr = curr->right;\n            } else {\n                TreeNode* pred = curr->left;\n                while(pred->right != curr && pred->right) {\n                    pred = pred->right;\n                }\n                if(pred->right == nullptr) {\n                    pred->right = curr;\n                    curr = curr->left;\n                } else {\n                    pred->right = nullptr;\n                    ans.push_back(curr->val);\n                    curr = curr->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "binary-tree-inorder-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033448596,
            "question_id": 94,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693161300,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1033448596/",
            "is_pending": "Not Pending",
            "title": "Binary Tree Inorder Traversal",
            "memory": "8.4 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n         vector<int> ans;\n        TreeNode* curr = root;\n        while(curr) {\n            if(curr->left == nullptr) {\n                ans.push_back(curr->val);\n                curr = curr->right;\n            } else {\n                TreeNode* pred = curr->left;\n                while(pred->right != curr && pred->right) {\n                    pred = pred->right;\n                }\n                if(pred->right == nullptr) {\n                    pred->right = curr;\n                    curr = curr->left;\n                } else {\n                    pred->right = nullptr;\n                    ans.push_back(curr->val);\n                    curr = curr->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "binary-tree-inorder-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033448173,
            "question_id": 94,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693161267,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1033448173/",
            "is_pending": "Not Pending",
            "title": "Binary Tree Inorder Traversal",
            "memory": "8.4 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n         vector<int> ans;\n        TreeNode* curr = root;\n        while(curr) {\n            if(curr->left == nullptr) {\n                ans.push_back(curr->val);\n                curr = curr->right;\n            } else {\n                TreeNode* pred = curr->left;\n                while(pred->right != curr && pred->right) {\n                    pred = pred->right;\n                }\n                if(pred->right == nullptr) {\n                    pred->right = curr;\n                    curr = curr->left;\n                } else {\n                    pred->right = nullptr;\n                    ans.push_back(curr->val);\n                    curr = curr->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "binary-tree-inorder-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033447913,
            "question_id": 94,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693161248,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1033447913/",
            "is_pending": "Not Pending",
            "title": "Binary Tree Inorder Traversal",
            "memory": "8.4 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n         vector<int> ans;\n        TreeNode* curr = root;\n        while(curr) {\n            if(curr->left == nullptr) {\n                ans.push_back(curr->val);\n                curr = curr->right;\n            } else {\n                TreeNode* pred = curr->left;\n                while(pred->right != curr && pred->right) {\n                    pred = pred->right;\n                }\n                if(pred->right == nullptr) {\n                    pred->right = curr;\n                    curr = curr->left;\n                } else {\n                    pred->right = nullptr;\n                    ans.push_back(curr->val);\n                    curr = curr->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "binary-tree-inorder-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033447725,
            "question_id": 94,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693161233,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1033447725/",
            "is_pending": "Not Pending",
            "title": "Binary Tree Inorder Traversal",
            "memory": "8.3 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n         vector<int> ans;\n        TreeNode* curr = root;\n        while(curr) {\n            if(curr->left == nullptr) {\n                ans.push_back(curr->val);\n                curr = curr->right;\n            } else {\n                TreeNode* pred = curr->left;\n                while(pred->right != curr && pred->right) {\n                    pred = pred->right;\n                }\n                if(pred->right == nullptr) {\n                    pred->right = curr;\n                    curr = curr->left;\n                } else {\n                    pred->right = nullptr;\n                    ans.push_back(curr->val);\n                    curr = curr->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "binary-tree-inorder-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033447106,
            "question_id": 94,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693161187,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1033447106/",
            "is_pending": "Not Pending",
            "title": "Binary Tree Inorder Traversal",
            "memory": "8.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n         vector<int> ans;\n        TreeNode* curr = root;\n        while(curr) {\n            if(curr->left == nullptr) {\n                ans.push_back(curr->val);\n                curr = curr->right;\n            } else {\n                TreeNode* pred = curr->left;\n                while(pred->right != curr && pred->right) {\n                    pred = pred->right;\n                }\n                if(pred->right == nullptr) {\n                    pred->right = curr;\n                    curr = curr->left;\n                } else {\n                    pred->right = nullptr;\n                    ans.push_back(curr->val);\n                    curr = curr->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "binary-tree-inorder-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033374111,
            "question_id": 437,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693156098,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "22 ms",
            "url": "/submissions/detail/1033374111/",
            "is_pending": "Not Pending",
            "title": "Path Sum III",
            "memory": "16 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = 0;\n    void pathFromOneRoot(TreeNode* root, long sum) {\n        if(!root) return;\n        if(root->val == sum) ++ans;\n        pathFromOneRoot(root->left, sum-root->val);\n        pathFromOneRoot(root->right, sum-root->val);\n    }\n    int pathSum(TreeNode* root, long targetSum) {\n        if(root) {\n            pathFromOneRoot(root, targetSum);\n            pathSum(root->left, targetSum);\n            pathSum(root->right, targetSum);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "path-sum-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033373789,
            "question_id": 437,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693156077,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "24 ms",
            "url": "/submissions/detail/1033373789/",
            "is_pending": "Not Pending",
            "title": "Path Sum III",
            "memory": "15.8 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = 0;\n    void pathFromOneRoot(TreeNode* root, long sum) {\n        if(!root) return;\n        if(root->val == sum) ++ans;\n        pathFromOneRoot(root->left, sum-root->val);\n        pathFromOneRoot(root->right, sum-root->val);\n    }\n    int pathSum(TreeNode* root, long targetSum) {\n        if(root) {\n            pathFromOneRoot(root, targetSum);\n            pathSum(root->left, targetSum);\n            pathSum(root->right, targetSum);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "path-sum-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033373422,
            "question_id": 437,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693156052,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/1033373422/",
            "is_pending": "Not Pending",
            "title": "Path Sum III",
            "memory": "N/A",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int ans = 0;\n    void pathFromOneRoot(TreeNode* root, int sum) {\n        if(!root) return;\n        if(root->val == sum) ++ans;\n        pathFromOneRoot(root->left, sum-root->val);\n        pathFromOneRoot(root->right, sum-root->val);\n    }\n    int pathSum(TreeNode* root, int targetSum) {\n        if(root) {\n            pathFromOneRoot(root, targetSum);\n            pathSum(root->left, targetSum);\n            pathSum(root->right, targetSum);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
            "title_slug": "path-sum-iii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033345537,
            "question_id": 1029,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693154006,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1033345537/",
            "is_pending": "Not Pending",
            "title": "Vertical Order Traversal of a Binary Tree",
            "memory": "13.6 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> ans;\n        queue<pair<TreeNode*, pair<int,int>>> q; // Node, {row,col}\n        q.push({root, {0,0}});\n        map<int, map<int, multiset<int>>> mp; // col -> {row: [x,y,z...]}\n        while(!q.empty()) {\n            auto front = q.front(); q.pop();\n            TreeNode* &node = front.first;\n            auto &coordinate = front.second;\n            int row = coordinate.first;\n            int col = coordinate.second;\n            mp[col][row].insert(node->val);\n            if(node->left) {\n                q.push({node->left, {row+1, col-1}});\n            }\n            if(node->right) {\n                q.push({node->right, {row+1, col+1}});\n            }\n        }\n        \n        // Store final vertical order into ans vector\n        for(auto it: mp) {\n            auto &colMap = it.second;\n            vector<int> vLine;\n            for(auto colMapIt: colMap) {\n                auto &mSet = colMapIt.second;\n                vLine.insert(vLine.end(), mSet.begin(), mSet.end());\n            }\n            ans.push_back(vLine);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111",
            "title_slug": "vertical-order-traversal-of-a-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1033344347,
            "question_id": 1029,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1693153912,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/1033344347/",
            "is_pending": "Not Pending",
            "title": "Vertical Order Traversal of a Binary Tree",
            "memory": "13.7 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> ans;\n        queue<pair<TreeNode*, pair<int,int>>> q; // Node, {row,col}\n        q.push({root, {0,0}});\n        map<int, map<int, multiset<int>>> mp; // col -> {row: [x,y,z...]}\n        while(!q.empty()) {\n            auto front = q.front(); q.pop();\n            TreeNode* &node = front.first;\n            auto coordinate = front.second;\n            int row = coordinate.first;\n            int col = coordinate.second;\n            mp[col][row].insert(node->val);\n            if(node->left) {\n                q.push({node->left, {row+1, col-1}});\n            }\n            if(node->right) {\n                q.push({node->right, {row+1, col+1}});\n            }\n        }\n        \n        // Store final vertical order into ans vector\n        for(auto it: mp) {\n            auto &colMap = it.second;\n            vector<int> vLine;\n            for(auto colMapIt: colMap) {\n                auto &mSet = colMapIt.second;\n                vLine.insert(vLine.end(), mSet.begin(), mSet.end());\n            }\n            ans.push_back(vLine);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111",
            "title_slug": "vertical-order-traversal-of-a-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1030408463,
            "question_id": 103,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1692874289,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1030408463/",
            "is_pending": "Not Pending",
            "title": "Binary Tree Zigzag Level Order Traversal",
            "memory": "12 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if(!root) return ans;\n        queue<TreeNode*> q;\n        bool leftToRightDir = true;\n        q.push(root);\n        while(!q.empty()) {\n            int width = q.size();\n            vector<int> oneLevel(width);\n            for(int i=0; i<width; i++) {\n                TreeNode* front = q.front(); q.pop();\n                int index = leftToRightDir ? i : width-i-1;\n                oneLevel[index] = front->val;\n                if(front->left) {\n                    q.push(front->left);\n                }\n                if(front->right) {\n                    q.push(front->right);\n                }\n            }\n            leftToRightDir = !leftToRightDir;\n            ans.push_back(oneLevel);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111",
            "title_slug": "binary-tree-zigzag-level-order-traversal",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1029499776,
            "question_id": 101,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1692791583,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "9 ms",
            "url": "/submissions/detail/1029499776/",
            "is_pending": "Not Pending",
            "title": "Symmetric Tree",
            "memory": "16.4 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isMirror(TreeNode *p, TreeNode *q) {\n        if(!p && !q) return true;\n        if(p && q) {\n            return (p->val == q->val)\n                && isMirror(p->left, q->right)\n                && isMirror(p->right, q->left);\n        }\n        return false;\n    }\n    bool isSymmetric(TreeNode* root) {\n        return isMirror(root->left, root->right);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "symmetric-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1029493419,
            "question_id": 100,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1692790973,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1029493419/",
            "is_pending": "Not Pending",
            "title": "Same Tree",
            "memory": "10.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q) return true;\n        if(p && q) {\n            return (p->val == q->val) &&\n                isSameTree(p->left, q->left) &&\n                isSameTree(p->right, q->right);\n        }\n        return false;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "same-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1028850700,
            "question_id": 110,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months",
            "timestamp": 1692726578,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/1028850700/",
            "is_pending": "Not Pending",
            "title": "Balanced Binary Tree",
            "memory": "20.9 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalancedTree = true;\n    int height(TreeNode* root) {\n        if(!root) return 0;\n        int leftH = height(root->left);\n        int rightH = height(root->right);\n        if(isBalancedTree && abs(leftH-rightH) > 1) {\n            isBalancedTree = false;\n        }\n        return max(leftH, rightH) + 1;\n    }\n    bool isBalanced(TreeNode* root) {\n        height(root);\n        return isBalancedTree;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "balanced-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1017135965,
            "question_id": 543,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 2 weeks",
            "timestamp": 1691637148,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1017135965/",
            "is_pending": "Not Pending",
            "title": "Diameter of Binary Tree",
            "memory": "20.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    // int maxDepth(TreeNode* root) {\n    //     if(root == NULL) return 0;\n    //     int left = maxDepth(root->left);\n    //     int right = maxDepth(root->right);\n    //     return max(left,right)+1;\n    // }\n    // int diameterOfBinaryTree(TreeNode* root) {\n    //     if(root == NULL) return 0;\n    //     int op1 = diameterOfBinaryTree(root->left);\n    //     int op2 = diameterOfBinaryTree(root->right);\n    //     int op3 = maxDepth(root->left) + maxDepth(root->right);\n    //     return max(op1,max(op2,op3));\n    // }\n    int D = 0;\n    int height(TreeNode* root) {\n        if(!root) return 0;\n        int lh = height(root->left);\n        int rh = height(root->right);\n        int currD = lh+rh;\n        D = max(D, currD);\n        return max(lh,rh)+1;\n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        height(root);\n        return D;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "diameter-of-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1015205392,
            "question_id": 225,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 3 weeks",
            "timestamp": 1691459476,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1015205392/",
            "is_pending": "Not Pending",
            "title": "Implement Stack using Queues",
            "memory": "6.7 MB",
            "code": "class MyStack {\npublic:\n    queue<int> q;\n    MyStack() {\n        \n    }\n    \n    void push(int x) {\n        q.push(x);\n        for(int i=0; i<q.size()-1; i++) {\n            int front = q.front();\n            q.pop();\n            q.push(front);\n        }\n    }\n    \n    int pop() {\n        int popEle = -1;\n        if(q.size()) {\n            popEle = q.front();\n            q.pop();\n        }\n        return popEle;\n    }\n    \n    int top() {\n        int popEle = -1;\n        if(q.size()) {\n            popEle = q.front();\n        }\n        return popEle;\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */",
            "compare_result": "11111111111111111",
            "title_slug": "implement-stack-using-queues",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1014309486,
            "question_id": 232,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 3 weeks",
            "timestamp": 1691377524,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1014309486/",
            "is_pending": "Not Pending",
            "title": "Implement Queue using Stacks",
            "memory": "6.9 MB",
            "code": "class MyQueue {\npublic:\n    stack<int> s1, s2;\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        int pop = -1;\n        if(!s2.empty()) {\n            pop = s2.top();\n        } else {\n            while(!s1.empty()) {\n                s2.push(s1.top()); \n                s1.pop();\n            }\n            pop = s2.top();\n        }\n        s2.pop();\n        return pop;\n    }\n    \n    int peek() {\n        int front = -1;\n        if(!s2.empty()) {\n            front = s2.top();\n        } else {\n            while(!s1.empty()) {\n                s2.push(s1.top()); \n                s1.pop();\n            }\n            front = s2.top();\n        }\n        return front;\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */",
            "compare_result": "1111111111111111111111",
            "title_slug": "implement-queue-using-stacks",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1014309415,
            "question_id": 232,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 3 weeks",
            "timestamp": 1691377516,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/1014309415/",
            "is_pending": "Not Pending",
            "title": "Implement Queue using Stacks",
            "memory": "6.9 MB",
            "code": "class MyQueue {\npublic:\n    stack<int> s1, s2;\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        int pop = -1;\n        if(!s2.empty()) {\n            pop = s2.top();\n        } else {\n            while(!s1.empty()) {\n                s2.push(s1.top()); \n                s1.pop();\n            }\n            pop = s2.top();\n        }\n        s2.pop();\n        return pop;\n    }\n    \n    int peek() {\n        int front = -1;\n        if(!s2.empty()) {\n            front = s2.top();\n        } else {\n            while(!s1.empty()) {\n                s2.push(s1.top()); \n                s1.pop();\n            }\n            front = s2.top();\n        }\n        return front;\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */",
            "compare_result": "1111111111111111111111",
            "title_slug": "implement-queue-using-stacks",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1014309299,
            "question_id": 232,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 3 weeks",
            "timestamp": 1691377501,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/1014309299/",
            "is_pending": "Not Pending",
            "title": "Implement Queue using Stacks",
            "memory": "6.8 MB",
            "code": "class MyQueue {\npublic:\n    stack<int> s1, s2;\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        int pop = -1;\n        if(!s2.empty()) {\n            pop = s2.top();\n        } else {\n            while(!s1.empty()) {\n                s2.push(s1.top()); \n                s1.pop();\n            }\n            pop = s2.top();\n        }\n        s2.pop();\n        return pop;\n    }\n    \n    int peek() {\n        int front = -1;\n        if(!s2.empty()) {\n            front = s2.top();\n        } else {\n            while(!s1.empty()) {\n                s2.push(s1.top()); \n                s1.pop();\n            }\n            front = s2.top();\n        }\n        return front;\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */",
            "compare_result": "1111111111111111111111",
            "title_slug": "implement-queue-using-stacks",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1013799255,
            "question_id": 1902,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 3 weeks",
            "timestamp": 1691323369,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "402 ms",
            "url": "/submissions/detail/1013799255/",
            "is_pending": "Not Pending",
            "title": "Car Fleet II",
            "memory": "129.7 MB",
            "code": "class Solution {\npublic:\n    vector<double> getCollisionTimes(vector<vector<int>>& cars) {\n        vector<double> answer(cars.size(), -1); // Collision time of ith car with the next car.\n        \n        stack<int> st;\n        \n        for(int i=cars.size()-1; i>=0; --i) {\n            // Check if the car ahead of current car is faster?\n            while(!st.empty() && cars[st.top()][1] >= cars[i][1]) { // [1] means speed\n                st.pop();\n            }\n\n            while(!st.empty()) {\n                double colTime = (double)(cars[st.top()][0] - cars[i][0]) / (cars[i][1] - cars[st.top()][1]);\n                if(answer[st.top()] == -1 || colTime <= answer[st.top()]) {\n                    answer[i] = colTime;\n                    break;\n                }\n                st.pop();\n            }\n            st.push(i);\n        }\n        return answer;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "car-fleet-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1013794519,
            "question_id": 1902,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 3 weeks",
            "timestamp": 1691322912,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1013794519/",
            "is_pending": "Not Pending",
            "title": "Car Fleet II",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    vector<double> getCollisionTimes(vector<vector<int>>& cars) {\n        vector<double> answer(cars.size(), -1); // Collision time of ith car with the next car.\n        \n        stack<int> st;\n        \n        for(int i=cars.size()-1; i>=0; --i) {\n            // Check if the car ahead of current car is faster?\n            while(!st.empty() && cars[st.top()][1] >= cars[i][1]) { // [1] means speed\n                st.pop();\n            }\n\n            while(!st.empty()) {\n                double colTime = (double)(cars[st.top()][0] - cars[i][0] / (cars[i][1] - cars[st.top()][1]));\n                if(answer[st.top()] == -1 || colTime <= answer[st.top()]) {\n                    answer[i] = colTime;\n                    break;\n                }\n                st.pop();\n            }\n            st.push(i);\n        }\n        return answer;\n    }\n};",
            "compare_result": "1010000000100101000001010010000010000000100100100001000100000000000000000000000100011",
            "title_slug": "car-fleet-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1013762658,
            "question_id": 883,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "8 months, 3 weeks",
            "timestamp": 1691319783,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "168 ms",
            "url": "/submissions/detail/1013762658/",
            "is_pending": "Not Pending",
            "title": "Car Fleet",
            "memory": "78.6 MB",
            "code": "class Solution {\n    class Car {\n        public:\n        int pos, speed;\n        Car(int p, int s):pos(p), speed(s) {};\n    };\n    static bool myComp(Car &a, Car &b) {\n        return a.pos < b.pos;\n    }\n    public:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        vector<Car> cars;\n        for(int i = 0; i<position.size(); ++i) {\n            Car car(position[i], speed[i]);\n            cars.push_back(car);\n        }\n        sort(cars.begin(), cars.end(), myComp);\n        stack<float> st;\n        for(auto car: cars) {\n            float time = (target-car.pos) / ((float) car.speed);\n            while(!st.empty() && time >= st.top()) {\n                st.pop();\n            }\n            st.push(time);\n        }\n        return st.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111",
            "title_slug": "car-fleet",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1001889035,
            "question_id": 85,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months",
            "timestamp": 1690124008,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "78 ms",
            "url": "/submissions/detail/1001889035/",
            "is_pending": "Not Pending",
            "title": "Maximal Rectangle",
            "memory": "18.9 MB",
            "code": "class Solution {\npublic:\n    vector<int> prevSmallerElement(vector<int> &input) {\n        stack<int> s;\n        s.push(-1);\n        vector<int> ans(input.size());\n\n        for(int i=0; i<input.size(); i++) {\n            int curr = input[i];\n            while(s.top() != -1 && input[s.top()] >= curr) {\n                s.pop();\n            }\n            ans[i] = s.top();\n            s.push(i);\n        }\n        return ans;\n    }\n    vector<int> nextSmallerElement(vector<int> &input) {\n        stack<int> s;\n        s.push(-1);\n        vector<int> ans(input.size());\n\n        for(int i=input.size()-1; i>=0; i--) {\n            int curr = input[i];\n            while(s.top() != -1 && input[s.top()] >= curr) {\n                s.pop();\n            }\n            ans[i] = s.top();\n            s.push(i);\n        }\n        return ans;\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        vector<int> prev = prevSmallerElement(heights);\n        vector<int> next = nextSmallerElement(heights);\n        int maxArea = INT_MIN;\n        for(int i=0; i<heights.size(); i++) {\n            int height = heights[i];\n            if(next[i] == -1) {\n                next[i] = heights.size();\n            }\n            int width = next[i] - prev[i] - 1;\n            maxArea = max(height*width, maxArea);\n        }\n        return maxArea;\n    }\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        vector<vector<int>> v;\n        int n = matrix.size();\n        int m = matrix[0].size();\n        for(int i=0; i<n; i++) {\n            vector<int> t;\n            for(int j=0; j<m; j++) {\n                t.push_back(matrix[i][j] - '0');\n            }\n            v.push_back(t);\n        }\n        \n        int area = largestRectangleArea(v[0]);\n        for(int i=1; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                if(v[i][j]) {\n                    v[i][j] += v[i-1][j];\n                } else {\n                    v[i][j] = 0;\n                }\n            }\n            area = max(area, largestRectangleArea(v[i]));\n        }\n        return area;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximal-rectangle",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1001154799,
            "question_id": 394,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1690045874,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/1001154799/",
            "is_pending": "Not Pending",
            "title": "Decode String",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> st;\n        for (int i = 0; i < s.length(); i++) {\n            if(s[i] == ']') {\n                string mergedStr = \"\";\n                while (!st.empty() && !isdigit(st.top()[0])) {\n                    mergedStr += st.top() == \"[\" ? \"\" : st.top();\n                    st.pop();\n                }\n                string numberedStr = \"\";\n                while (!st.empty() && isdigit(st.top()[0])) {\n                    numberedStr += st.top();\n                    st.pop();\n                }\n                reverse(numberedStr.begin(), numberedStr.end());\n                int timesToRepeat = 1;\n                if(numberedStr.length() > 0) {\n                    timesToRepeat = stoi(numberedStr);\n                }\n                string tempStr = \"\";\n                for (int j = 0; j < timesToRepeat; j++) {\n                    tempStr += mergedStr;\n                }\n                st.push(tempStr);\n            } else {\n                string temp(1, s[i]);\n                st.push(temp);\n            }\n        }\n        string finalStr;\n        while (!st.empty()) {\n            string str = st.top();\n            finalStr += str;\n            st.pop();\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111",
            "title_slug": "decode-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1001154685,
            "question_id": 394,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1690045864,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/1001154685/",
            "is_pending": "Not Pending",
            "title": "Decode String",
            "memory": "6.5 MB",
            "code": "class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> st;\n        for (int i = 0; i < s.length(); i++) {\n            if(s[i] == ']') {\n                string mergedStr = \"\";\n                while (!st.empty() && !isdigit(st.top()[0])) {\n                    mergedStr += st.top() == \"[\" ? \"\" : st.top();\n                    st.pop();\n                }\n                string numberedStr = \"\";\n                while (!st.empty() && isdigit(st.top()[0])) {\n                    numberedStr += st.top();\n                    st.pop();\n                }\n                reverse(numberedStr.begin(), numberedStr.end());\n                int timesToRepeat = 1;\n                if(numberedStr.length() > 0) {\n                    timesToRepeat = stoi(numberedStr);\n                }\n                string tempStr = \"\";\n                for (int j = 0; j < timesToRepeat; j++) {\n                    tempStr += mergedStr;\n                }\n                st.push(tempStr);\n            } else {\n                string temp(1, s[i]);\n                st.push(temp);\n            }\n        }\n        string finalStr;\n        while (!st.empty()) {\n            string str = st.top();\n            finalStr += str;\n            st.pop();\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111",
            "title_slug": "decode-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1001110915,
            "question_id": 394,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1690042368,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1001110915/",
            "is_pending": "Not Pending",
            "title": "Decode String",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> st;\n        for (int i = 0; i < s.length(); i++) {\n            while (i < s.length() && s[i] != ']') {\n                if (s[i] != '[') {\n                    string temp = \"\";\n                    temp += s[i];\n                    st.push(temp);\n                }\n                ++i;\n            }\n            string mergedStr = \"\";\n            while (!st.empty() && !isdigit(st.top()[0])) {\n                mergedStr += st.top();\n                st.pop();\n            }\n            string repeatedStr = \"\";\n            while (!st.empty() && isdigit(st.top()[0])) {\n                repeatedStr += st.top();\n                st.pop();\n            }\n            reverse(repeatedStr.begin(), repeatedStr.end());\n            int timesToRepeat = 1;\n            if(repeatedStr.length() > 0) {\n                timesToRepeat = stoi(repeatedStr);\n            }\n            string tempStr = \"\";\n            for (int j = 0; j < timesToRepeat; j++) {\n                tempStr += mergedStr;\n            }\n            st.push(tempStr);\n        }\n        string finalStr;\n        while (!st.empty()) {\n            string str = st.top();\n            finalStr += str;\n            st.pop();\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n};",
            "compare_result": "1111111011100011000110111111111011",
            "title_slug": "decode-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1001107459,
            "question_id": 394,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1690042103,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/1001107459/",
            "is_pending": "Not Pending",
            "title": "Decode String",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> st;\n        for (int i = 0; i < s.length(); i++) {\n            while (i < s.length() && s[i] != ']') {\n                if (s[i] != '[') {\n                    string temp = \"\";\n                    temp += s[i];\n                    st.push(temp);\n                }\n                ++i;\n            }\n            string mergedStr = \"\";\n            while (!st.empty() && !isdigit(st.top()[0])) {\n                mergedStr += st.top();\n                st.pop();\n            }\n            string repeatedStr = \"\";\n            while (!st.empty() && isdigit(st.top()[0])) {\n                repeatedStr += st.top();\n                st.pop();\n            }\n            int timesToRepeat = 1;\n            if(repeatedStr.length() > 0) {\n                timesToRepeat = stoi(repeatedStr);\n            }\n            string tempStr = \"\";\n            for (int j = 0; j < timesToRepeat; j++) {\n                tempStr += mergedStr;\n            }\n            st.push(tempStr);\n        }\n        string finalStr;\n        while (!st.empty()) {\n            string str = st.top();\n            finalStr += str;\n            st.pop();\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n};",
            "compare_result": "1111110011100011000010100001100001",
            "title_slug": "decode-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 1000917680,
            "question_id": 394,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1690032364,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/1000917680/",
            "is_pending": "Not Pending",
            "title": "Decode String",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> st;\n        for (int i = 0; i < s.length(); i++) {\n            while (s[i] != ']') {\n                if (s[i] != '[') {\n                    string temp = \"\";\n                    temp += s[i];\n                    st.push(temp);\n                }\n                ++i;\n            }\n            string mergedStr = \"\";\n            while (!st.empty() && !isdigit(st.top()[0])) {\n                mergedStr += st.top();\n                st.pop();\n            }\n            string repeatedStr = \"\";\n            while (!st.empty() && isdigit(st.top()[0])) {\n                repeatedStr += st.top();\n                st.pop();\n            }\n            reverse(mergedStr.begin(), mergedStr.end());\n            int timesToRepeat = stoi(repeatedStr);\n            string tempStr = \"\";\n            for (int j = 0; j < timesToRepeat; j++) {\n                tempStr += mergedStr;\n            }\n            st.push(tempStr);\n        }\n        string finalStr;\n        while (!st.empty()) {\n            string str = st.top();\n            reverse(str.begin(), str.end());\n            finalStr += str;\n            st.pop();\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n};",
            "compare_result": "1100000000000000000000000000000000",
            "title_slug": "decode-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 996084896,
            "question_id": 1045,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689530813,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/996084896/",
            "is_pending": "Not Pending",
            "title": "Check If Word Is Valid After Substitutions",
            "memory": "8.2 MB",
            "code": "class Solution {\npublic:\n    // Recursive solution\n    // bool isValid(string s) {\n    //     if(s.size() == 0) return true;\n    //     int fnd = s.find(\"abc\");\n    //     if(fnd != string::npos) {\n    //         string tLeft = s.substr(0, fnd);\n    //         string tRight = s.substr(fnd+3, s.size());\n    //         return isValid(tLeft+tRight);\n    //     }\n    //     return false;\n    // }\n    \n    // Using stack\n    bool isValid(string s) {\n        if(s[0] != 'a') return false;\n        stack<char> st;\n        for(int i=0; i<s.length(); i++) {\n            if(s[i] == 'c') {\n                if(!st.empty() && st.top() == 'b') {\n                    st.pop();\n                    if(!st.empty() && st.top() == 'a') {\n                        st.pop();\n                    } else {\n                        st.push('b');\n                        st.push('c');\n                    }\n                } else {\n                    st.push('c');\n                }\n            } else {\n                st.push(s[i]);\n            }\n        }\n        return st.empty();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "check-if-word-is-valid-after-substitutions",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 996079269,
            "question_id": 1045,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689530375,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "16 ms",
            "url": "/submissions/detail/996079269/",
            "is_pending": "Not Pending",
            "title": "Check If Word Is Valid After Substitutions",
            "memory": "8.5 MB",
            "code": "class Solution {\npublic:\n    // Recursive solution\n    // bool isValid(string s) {\n    //     if(s.size() == 0) return true;\n    //     int fnd = s.find(\"abc\");\n    //     if(fnd != string::npos) {\n    //         string tLeft = s.substr(0, fnd);\n    //         string tRight = s.substr(fnd+3, s.size());\n    //         return isValid(tLeft+tRight);\n    //     }\n    //     return false;\n    // }\n    \n    // Using stack\n    bool isValid(string s) {\n        stack<char> st;\n        for(int i=0; i<s.length(); i++) {\n            if(s[i] == 'c') {\n                if(!st.empty() && st.top() == 'b') {\n                    st.pop();\n                    if(!st.empty() && st.top() == 'a') {\n                        st.pop();\n                    } else {\n                        st.push('b');\n                        st.push('c');\n                    }\n                } else {\n                    st.push('c');\n                }\n            } else {\n                st.push(s[i]);\n            }\n        }\n        return st.empty();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "check-if-word-is-valid-after-substitutions",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 996079076,
            "question_id": 1045,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689530358,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "20 ms",
            "url": "/submissions/detail/996079076/",
            "is_pending": "Not Pending",
            "title": "Check If Word Is Valid After Substitutions",
            "memory": "8.5 MB",
            "code": "class Solution {\npublic:\n    // Recursive solution\n    // bool isValid(string s) {\n    //     if(s.size() == 0) return true;\n    //     int fnd = s.find(\"abc\");\n    //     if(fnd != string::npos) {\n    //         string tLeft = s.substr(0, fnd);\n    //         string tRight = s.substr(fnd+3, s.size());\n    //         return isValid(tLeft+tRight);\n    //     }\n    //     return false;\n    // }\n    \n    // Using stack\n    bool isValid(string s) {\n        stack<char> st;\n        for(int i=0; i<s.length(); i++) {\n            if(s[i] == 'c') {\n                if(!st.empty() && st.top() == 'b') {\n                    st.pop();\n                    if(!st.empty() && st.top() == 'a') {\n                        st.pop();\n                    } else {\n                        st.push('b');\n                        st.push('c');\n                    }\n                } else {\n                    st.push('c');\n                }\n            } else {\n                st.push(s[i]);\n            }\n        }\n        return st.empty();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "check-if-word-is-valid-after-substitutions",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 996057602,
            "question_id": 1045,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689528655,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "592 ms",
            "url": "/submissions/detail/996057602/",
            "is_pending": "Not Pending",
            "title": "Check If Word Is Valid After Substitutions",
            "memory": "697.7 MB",
            "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        if(s.size() == 0) return true;\n        int fnd = s.find(\"abc\");\n        if(fnd != string::npos) {\n            string tLeft = s.substr(0, fnd);\n            string tRight = s.substr(fnd+3, s.size());\n            return isValid(tLeft+tRight);\n        }\n        return false;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "check-if-word-is-valid-after-substitutions",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 995938862,
            "question_id": 71,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689517977,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/995938862/",
            "is_pending": "Not Pending",
            "title": "Simplify Path",
            "memory": "8 MB",
            "code": "class Solution {\npublic:\n    void buildPath(stack<string> &st, string &ans) {\n        if(st.empty()) {\n            return;\n        }\n        string path = st.top();\n        st.pop();\n        buildPath(st, ans);\n        ans += path;\n    }\n    string simplifyPath(string path) {\n        stack<string> st;\n        int i=0;\n        while(i < path.size()) {\n            int start = i;\n            int end = i + 1;\n            while(end < path.size() && path[end] != '/') {\n                ++end;\n            }\n            i = end;\n            string minPath = path.substr(start, end-start);\n            if(minPath == \"/\" || minPath == \"/.\") {\n                continue;\n            } else if(minPath != \"/..\") {\n                st.push(minPath);\n            } else if(!st.empty()) {\n                st.pop();\n            }\n        }\n        string ans = st.empty() ? \"/\" : \"\";\n        buildPath(st, ans);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "simplify-path",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 995937999,
            "question_id": 71,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689517902,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/995937999/",
            "is_pending": "Not Pending",
            "title": "Simplify Path",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    void buildPath(stack<string> &st, string &ans) {\n        if(st.empty()) {\n            return;\n        }\n        string path = st.top();\n        st.pop();\n        buildPath(st, ans);\n        ans += path;\n    }\n    string simplifyPath(string path) {\n        stack<string> st;\n        int i=0;\n        while(i < path.size()) {\n            int start = i;\n            int end = i + 1;\n            while(end < path.size() && path[end] != '/') {\n                ++end;\n            }\n            i = end;\n            string minPath = path.substr(start, end-start);\n            if(minPath == \"/\" || minPath == \"/.\") {\n                continue;\n            } else if(minPath != \"/..\") {\n                st.push(minPath);\n            } else {\n                st.pop();\n            }\n        }\n        string ans = st.empty() ? \"/\" : \"\";\n        buildPath(st, ans);\n        return ans;\n    }\n};",
            "compare_result": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "simplify-path",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 995893822,
            "question_id": 937,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689513678,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "254 ms",
            "url": "/submissions/detail/995893822/",
            "is_pending": "Not Pending",
            "title": "Online Stock Span",
            "memory": "84.1 MB",
            "code": "class StockSpanner {\npublic:\n    stack<pair<int,int>> st;\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        int span = 1;\n        while(!st.empty() && st.top().first <= price) {\n            span += st.top().second;\n            st.pop();\n        }\n        st.push({price, span});\n        return span;\n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "online-stock-span",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 995893735,
            "question_id": 937,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 1 week",
            "timestamp": 1689513668,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "242 ms",
            "url": "/submissions/detail/995893735/",
            "is_pending": "Not Pending",
            "title": "Online Stock Span",
            "memory": "84.1 MB",
            "code": "class StockSpanner {\npublic:\n    stack<pair<int,int>> st;\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        int span = 1;\n        while(!st.empty() && st.top().first <= price) {\n            span += st.top().second;\n            st.pop();\n        }\n        st.push({price, span});\n        return span;\n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "online-stock-span",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 986374305,
            "question_id": 1072,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 3 weeks",
            "timestamp": 1688496133,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "117 ms",
            "url": "/submissions/detail/986374305/",
            "is_pending": "Not Pending",
            "title": "Next Greater Node In Linked List",
            "memory": "41.9 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nextLargerNodes(ListNode* head) {\n        vector<int> ll;\n        while(head) {\n            ll.push_back(head->val);\n            head = head->next;\n        }\n        stack<int> st;\n        for(int i=0; i<ll.size(); i++) {\n            while(!st.empty() && ll[i] > ll[st.top()]) {\n                int nextGreaterEleIndex = st.top();\n                st.pop();\n                ll[nextGreaterEleIndex] = ll[i];\n            }\n            st.push(i);\n        }\n        while(!st.empty()) {\n            ll[st.top()] = 0;\n            st.pop();\n        }\n        ll[ll.size()-1] = 0;\n        return ll;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "next-greater-node-in-linked-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 986371436,
            "question_id": 1072,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 3 weeks",
            "timestamp": 1688495902,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/986371436/",
            "is_pending": "Not Pending",
            "title": "Next Greater Node In Linked List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nextLargerNodes(ListNode* head) {\n        vector<int> ll;\n        while(head) {\n            ll.push_back(head->val);\n            head = head->next;\n        }\n        stack<int> st;\n        for(int i=0; i<ll.size(); i++) {\n            while(!st.empty() && ll[i] > ll[st.top()]) {\n                int nextGreaterEleIndex = st.top();\n                st.pop();\n                ll[nextGreaterEleIndex] = ll[i];\n            }\n            st.push(i);\n        }\n        ll[ll.size()-1] = 0;\n        return ll;\n    }\n};",
            "compare_result": "1001100100000001000110000000100000100000000000000000000000000000000000000000",
            "title_slug": "next-greater-node-in-linked-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 986253317,
            "question_id": 1128,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 3 weeks",
            "timestamp": 1688487193,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "28 ms",
            "url": "/submissions/detail/986253317/",
            "is_pending": "Not Pending",
            "title": "Remove All Adjacent Duplicates In String",
            "memory": "11.4 MB",
            "code": "class Solution {\npublic:\n    // string removeDuplicates(string s) {\n    //     string ans =\"\";\n    //     for(int i=0; i<s.length(); i++) {\n    //         if((ans.length() > 0) && s[i] == ans[ans.length()-1]) {\n    //             ans.pop_back();\n    //         } else {\n    //             ans.push_back(s[i]);\n    //         }\n    //     }\n    //     return ans;\n    // }\n    \n    // Using STACK:\n    string removeDuplicates(string s) {\n        stack<char> st;\n        for(auto ch: s) {\n            if(!st.empty() && ch == st.top()) {\n                st.pop();\n            } else {\n                st.push(ch);\n            }\n        }\n        string ans =\"\";\n        while(!st.empty()) {\n            ans += st.top();\n            st.pop();\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-adjacent-duplicates-in-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 986253193,
            "question_id": 1128,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 3 weeks",
            "timestamp": 1688487183,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "24 ms",
            "url": "/submissions/detail/986253193/",
            "is_pending": "Not Pending",
            "title": "Remove All Adjacent Duplicates In String",
            "memory": "11.5 MB",
            "code": "class Solution {\npublic:\n    // string removeDuplicates(string s) {\n    //     string ans =\"\";\n    //     for(int i=0; i<s.length(); i++) {\n    //         if((ans.length() > 0) && s[i] == ans[ans.length()-1]) {\n    //             ans.pop_back();\n    //         } else {\n    //             ans.push_back(s[i]);\n    //         }\n    //     }\n    //     return ans;\n    // }\n    \n    // Using STACK:\n    string removeDuplicates(string s) {\n        stack<char> st;\n        for(auto ch: s) {\n            if(!st.empty() && ch == st.top()) {\n                st.pop();\n            } else {\n                st.push(ch);\n            }\n        }\n        string ans =\"\";\n        while(!st.empty()) {\n            ans += st.top();\n            st.pop();\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-adjacent-duplicates-in-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 985615271,
            "question_id": 2299,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 3 weeks",
            "timestamp": 1688414421,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "722 ms",
            "url": "/submissions/detail/985615271/",
            "is_pending": "Not Pending",
            "title": "Merge Nodes in Between Zeros",
            "memory": "253 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeNodes(ListNode* head) {\n        if(!head) return 0;\n        ListNode* slow = head;\n        ListNode* lastNode = slow;\n        ListNode* fast = head->next;\n        \n        int sum = 0;\n        while(fast) {\n            if(fast->val == 0) {\n                slow->val = sum;\n                lastNode = slow;\n                slow = slow->next;\n                sum = 0;\n            } else {\n                sum += fast->val;\n            }\n            fast = fast->next;\n        }\n        lastNode->next = nullptr;\n        delete slow;\n        return head;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "merge-nodes-in-between-zeros",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 985596208,
            "question_id": 2182,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 3 weeks",
            "timestamp": 1688412534,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "224 ms",
            "url": "/submissions/detail/985596208/",
            "is_pending": "Not Pending",
            "title": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
            "memory": "113.4 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        vector<int> ans = {-1,-1};\n        ListNode* prev = head;\n        if(!prev) return ans;\n        ListNode* curr = head->next;\n        if(!curr) return ans;\n        ListNode* nxt = head->next->next;\n        if(!nxt) return ans;\n        \n        int firstCP = -1, lastCP = -1, minDist = INT_MAX;\n        int i = 1;\n        while(nxt) {\n            bool isCP = ((curr->val > prev->val && curr->val > nxt->val) || (curr->val < prev->val && curr->val < nxt->val));\n            if(isCP && firstCP == -1) {\n                firstCP = i;\n                lastCP = i;\n            } else if(isCP) {\n                minDist = min(minDist, i-lastCP);\n                lastCP = i;\n            }\n            prev = prev->next;\n            curr = curr->next;\n            nxt = nxt->next;\n            ++i;\n        }\n        if(lastCP == firstCP) {\n            return ans;\n        } else {\n            ans[0] = minDist;\n            ans[1] = lastCP - firstCP;\n            return ans;\n        }\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 985595813,
            "question_id": 2182,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "9 months, 3 weeks",
            "timestamp": 1688412498,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "239 ms",
            "url": "/submissions/detail/985595813/",
            "is_pending": "Not Pending",
            "title": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
            "memory": "113.3 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        vector<int> ans = {-1,-1};\n        ListNode* prev = head;\n        if(!prev) return ans;\n        ListNode* curr = head->next;\n        if(!curr) return ans;\n        ListNode* nxt = head->next->next;\n        if(!nxt) return ans;\n        \n        int firstCP = -1, lastCP = -1, minDist = INT_MAX;\n        int i = 1;\n        while(nxt) {\n            bool isCP = ((curr->val > prev->val && curr->val > nxt->val) || (curr->val < prev->val && curr->val < nxt->val));\n            if(isCP && firstCP == -1) {\n                firstCP = i;\n                lastCP = i;\n            } else if(isCP) {\n                minDist = min(minDist, i-lastCP);\n                lastCP = i;\n            }\n            prev = prev->next;\n            curr = curr->next;\n            nxt = nxt->next;\n            ++i;\n        }\n        if(lastCP == firstCP) {\n            return ans;\n        } else {\n            ans[0] = minDist;\n            ans[1] = lastCP - firstCP;\n            return ans;\n        }\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973871051,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687070720,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/973871051/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "11.8 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n//     ListNode* rotateRight(ListNode* head, int k) {\n//         if(!head || (head && head->next == nullptr) || k == 0) return head;\n//         ListNode* h1 = new ListNode(-1);\n//         ListNode* headNode = head;\n//         ListNode* h2 = headNode;\n        \n//         int len = findLength(headNode);\n//         int finalK = (k-1)%len;\n//         rotateRightHelper(h1,h2,headNode, finalK);\n//         return headNode;\n//     }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k <= 0) return head;\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int actualRotate = k%len;\n        if(actualRotate <= 0) return head;\n        int newLastNodePos = len-actualRotate-1;\n        \n        ListNode* newLastNode = head;\n        for(int i=0; i<newLastNodePos; i++) {\n            newLastNode = newLastNode->next;\n        }\n        ListNode* newHead = newLastNode->next;\n        newLastNode->next = NULL;\n        ListNode* it = newHead;\n        while(it->next) {\n            it = it->next;\n        }\n        it->next = head;\n        return newHead;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973870801,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687070695,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/973870801/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "11.6 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n//     ListNode* rotateRight(ListNode* head, int k) {\n//         if(!head || (head && head->next == nullptr) || k == 0) return head;\n//         ListNode* h1 = new ListNode(-1);\n//         ListNode* headNode = head;\n//         ListNode* h2 = headNode;\n        \n//         int len = findLength(headNode);\n//         int finalK = (k-1)%len;\n//         rotateRightHelper(h1,h2,headNode, finalK);\n//         return headNode;\n//     }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k <= 0) return head;\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int actualRotate = k%len;\n        if(actualRotate <= 0) return head;\n        int newLastNodePos = len-actualRotate-1;\n        \n        ListNode* newLastNode = head;\n        for(int i=0; i<newLastNodePos; i++) {\n            newLastNode = newLastNode->next;\n        }\n        ListNode* newHead = newLastNode->next;\n        newLastNode->next = NULL;\n        ListNode* it = newHead;\n        while(it->next) {\n            it = it->next;\n        }\n        it->next = head;\n        return newHead;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973870720,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687070687,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "9 ms",
            "url": "/submissions/detail/973870720/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "11.7 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n//     ListNode* rotateRight(ListNode* head, int k) {\n//         if(!head || (head && head->next == nullptr) || k == 0) return head;\n//         ListNode* h1 = new ListNode(-1);\n//         ListNode* headNode = head;\n//         ListNode* h2 = headNode;\n        \n//         int len = findLength(headNode);\n//         int finalK = (k-1)%len;\n//         rotateRightHelper(h1,h2,headNode, finalK);\n//         return headNode;\n//     }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k <= 0) return head;\n        // ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int actualRotate = k%len;\n        if(actualRotate <= 0) return head;\n        int newLastNodePos = len-actualRotate-1;\n        \n        ListNode* newLastNode = head;\n        for(int i=0; i<newLastNodePos; i++) {\n            newLastNode = newLastNode->next;\n        }\n        ListNode* newHead = newLastNode->next;\n        newLastNode->next = NULL;\n        ListNode* it = newHead;\n        while(it->next) {\n            it = it->next;\n        }\n        it->next = head;\n        return newHead;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973867504,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687070347,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/973867504/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n//     ListNode* rotateRight(ListNode* head, int k) {\n//         if(!head || (head && head->next == nullptr) || k == 0) return head;\n//         ListNode* h1 = new ListNode(-1);\n//         ListNode* headNode = head;\n//         ListNode* h2 = headNode;\n        \n//         int len = findLength(headNode);\n//         int finalK = (k-1)%len;\n//         rotateRightHelper(h1,h2,headNode, finalK);\n//         return headNode;\n//     }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k <= 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int actualRotate = k%len;\n        int newLastNodePos = len-actualRotate-1;\n        \n        ListNode* newLastNode = head;\n        for(int i=0; i<newLastNodePos; i++) {\n            newLastNode = newLastNode->next;\n        }\n        ListNode* newHead = newLastNode->next;\n        newLastNode->next = NULL;\n        ListNode* it = newHead;\n        while(it->next) {\n            it = it->next;\n        }\n        it->next = head;\n        return newHead;\n    }\n};",
            "compare_result": "111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973866264,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687070208,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/973866264/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n//     ListNode* rotateRight(ListNode* head, int k) {\n//         if(!head || (head && head->next == nullptr) || k == 0) return head;\n//         ListNode* h1 = new ListNode(-1);\n//         ListNode* headNode = head;\n//         ListNode* h2 = headNode;\n        \n//         int len = findLength(headNode);\n//         int finalK = (k-1)%len;\n//         rotateRightHelper(h1,h2,headNode, finalK);\n//         return headNode;\n//     }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k <= 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int finalK = (k-1)%len;\n        \n        ListNode* newLastNode = head;\n        for(int i=0; i<finalK; i++) {\n            newLastNode = newLastNode->next;\n        }\n        ListNode* newHead = newLastNode->next;\n        newLastNode->next = NULL;\n        ListNode* it = newHead;\n        while(it->next) {\n            it = it->next;\n        }\n        it->next = head;\n        return newHead;\n    }\n};",
            "compare_result": "001111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973838767,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687067132,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/973838767/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "11.9 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int finalK = (k-1)%len;\n        rotateRightHelper(h1,h2,headNode, finalK);\n        return headNode;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973838701,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687067123,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "12 ms",
            "url": "/submissions/detail/973838701/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "11.9 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int finalK = (k-1)%len;\n        rotateRightHelper(h1,h2,headNode, finalK);\n        return headNode;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973838282,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687067071,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "9 ms",
            "url": "/submissions/detail/973838282/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "12 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, int& k) {\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int finalK = (k-1)%len;\n        rotateRightHelper(h1,h2,headNode, finalK);\n        return headNode;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 973837823,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 1 week",
            "timestamp": 1687067015,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "13 ms",
            "url": "/submissions/detail/973837823/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "11.9 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    void rotateRightHelper(ListNode* h1,ListNode*& h2,ListNode*& headNode, long long int& k) {\n        // cout<<\"k: \"<<k<<endl;\n        if(k < 0) return;\n        h1 = new ListNode(-1);\n        h1->next = headNode;\n        while(h2->next) {\n            h1=h1->next;\n            h2=h2->next;\n        }\n        // cout<<\"h2->val: \"<<h2->val<<endl;\n        // cout<<\"h1->val: \"<<h1->val<<endl;\n        h2->next = headNode;\n        headNode = h2;\n        h1->next = nullptr;\n        long long int finalK = k-1;\n        rotateRightHelper(h1,h2,headNode,finalK);\n        // cout<<\"k: \"<<k<<endl;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        // h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        long long int finalK = (k-1)%len;\n        rotateRightHelper(h1,h2,headNode, finalK);\n        cout<<k%len;\n        return headNode;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968841279,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686485138,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/968841279/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        cout<<\"pos: \"<<pos<<endl;\n        if(pos == 0) return head;\n        // if(abs(pos) == 1) pos = len-abs(pos);\n        if(pos<=1) pos = len-abs(pos);\n        cout<<\"abs(pos): \"<<abs(pos)<<endl;\n        cout<<\"after abs(pos): \"<<abs(pos)<<endl;\n        while(pos && h2->next) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        // cout<<\"h1->val: \"<<h1->val<<endl;\n        // cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111111111111011011111110111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968835083,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686484423,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968835083/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        cout<<\"pos: \"<<pos<<endl;\n        cout<<\"abs(pos): \"<<abs(pos)<<endl;\n        if(pos == 0) return head;\n        if(abs(pos) == 1) pos = len-abs(pos);\n        else if(pos<0) pos = abs(pos)+1;\n        cout<<\"after abs(pos): \"<<abs(pos)<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968818342,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686482493,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968818342/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        if(pos == 0) return head;\n        if(pos<0) pos = abs(pos)+1;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968756174,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686475215,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968756174/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr) || k == 0) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        if(pos<0) pos = abs(pos)+1;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968755807,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686475172,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968755807/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr)) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        if(pos<0) pos = abs(pos)+1;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968755274,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686475110,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968755274/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && head->next == nullptr && k<=1)) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        if(pos<0) pos = abs(pos)+1;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968753187,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686474862,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968753187/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || (head && !k)) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        if(pos<0) pos = abs(pos)+1;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968731432,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686472322,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968731432/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head) return head;\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        if(pos<0) pos = abs(pos)+1;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968730498,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686472211,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968730498/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        if(pos<0) pos = abs(pos)+1;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968727610,
            "question_id": 61,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686471881,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968727610/",
            "is_pending": "Not Pending",
            "title": "Rotate List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode* head) {\n        int c = 0;\n        while(head) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* h1 = new ListNode(-1);\n        ListNode* headNode = head;\n        h1->next = headNode;\n        ListNode* h2 = headNode;\n        \n        int len = findLength(headNode);\n        int pos = len-k;\n        cout<<\"pos: \"<<pos<<endl;\n        while(pos) {\n            h1 = h1->next;\n            h2 = h2->next;\n            pos--;\n        }\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        ListNode* tail = headNode;\n        cout<<\"before while headNode->val: \"<<headNode->val<<endl;\n        while(headNode) {\n            if(headNode->next == nullptr) {\n                cout<<\"if nullptr, headNode->val: \"<<headNode->val<<endl;\n                tail = headNode;\n            }\n            headNode = headNode->next;\n        }\n        headNode = head;\n        cout<<\"after while headNode->val: \"<<headNode->val<<endl;\n        h1->next = nullptr;\n        cout<<\"h1->val: \"<<h1->val<<endl;\n        cout<<\"h2->val: \"<<h2->val<<endl;\n        cout<<\"tail->val: \"<<tail->val<<endl;\n        tail->next = headNode;\n        head = h2;\n        return head;\n    }\n};",
            "compare_result": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "rotate-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968200695,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686413295,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/968200695/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "11.1 MB",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp)\n        {\n            if(temp->random)\n                cout << \"temp->val: \"<<temp->val << \", temp->random->val: \"<<temp->random->val<<endl;\n            else cout << \"temp->val: \"<<temp->val << \", temp->random->val: NULL\"<<endl;\n            temp = temp->next;\n        }\n    }\n    int findRandomElePosition(Node* head, Node* headRandom) {\n        int c = 0;\n        while(head && head != headRandom) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    Node* findRandom(Node*& copyLL, Node* head) {\n        Node* copyLLHead = copyLL;\n        Node* tempHead = head;\n        int len = findLength(head);\n        while(tempHead) {\n            if(tempHead->random) {\n                int randomPosition = findRandomElePosition(head, tempHead->random);\n                if(randomPosition <= len) {\n                    Node* travCopyLL = copyLL;\n                    while(randomPosition != -1) {\n                        copyLLHead->random = travCopyLL;\n                        travCopyLL = travCopyLL->next;\n                        randomPosition--;\n                    }\n                }\n            } else {\n                copyLLHead->random = NULL;\n            }\n            tempHead = tempHead->next;\n            copyLLHead = copyLLHead->next;\n        }\n        return copyLL;\n    }\n    // Node* copyRandomList(Node* head) {\n    //     if(!head) return NULL;\n    //     Node* temp = head;\n    //     Node* copyLL = new Node(temp->val);\n    //     Node* copyLLHead = copyLL;\n    //     temp = temp->next;\n    //     while(temp) {\n    //         Node* tempNode = new Node(temp->val);\n    //         copyLL->next = tempNode;\n    //         copyLL = copyLL->next;\n    //         temp = temp->next;\n    //     }\n    //     Node* randomNodes = findRandom(copyLLHead, head);\n    //     return copyLLHead;\n    // }\n    \n    // 2nd approach\n    Node* copyRandomList(Node* head) {\n        if(!head) return 0;\n        // Step1: Clone A -> A'.\n        Node* it = head;\n        while(it) {\n            Node* clonedNode = new Node(it->val);\n            clonedNode->next = it->next;\n            it->next = clonedNode;\n            it = clonedNode->next;\n        }\n        \n        // Step2: Assign random links of A' with the help of A.\n        it = head;\n        while(it) {\n            Node* clonedNode = it->next;\n            clonedNode->random = it->random ? it->random->next : nullptr;\n            it = it->next->next;\n        }\n        \n        // Step3: Detach A' from A.\n        it = head;\n        Node* clonedHead = it->next;\n        while(it) {\n            Node* cloneNode = it->next;\n            it->next = cloneNode->next;\n            if(cloneNode->next) {\n                cloneNode->next = cloneNode->next->next;\n            }\n            it = it->next;\n            cloneNode = cloneNode->next;\n        }\n        return clonedHead;\n    }\n};",
            "compare_result": "1111111111111111111",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968200496,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686413276,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/968200496/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "11.2 MB",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp)\n        {\n            if(temp->random)\n                cout << \"temp->val: \"<<temp->val << \", temp->random->val: \"<<temp->random->val<<endl;\n            else cout << \"temp->val: \"<<temp->val << \", temp->random->val: NULL\"<<endl;\n            temp = temp->next;\n        }\n    }\n    int findRandomElePosition(Node* head, Node* headRandom) {\n        int c = 0;\n        while(head && head != headRandom) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    Node* findRandom(Node*& copyLL, Node* head) {\n        Node* copyLLHead = copyLL;\n        Node* tempHead = head;\n        int len = findLength(head);\n        while(tempHead) {\n            if(tempHead->random) {\n                int randomPosition = findRandomElePosition(head, tempHead->random);\n                if(randomPosition <= len) {\n                    Node* travCopyLL = copyLL;\n                    while(randomPosition != -1) {\n                        copyLLHead->random = travCopyLL;\n                        travCopyLL = travCopyLL->next;\n                        randomPosition--;\n                    }\n                }\n            } else {\n                copyLLHead->random = NULL;\n            }\n            tempHead = tempHead->next;\n            copyLLHead = copyLLHead->next;\n        }\n        return copyLL;\n    }\n    // Node* copyRandomList(Node* head) {\n    //     if(!head) return NULL;\n    //     Node* temp = head;\n    //     Node* copyLL = new Node(temp->val);\n    //     Node* copyLLHead = copyLL;\n    //     temp = temp->next;\n    //     while(temp) {\n    //         Node* tempNode = new Node(temp->val);\n    //         copyLL->next = tempNode;\n    //         copyLL = copyLL->next;\n    //         temp = temp->next;\n    //     }\n    //     Node* randomNodes = findRandom(copyLLHead, head);\n    //     return copyLLHead;\n    // }\n    \n    // 2nd approach\n    Node* copyRandomList(Node* head) {\n        if(!head) return 0;\n        // Step1: Clone A -> A'.\n        Node* it = head;\n        while(it) {\n            Node* clonedNode = new Node(it->val);\n            clonedNode->next = it->next;\n            it->next = clonedNode;\n            it = clonedNode->next;\n        }\n        \n        // Step2: Assign random links of A' with the help of A.\n        it = head;\n        while(it) {\n            Node* clonedNode = it->next;\n            clonedNode->random = it->random ? it->random->next : nullptr;\n            it = it->next->next;\n        }\n        \n        // Step3: Detach A' from A.\n        it = head;\n        Node* clonedHead = it->next;\n        while(it) {\n            Node* cloneNode = it->next;\n            it->next = cloneNode->next;\n            if(cloneNode->next) {\n                cloneNode->next = cloneNode->next->next;\n            }\n            it = it->next;\n            cloneNode = cloneNode->next;\n        }\n        return clonedHead;\n    }\n};",
            "compare_result": "1111111111111111111",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968200337,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686413261,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/968200337/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "11.1 MB",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp)\n        {\n            if(temp->random)\n                cout << \"temp->val: \"<<temp->val << \", temp->random->val: \"<<temp->random->val<<endl;\n            else cout << \"temp->val: \"<<temp->val << \", temp->random->val: NULL\"<<endl;\n            temp = temp->next;\n        }\n    }\n    int findRandomElePosition(Node* head, Node* headRandom) {\n        int c = 0;\n        while(head && head != headRandom) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    Node* findRandom(Node*& copyLL, Node* head) {\n        Node* copyLLHead = copyLL;\n        Node* tempHead = head;\n        int len = findLength(head);\n        while(tempHead) {\n            if(tempHead->random) {\n                int randomPosition = findRandomElePosition(head, tempHead->random);\n                if(randomPosition <= len) {\n                    Node* travCopyLL = copyLL;\n                    while(randomPosition != -1) {\n                        copyLLHead->random = travCopyLL;\n                        travCopyLL = travCopyLL->next;\n                        randomPosition--;\n                    }\n                }\n            } else {\n                copyLLHead->random = NULL;\n            }\n            tempHead = tempHead->next;\n            copyLLHead = copyLLHead->next;\n        }\n        return copyLL;\n    }\n    // Node* copyRandomList(Node* head) {\n    //     if(!head) return NULL;\n    //     Node* temp = head;\n    //     Node* copyLL = new Node(temp->val);\n    //     Node* copyLLHead = copyLL;\n    //     temp = temp->next;\n    //     while(temp) {\n    //         Node* tempNode = new Node(temp->val);\n    //         copyLL->next = tempNode;\n    //         copyLL = copyLL->next;\n    //         temp = temp->next;\n    //     }\n    //     Node* randomNodes = findRandom(copyLLHead, head);\n    //     return copyLLHead;\n    // }\n    \n    // 2nd approach\n    Node* copyRandomList(Node* head) {\n        if(!head) return 0;\n        // Step1: Clone A -> A'.\n        Node* it = head;\n        while(it) {\n            Node* clonedNode = new Node(it->val);\n            clonedNode->next = it->next;\n            it->next = clonedNode;\n            it = clonedNode->next;\n        }\n        \n        // Step2: Assign random links of A' with the help of A.\n        it = head;\n        while(it) {\n            Node* clonedNode = it->next;\n            clonedNode->random = it->random ? it->random->next : nullptr;\n            it = it->next->next;\n        }\n        \n        // Step3: Detach A' from A.\n        it = head;\n        Node* clonedHead = it->next;\n        while(it) {\n            Node* cloneNode = it->next;\n            it->next = cloneNode->next;\n            if(cloneNode->next) {\n                cloneNode->next = cloneNode->next->next;\n            }\n            it = it->next;\n            cloneNode = cloneNode->next;\n        }\n        return clonedHead;\n    }\n};",
            "compare_result": "1111111111111111111",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968052294,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686404959,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/968052294/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "11 MB",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp)\n        {\n            if(temp->random)\n                cout << \"temp->val: \"<<temp->val << \", temp->random->val: \"<<temp->random->val<<endl;\n            else cout << \"temp->val: \"<<temp->val << \", temp->random->val: NULL\"<<endl;\n            temp = temp->next;\n        }\n    }\n    int findRandomElePosition(Node* head, Node* headRandom) {\n        int c = 0;\n        while(head && head != headRandom) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    Node* findRandom(Node*& copyLL, Node* head) {\n        Node* copyLLHead = copyLL;\n        Node* tempHead = head;\n        int len = findLength(head);\n        while(tempHead) {\n            if(tempHead->random) {\n                int randomPosition = findRandomElePosition(head, tempHead->random);\n                if(randomPosition <= len) {\n                    Node* travCopyLL = copyLL;\n                    while(randomPosition != -1) {\n                        copyLLHead->random = travCopyLL;\n                        travCopyLL = travCopyLL->next;\n                        randomPosition--;\n                    }\n                }\n            } else {\n                copyLLHead->random = NULL;\n            }\n            tempHead = tempHead->next;\n            copyLLHead = copyLLHead->next;\n        }\n        return copyLL;\n    }\n    Node* copyRandomList(Node* head) {\n        if(!head) return NULL;\n        Node* temp = head;\n        Node* copyLL = new Node(temp->val);\n        Node* copyLLHead = copyLL;\n        temp = temp->next;\n        while(temp) {\n            Node* tempNode = new Node(temp->val);\n            copyLL->next = tempNode;\n            copyLL = copyLL->next;\n            temp = temp->next;\n        }\n        Node* randomNodes = findRandom(copyLLHead, head);\n        return copyLLHead;\n    }\n};",
            "compare_result": "1111111111111111111",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968052140,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686404941,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "12 ms",
            "url": "/submissions/detail/968052140/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "11.2 MB",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp)\n        {\n            if(temp->random)\n                cout << \"temp->val: \"<<temp->val << \", temp->random->val: \"<<temp->random->val<<endl;\n            else cout << \"temp->val: \"<<temp->val << \", temp->random->val: NULL\"<<endl;\n            temp = temp->next;\n        }\n    }\n    int findRandomElePosition(Node* head, Node* headRandom) {\n        int c = 0;\n        while(head && head != headRandom) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    Node* findRandom(Node*& copyLL, Node* head) {\n        Node* copyLLHead = copyLL;\n        Node* tempHead = head;\n        int len = findLength(head);\n        while(tempHead) {\n            if(tempHead->random) {\n                int randomPosition = findRandomElePosition(head, tempHead->random);\n                cout<<\"pos: \"<<randomPosition<< \" \"<<endl;\n                if(randomPosition <= len) {\n                    Node* travCopyLL = copyLL;\n                    while(randomPosition != -1) {\n                        copyLLHead->random = travCopyLL;\n                        travCopyLL = travCopyLL->next;\n                        randomPosition--;\n                    }\n                }\n            } else {\n                copyLLHead->random = NULL;\n            }\n            tempHead = tempHead->next;\n            copyLLHead = copyLLHead->next;\n        }\n        return copyLL;\n    }\n    Node* copyRandomList(Node* head) {\n        if(!head) return NULL;\n        Node* temp = head;\n        Node* copyLL = new Node(temp->val);\n        Node* copyLLHead = copyLL;\n        temp = temp->next;\n        while(temp) {\n            Node* tempNode = new Node(temp->val);\n            copyLL->next = tempNode;\n            copyLL = copyLL->next;\n            temp = temp->next;\n        }\n        Node* randomNodes = findRandom(copyLLHead, head);\n        return copyLLHead;\n    }\n};",
            "compare_result": "1111111111111111111",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968032142,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686402324,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/968032142/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "N/A",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            cout << temp->val << \" \";\n            temp = temp->next;\n        }\n    }\n    int findRandomElePosition(Node* head, Node* headRandom) {\n        int c = 0;\n        while(head && head != headRandom) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    Node* findRandom(Node*& copyLL, Node* head) {\n        Node* tempHead = head;\n        Node* copyLLHead = copyLL;\n        int len = findLength(head);\n        while(tempHead) {\n            if(tempHead->random) {\n                int randomPosition = findRandomElePosition(head, tempHead->random);\n                if(randomPosition <= len) {\n                    Node* travCopyLL = copyLL;\n                    while(randomPosition != -1) {\n                        copyLLHead->random = travCopyLL;\n                        travCopyLL = travCopyLL->next;\n                        randomPosition--;\n                    }\n                }\n            } else {\n                copyLL->random = NULL;\n            }\n            tempHead = tempHead->next;\n            copyLLHead = copyLLHead->next;\n        }\n        return copyLL;\n    }\n    Node* copyRandomList(Node* head) {\n        if(!head) return NULL;\n        Node* temp = head;\n        Node* copyLL = new Node(temp->val);\n        Node* copyLLHead = copyLL;\n        temp = temp->next;\n        while(temp) {\n            Node* tempNode = new Node(temp->val);\n            copyLL->next = tempNode;\n            copyLL = copyLL->next;\n            temp = temp->next;\n        }\n        Node* randomNodes = findRandom(copyLLHead, head);\n        return copyLLHead;\n    }\n};",
            "compare_result": "1111111001011001001",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 968031600,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686402256,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/968031600/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "N/A",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            cout << temp->val << \" \";\n            temp = temp->next;\n        }\n    }\n    int findRandomElePosition(Node* head, Node* headRandom) {\n        int c = 0;\n        while(head && head != headRandom) {\n            c++;\n            head = head->next;\n        }\n        return c;\n    }\n    Node* findRandom(Node*& copyLL, Node* head) {\n        Node* tempHead = head;\n        Node* copyLLHead = copyLL;\n        int len = findLength(head);\n        while(tempHead) {\n            if(tempHead->random) {\n                int randomPosition = findRandomElePosition(head, tempHead->random);\n                if(randomPosition <= len) {\n                    Node* travCopyLL = copyLL;\n                    while(randomPosition != -1) {\n                        copyLLHead->random = travCopyLL;\n                        travCopyLL = travCopyLL->next;\n                        randomPosition--;\n                    }\n                }\n            } else {\n                copyLL->random = NULL;\n            }\n            tempHead = tempHead->next;\n            copyLLHead = copyLLHead->next;\n        }\n        return copyLL;\n    }\n    Node* copyRandomList(Node* head) {\n        Node* temp = head;\n        Node* copyLL = new Node(temp->val);\n        Node* copyLLHead = copyLL;\n        temp = temp->next;\n        while(temp) {\n            Node* tempNode = new Node(temp->val);\n            copyLL->next = tempNode;\n            copyLL = copyLL->next;\n            temp = temp->next;\n        }\n        Node* randomNodes = findRandom(copyLLHead, head);\n        return copyLLHead;\n    }\n};",
            "compare_result": "1110000000000000000",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 967981071,
            "question_id": 148,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686395849,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "303 ms",
            "url": "/submissions/detail/967981071/",
            "is_pending": "Not Pending",
            "title": "Sort List",
            "memory": "84 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findMid(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        \n        while(fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n    ListNode* merge(ListNode* listN1, ListNode* listN2) {\n        ListNode *list1 = listN1;\n        ListNode *list2 = listN2;\n        ListNode *temp = new ListNode();\n        ListNode *dummy = temp;\n        while(list1 != NULL && list2 != NULL) {\n            if(list2->val > list1->val) {\n                dummy->next = list1;\n                list1 = list1->next;\n            } else {\n                dummy->next = list2;\n                list2 = list2->next;\n            }\n            dummy = dummy->next;\n        }\n        if(list1) dummy->next = list1;\n        if(list2) dummy->next = list2;\n        dummy = temp->next;\n        delete temp;\n        return dummy;\n    }\n    ListNode* sortList(ListNode* head) {\n        if(head == 0 || head->next == 0) return head;\n        \n        // Break LL into two halves using mid node.\n        ListNode* mid = findMid(head);\n        ListNode* left = head;\n        ListNode* right = mid->next;\n        mid->next = 0;\n        \n        // Sort RE\n        left = sortList(left);\n        right = sortList(right);\n        \n        ListNode* mergeLL = merge(left, right);\n        return mergeLL;\n    }\n};",
            "compare_result": "111111111111111111111111111111",
            "title_slug": "sort-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 967980996,
            "question_id": 148,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686395840,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "308 ms",
            "url": "/submissions/detail/967980996/",
            "is_pending": "Not Pending",
            "title": "Sort List",
            "memory": "83.8 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findMid(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        \n        while(fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n    ListNode* merge(ListNode* listN1, ListNode* listN2) {\n        ListNode *list1 = listN1;\n        ListNode *list2 = listN2;\n        ListNode *temp = new ListNode();\n        ListNode *dummy = temp;\n        while(list1 != NULL && list2 != NULL) {\n            if(list2->val > list1->val) {\n                dummy->next = list1;\n                list1 = list1->next;\n            } else {\n                dummy->next = list2;\n                list2 = list2->next;\n            }\n            dummy = dummy->next;\n        }\n        if(list1) dummy->next = list1;\n        if(list2) dummy->next = list2;\n        dummy = temp->next;\n        delete temp;\n        return dummy;\n    }\n    ListNode* sortList(ListNode* head) {\n        if(head == 0 || head->next == 0) return head;\n        \n        // Break LL into two halves using mid node.\n        ListNode* mid = findMid(head);\n        ListNode* left = head;\n        ListNode* right = mid->next;\n        mid->next = 0;\n        \n        // Sort RE\n        left = sortList(left);\n        right = sortList(right);\n        \n        ListNode* mergeLL = merge(left, right);\n        return mergeLL;\n    }\n};",
            "compare_result": "111111111111111111111111111111",
            "title_slug": "sort-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 967980916,
            "question_id": 148,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686395830,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "285 ms",
            "url": "/submissions/detail/967980916/",
            "is_pending": "Not Pending",
            "title": "Sort List",
            "memory": "83.8 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findMid(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        \n        while(fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n    ListNode* merge(ListNode* listN1, ListNode* listN2) {\n        ListNode *list1 = listN1;\n        ListNode *list2 = listN2;\n        ListNode *temp = new ListNode();\n        ListNode *dummy = temp;\n        while(list1 != NULL && list2 != NULL) {\n            if(list2->val > list1->val) {\n                dummy->next = list1;\n                list1 = list1->next;\n            } else {\n                dummy->next = list2;\n                list2 = list2->next;\n            }\n            dummy = dummy->next;\n        }\n        if(list1) dummy->next = list1;\n        if(list2) dummy->next = list2;\n        dummy = temp->next;\n        delete temp;\n        return dummy;\n    }\n    ListNode* sortList(ListNode* head) {\n        if(head == 0 || head->next == 0) return head;\n        \n        // Break LL into two halves using mid node.\n        ListNode* mid = findMid(head);\n        ListNode* left = head;\n        ListNode* right = mid->next;\n        mid->next = 0;\n        \n        // Sort RE\n        left = sortList(left);\n        right = sortList(right);\n        \n        ListNode* mergeLL = merge(left, right);\n        return mergeLL;\n    }\n};",
            "compare_result": "111111111111111111111111111111",
            "title_slug": "sort-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 967980355,
            "question_id": 148,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686395760,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/967980355/",
            "is_pending": "Not Pending",
            "title": "Sort List",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findMid(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = slow->next;\n        \n        while(fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n    ListNode* merge(ListNode* listN1, ListNode* listN2) {\n        ListNode *list1 = listN1;\n        ListNode *list2 = listN2;\n        ListNode *temp = new ListNode();\n        ListNode *dummy = temp;\n        while(list1 != NULL && list2 != NULL) {\n            if(list2->val > list1->val) {\n                dummy->next = list1;\n                list1 = list1->next;\n            } else {\n                dummy->next = list2;\n                list2 = list2->next;\n            }\n            dummy = dummy->next;\n        }\n        if(list1) dummy->next = list1;\n        if(list2) dummy->next = list2;\n        dummy = temp->next;\n        delete temp;\n        return dummy;\n    }\n    ListNode* sortList(ListNode* head) {\n        if(head == 0 || head->next == 0) return head;\n        \n        // Break LL into two halves using mid node.\n        ListNode* mid = findMid(head);\n        ListNode* left = head;\n        ListNode* right = mid->next;\n        mid->next = 0;\n        \n        // Sort RE\n        left = sortList(left);\n        right = sortList(right);\n        \n        ListNode* mergeLL = merge(left, right);\n        return mergeLL;\n    }\n};",
            "compare_result": "100000000000000000000000000000",
            "title_slug": "sort-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 967859474,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686381016,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "51 ms",
            "url": "/submissions/detail/967859474/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "14.7 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next && headB->next) {\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        if(headA == headB) return headA;\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next) {\n                bLen++;\n               headB = headB->next;\n            }\n            if(bLen == 0) {\n                if(headA == headB)\n                    return headB;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            while(bLen--) {\n                headB = headB->next;\n            }\n            while(headA->next && headB->next) {\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headB;\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next) {\n                aLen++;\n                headA = headA->next;\n            }\n            if(aLen == 0) {\n                if(headA == headB)\n                    return headA;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            while(aLen--) {\n                headA = headA->next;\n            }\n            while(headA->next && headB->next) {\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headA;\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 967859394,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686381007,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "56 ms",
            "url": "/submissions/detail/967859394/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "14.6 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next && headB->next) {\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        if(headA == headB) return headA;\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next) {\n                bLen++;\n               headB = headB->next;\n            }\n            if(bLen == 0) {\n                if(headA == headB)\n                    return headB;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            while(bLen--) {\n                headB = headB->next;\n            }\n            while(headA->next && headB->next) {\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headB;\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next) {\n                aLen++;\n                headA = headA->next;\n            }\n            if(aLen == 0) {\n                if(headA == headB)\n                    return headA;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            while(aLen--) {\n                headA = headA->next;\n            }\n            while(headA->next && headB->next) {\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headA;\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 967859287,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 2 weeks",
            "timestamp": 1686380995,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "50 ms",
            "url": "/submissions/detail/967859287/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "14.6 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next && headB->next) {\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        if(headA == headB) return headA;\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next) {\n                bLen++;\n               headB = headB->next;\n            }\n            if(bLen == 0) {\n                if(headA == headB)\n                    return headB;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            while(bLen--) {\n                headB = headB->next;\n            }\n            while(headA->next && headB->next) {\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headB;\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next) {\n                aLen++;\n                headA = headA->next;\n            }\n            if(aLen == 0) {\n                if(headA == headB)\n                    return headA;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            while(aLen--) {\n                headA = headA->next;\n            }\n            while(headA->next && headB->next) {\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headA;\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 964343033,
            "question_id": 138,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685965797,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/964343033/",
            "is_pending": "Not Pending",
            "title": "Copy List with Random Pointer",
            "memory": "N/A",
            "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int findLength(Node *head)\n    {\n        int i = 0;\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    void print(Node *head)\n    {\n        if (head == NULL)\n        {\n            cout << \"\\nNothing to print. LL is empty.\\n\";\n            return;\n        }\n        Node *temp = head;\n        while (temp != NULL)\n        {\n            cout << temp->val << \" \";\n            temp = temp->next;\n        }\n    }\n    void findNextRandomNode(Node* head, Node*& copyList) {\n        while(head) {\n            if(head->random == NULL) {\n                copyList->random = NULL;\n            } else {\n                if(copyList && head->random)\n                    copyList->random = head->random;\n            }\n            if(copyList && copyList->next)\n                copyList = copyList->next;\n            head = head->next;\n        }\n    }\n    Node* findRandomNode(int value, Node* headNode) {\n        Node* copyList = headNode;\n        cout<<\"\\n findRandomNode value: \"<<value<<endl;\n        while(copyList) {\n            if(copyList->val == value) {\n                // Node* temp = copyList;\n                cout<<\"\\n findRandomNode copyList->val: \"<<copyList->val<<endl;\n                return copyList;\n            } else if(copyList->random) {\n                if(copyList->random->val == value) {\n                    // Node* rtemp = copyList;\n                    return copyList->random;\n                }\n            }\n            copyList = copyList->next;\n        }\n        return NULL;\n    }\n    void findNextNode(Node* temp, Node*& copyList, Node* headNode) {\n        cout<<\"copyList: \";\n        print(headNode);\n        cout<<endl;\n        while(temp) {\n            // Node* newNode = new Node(temp->val);\n            // copyList->next = newNode;\n            // copyList = copyList->next;\n            // temp = temp->next;\n            \n            if(temp->next) {\n                cout<<\"\\ntemp->next->val: \"<<temp->next->val<<endl;\n                Node* tempNode = findRandomNode(temp->next->val, headNode);\n                if(tempNode)\n                    cout<<\"\\ntempNode->val: \"<<tempNode->val<<endl;\n                else cout<<\"\\ntempNode->val: NULL\"<<endl;\n                if(tempNode) {\n                    copyList->next = tempNode;\n                } else {\n                    Node* newNode = new Node(temp->next->val);\n                    copyList->next = newNode;\n                    cout<<\"After adding in else: \";\n                    print(headNode);\n                    cout<<\", Len: \"<<findLength(headNode);\n                    cout<<endl;\n                }\n            } else {\n                copyList->next = NULL;\n            }\n            if(temp->random) {\n                cout<<\"\\nrtemp->random->val: \"<<temp->random->val<<endl;\n                Node* tempNode = findRandomNode(temp->random->val, headNode);\n                if(tempNode)\n                    cout<<\"\\nrtempNode->val: \"<<tempNode->val<<endl;\n                else cout<<\"\\nrtempNode->val: NULL\"<<endl;\n                if(tempNode) {\n                    copyList->random = tempNode;\n                    cout<<\"\\nrTempNode found and attached 'copyList->random->val':\"<<copyList->random->val<<endl;\n                } else {\n                    Node* newNode = new Node(temp->random->val);\n                    copyList->random = newNode;\n                }\n            } else {\n                copyList->random = NULL;\n            }\n            cout<<\"After random done Len: \"<<findLength(headNode)<<endl;\n            temp = temp->next;\n            copyList = copyList->next;\n            print(headNode);\n            cout<<\", Len: \"<<findLength(headNode);\n            cout<<endl;\n        }\n    }\n    Node* copyRandomList(Node* head) {\n        Node* temp = head;\n        Node* copyList = new Node(temp->val);\n        Node* headNode = copyList;\n        findNextNode(temp, copyList, headNode);\n        return headNode;\n    }\n};",
            "compare_result": "1100000000000000000",
            "title_slug": "copy-list-with-random-pointer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 963417443,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685851465,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "164 ms",
            "url": "/submissions/detail/963417443/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "14.7 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next != NULL && headB->next != NULL) {\n            cout<<\"Insideeee\";\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        cout<<\"initially headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n        if(headA == headB) return headA;\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next != NULL) {\n                bLen++;\n               headB = headB->next;\n            }\n            if(bLen == 0) {\n                if(headA == headB)\n                    return headB;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"bLen: \"<<bLen<<endl;\n            while(bLen!=0) {\n                bLen--;\n                headB = headB->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headB;\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next != NULL) {\n                aLen++;\n                headA = headA->next;\n            }\n            if(aLen == 0) {\n                if(headA == headB)\n                    return headA;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"aLen: \"<<aLen<<endl;\n            while(aLen!=0) {\n                aLen--;\n                headA = headA->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headA;\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 963417274,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685851446,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "153 ms",
            "url": "/submissions/detail/963417274/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "14.6 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next != NULL && headB->next != NULL) {\n            cout<<\"Insideeee\";\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        cout<<\"initially headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n        if(headA == headB) return headA;\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next != NULL) {\n                bLen++;\n               headB = headB->next;\n            }\n            if(bLen == 0) {\n                if(headA == headB)\n                    return headB;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"bLen: \"<<bLen<<endl;\n            while(bLen!=0) {\n                bLen--;\n                headB = headB->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headB;\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next != NULL) {\n                aLen++;\n                headA = headA->next;\n            }\n            if(aLen == 0) {\n                if(headA == headB)\n                    return headA;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"aLen: \"<<aLen<<endl;\n            while(aLen!=0) {\n                aLen--;\n                headA = headA->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            if(headA == headB) return headA;\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 963352004,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685847518,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/963352004/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next != NULL && headB->next != NULL) {\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next != NULL) {\n                bLen++;\n               headB = headB->next;\n            }\n            if(bLen == 0) {\n                if(headA == headB)\n                    return headB;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"bLen: \"<<bLen<<endl;\n            while(bLen!=0) {\n                bLen--;\n                headB = headB->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next != NULL) {\n                aLen++;\n                headA = headA->next;\n            }\n            if(aLen == 0) {\n                if(headA == headB)\n                    return headA;\n                return NULL;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"aLen: \"<<aLen<<endl;\n            while(aLen!=0) {\n                aLen--;\n                headA = headA->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111111111110011111111111111110101111",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 963348275,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685847333,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/963348275/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next != NULL && headB->next != NULL) {\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next != NULL) {\n                bLen++;\n               headB = headB->next;\n            }\n            if(bLen == 0) return headB;\n            headA = headAA;\n            headB = headBB;\n            cout<<\"bLen: \"<<bLen<<endl;\n            while(bLen!=0) {\n                bLen--;\n                headB = headB->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next != NULL) {\n                aLen++;\n                headA = headA->next;\n            }\n            if(aLen == 0) return headA;\n            headA = headAA;\n            headB = headBB;\n            cout<<\"aLen: \"<<aLen<<endl;\n            while(aLen!=0) {\n                aLen--;\n                headA = headA->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111110011110011111111111111110101110",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 963340644,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685846958,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/963340644/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next != NULL && headB->next != NULL) {\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headB->next != NULL) {\n                bLen++;\n               headB = headB->next;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"bLen: \"<<bLen<<endl;\n            while(bLen!=0) {\n                bLen--;\n                headB = headB->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headB;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            return NULL;\n        } else if(headB->next == NULL){\n            while(headA->next != NULL) {\n                aLen++;\n                headA = headA->next;\n            }\n            headA = headAA;\n            headB = headBB;\n            cout<<\"aLen: \"<<aLen<<endl;\n            while(aLen!=0) {\n                aLen--;\n                headA = headA->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "111111111111010011111111111111110101111",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 963309314,
            "question_id": 160,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685845070,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/963309314/",
            "is_pending": "Not Pending",
            "title": "Intersection of Two Linked Lists",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headAA, ListNode *headBB) {\n        ListNode* headA = headAA;\n        ListNode* headB = headBB;\n        while(headA->next != NULL && headB->next != NULL) {\n            if(headA==headB) return headA;\n            headA = headA->next;\n            headB = headA->next;\n        }\n        int aLen = 0, bLen = 0;\n        if(headA->next == NULL) {\n           while(headA->next != NULL) {\n                aLen++;\n               headA = headA->next;\n            }\n            headA = headAA;\n            headB = headBB;\n            while(aLen!=0) {\n                aLen--;\n                headA = headA->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL && headA != headB) {\n                headA = headA->next;\n                headB = headB->next;\n            } \n            return headA; \n        } else if(headB->next == NULL){\n            while(headB->next != NULL) {\n                bLen++;\n                headB = headB->next;\n            }\n            bLen++;\n            headA = headAA;\n            headB = headBB;\n            cout<<\"bLen: \"<<bLen<<endl;\n            while(bLen!=0) {\n                bLen--;\n                headB = headB->next;\n            }\n            cout<<\"headA->val: \"<<headA->val<<endl;\n            cout<<\"headB->val: \"<<headB->val<<endl;\n            while(headA->next != NULL && headB->next != NULL) {\n                cout<<\"headA->val: \"<<headA->val<<\", headB->val: \"<<headB->val<<endl;\n                if(headA == headB) return headA;\n                headA = headA->next;\n                headB = headB->next;\n            }\n            return NULL;\n        } else {\n            return NULL;\n        }\n    }\n};",
            "compare_result": "101000000000000000000000000000000000000",
            "title_slug": "intersection-of-two-linked-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 962975497,
            "question_id": 1758,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685797225,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "538 ms",
            "url": "/submissions/detail/962975497/",
            "is_pending": "Not Pending",
            "title": "Distribute Repeating Integers",
            "memory": "76.8 MB",
            "code": "class Solution {\npublic:\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity, int ithCustomer) {\n        // Base case\n        if(ithCustomer == quantity.size()) return true;\n        \n        for(int i=0; i<count.size(); i++) {\n            if(count[i] >= quantity[ithCustomer]) {\n                count[i] -= quantity[ithCustomer];\n                if(canDistributeHelper(count, quantity, ithCustomer+1)) {\n                    return true;\n                }\n                count[i] += quantity[ithCustomer];\n            }\n        }\n        return false;\n    }\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\n        unordered_map<int,int> countMap;\n        for(auto n: nums) {\n            countMap[n]++;\n        }\n        vector<int> count;\n        for(auto m: countMap) {\n            count.push_back(m.second);\n        }\n        sort(quantity.rbegin(), quantity.rend());\n        return canDistributeHelper(count, quantity, 0);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "distribute-repeating-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 962975388,
            "question_id": 1758,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685797211,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "523 ms",
            "url": "/submissions/detail/962975388/",
            "is_pending": "Not Pending",
            "title": "Distribute Repeating Integers",
            "memory": "76.8 MB",
            "code": "class Solution {\npublic:\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity, int ithCustomer) {\n        // Base case\n        if(ithCustomer == quantity.size()) return true;\n        \n        for(int i=0; i<count.size(); i++) {\n            if(count[i] >= quantity[ithCustomer]) {\n                count[i] -= quantity[ithCustomer];\n                if(canDistributeHelper(count, quantity, ithCustomer+1)) {\n                    return true;\n                }\n                count[i] += quantity[ithCustomer];\n            }\n        }\n        return false;\n    }\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\n        unordered_map<int,int> countMap;\n        for(auto n: nums) {\n            countMap[n]++;\n        }\n        vector<int> count;\n        for(auto m: countMap) {\n            count.push_back(m.second);\n        }\n        sort(quantity.rbegin(), quantity.rend());\n        return canDistributeHelper(count, quantity, 0);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "distribute-repeating-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 962974865,
            "question_id": 1758,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685797145,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/962974865/",
            "is_pending": "Not Pending",
            "title": "Distribute Repeating Integers",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity, int ithCustomer) {\n        // Base case\n        if(ithCustomer == quantity.size()) return true;\n        \n        for(int i=0; i<count.size(); i++) {\n            if(count[i] >= quantity[ithCustomer]) {\n                count[i] -= quantity[ithCustomer];\n                if(canDistributeHelper(count, quantity, ithCustomer+1)) {\n                    return true;\n                }\n                count[i] += quantity[ithCustomer];\n            }\n        }\n        return false;\n    }\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\n        unordered_map<int,int> countMap;\n        for(auto n: nums) {\n            countMap[n]++;\n        }\n        vector<int> count;\n        for(auto m: countMap) {\n            count.push_back(m.second);\n        }\n        sort(count.rbegin(), count.rend());\n        return canDistributeHelper(count, quantity, 0);\n    }\n};",
            "compare_result": "1111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "distribute-repeating-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 962974531,
            "question_id": 1758,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 3 weeks",
            "timestamp": 1685797098,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/962974531/",
            "is_pending": "Not Pending",
            "title": "Distribute Repeating Integers",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool canDistributeHelper(vector<int>& count, vector<int>& quantity, int ithCustomer) {\n        // Base case\n        if(ithCustomer == quantity.size()) return true;\n        \n        for(int i=0; i<count.size(); i++) {\n            if(count[i] >= quantity[ithCustomer]) {\n                count[i] -= quantity[ithCustomer];\n                if(canDistributeHelper(count, quantity, ithCustomer+1)) {\n                    return true;\n                }\n                count[i] += quantity[ithCustomer];\n            }\n        }\n        return false;\n    }\n    bool canDistribute(vector<int>& nums, vector<int>& quantity) {\n        unordered_map<int,int> countMap;\n        for(auto n: nums) {\n            countMap[n]++;\n        }\n        vector<int> count;\n        for(auto m: countMap) {\n            count.push_back(m.second);\n        }\n        return canDistributeHelper(count, quantity, 0);\n    }\n};",
            "compare_result": "1111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "distribute-repeating-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 961808327,
            "question_id": 526,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "10 months, 4 weeks",
            "timestamp": 1685640850,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "163 ms",
            "url": "/submissions/detail/961808327/",
            "is_pending": "Not Pending",
            "title": "Beautiful Arrangement",
            "memory": "6 MB",
            "code": "class Solution {\npublic:\n    void countArrangementHelper(vector<int>& vec, int& n, int& ans, int currNum) {\n        // Base case\n        if(currNum == n+1) {\n            ans++;\n            return;\n        }\n        \n        for(int i=1; i<=n; i++) {\n            if(vec[i] == 0 && (i%currNum == 0 || currNum%i == 0)) {\n                vec[i] = currNum;\n                countArrangementHelper(vec, n, ans, currNum+1);\n                vec[i] = 0;\n            }\n        }\n    }\n    int countArrangement(int n) {\n        vector<int> vec(n+1);\n        int ans = 0;\n        countArrangementHelper(vec, n, ans, 1);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111",
            "title_slug": "beautiful-arrangement",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 960463543,
            "question_id": 47,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months",
            "timestamp": 1685472708,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/960463543/",
            "is_pending": "Not Pending",
            "title": "Permutations II",
            "memory": "11 MB",
            "code": "class Solution {\npublic:\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& ans, int start) {\n        if(start == nums.size()) {\n            ans.push_back(nums);\n            return;\n        }\n        unordered_map<int,bool> visited;\n        for(int i=start; i<nums.size(); i++) {\n            if(visited.find(nums[i]) != visited.end()) {\n                continue;\n            }\n            visited[nums[i]] = true;\n            swap(nums[i],nums[start]);\n            permuteUnique(nums, ans, start+1);\n            swap(nums[i],nums[start]);\n        }\n    }\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> ans;\n        permuteUnique(nums, ans, 0);\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111",
            "title_slug": "permutations-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 960427834,
            "question_id": 40,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months",
            "timestamp": 1685469442,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/960427834/",
            "is_pending": "Not Pending",
            "title": "Combination Sum II",
            "memory": "10.6 MB",
            "code": "class Solution {\npublic:\n    void combinationSum2Helper(vector<int>& candidates, int target, vector<vector<int>>&ans, vector<int>& v, int index) {\n        if(target == 0) {\n            ans.push_back(v);\n            return;\n        }\n        if(target < 0) {\n            return;\n        }\n        for(int i=index; i<candidates.size(); i++) {\n            if(i > index && candidates[i] == candidates[i-1]) {\n                continue;\n            }\n            v.push_back(candidates[i]);\n            combinationSum2Helper(candidates, target-candidates[i], ans, v, i+1);\n            v.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> ans;\n        vector<int> v;\n        combinationSum2Helper(candidates, target, ans, v, 0);\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "combination-sum-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 960220818,
            "question_id": 39,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months",
            "timestamp": 1685448371,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/960220818/",
            "is_pending": "Not Pending",
            "title": "Combination Sum",
            "memory": "10.7 MB",
            "code": "class Solution {\npublic:\n    void combinationSumHelper(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& v, int index) {\n        if(target == 0) {\n            ans.push_back(v);\n            return;\n        }\n        if(target < 0) {\n            return;\n        }\n        for(int i=index; i<candidates.size(); i++) {\n            v.push_back(candidates[i]);\n            combinationSumHelper(candidates, target-candidates[i], ans, v, i);\n            v.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> ans;\n        vector<int> v;\n        combinationSumHelper(candidates, target, ans, v, 0);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "combination-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 949219775,
            "question_id": 113,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 2 weeks",
            "timestamp": 1683922159,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "21 ms",
            "url": "/submissions/detail/949219775/",
            "is_pending": "Not Pending",
            "title": "Path Sum II",
            "memory": "19.8 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void solve(TreeNode *root, int targetSum, int &currSum, vector<int> &path, vector<vector<int>> &v)\n    {\n        if(root == NULL) return;\n        if(root->left == NULL && root->right == NULL) {\n            path.push_back(root->val);\n            currSum += root->val;\n            if(currSum == targetSum) v.push_back(path);\n            path.pop_back();\n            currSum -= root->val;\n            return;\n        }\n        \n        path.push_back(root->val);\n        currSum += root->val;\n        solve(root->left, targetSum, currSum, path, v);\n        solve(root->right, targetSum, currSum, path, v);\n        path.pop_back();\n        currSum -= root->val;\n    }\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        vector<vector<int>> v;\n        vector<int> path;\n        int currSum = 0;\n        solve(root, targetSum, currSum, path, v);\n        return v;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "path-sum-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 948175793,
            "question_id": 236,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 2 weeks",
            "timestamp": 1683774633,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/948175793/",
            "is_pending": "Not Pending",
            "title": "Lowest Common Ancestor of a Binary Tree",
            "memory": "14.1 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL) return NULL;\n        \n        // Check for p and q\n        if(root->val == p->val) return p;\n        if(root->val == q->val) return q;\n        \n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\n        \n        if(leftAns != NULL && rightAns == NULL) return leftAns;\n        else if(leftAns == NULL && rightAns != NULL) return rightAns;\n        else if(leftAns == NULL && rightAns == NULL) return NULL;\n        else return root;\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "lowest-common-ancestor-of-a-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 948175665,
            "question_id": 236,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 2 weeks",
            "timestamp": 1683774614,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "20 ms",
            "url": "/submissions/detail/948175665/",
            "is_pending": "Not Pending",
            "title": "Lowest Common Ancestor of a Binary Tree",
            "memory": "14.1 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL) return NULL;\n        \n        // Check for p and q\n        if(root->val == p->val) return p;\n        if(root->val == q->val) return q;\n        \n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\n        \n        if(leftAns != NULL && rightAns == NULL) return leftAns;\n        else if(leftAns == NULL && rightAns != NULL) return rightAns;\n        else if(leftAns == NULL && rightAns == NULL) return NULL;\n        else return root;\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "lowest-common-ancestor-of-a-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 948175580,
            "question_id": 236,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 2 weeks",
            "timestamp": 1683774599,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/948175580/",
            "is_pending": "Not Pending",
            "title": "Lowest Common Ancestor of a Binary Tree",
            "memory": "14.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL) return NULL;\n        \n        // Check for p and q\n        if(root->val == p->val) return p;\n        if(root->val == q->val) return q;\n        \n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\n        \n        if(leftAns != NULL && rightAns == NULL) return leftAns;\n        else if(leftAns == NULL && rightAns != NULL) return rightAns;\n        else if(leftAns == NULL && rightAns == NULL) return NULL;\n        else return root;\n    }\n};",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "lowest-common-ancestor-of-a-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947448411,
            "question_id": 110,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683661823,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "125 ms",
            "url": "/submissions/detail/947448411/",
            "is_pending": "Not Pending",
            "title": "Balanced Binary Tree",
            "memory": "21 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        return max(leftHeight,rightHeight)+1;\n    }\n    bool isBalanced(TreeNode* root) {\n        if(root == NULL) return true;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        bool ans1 = abs(rightHeight-leftHeight) <= 1;\n        \n        bool leftAns = isBalanced(root->left);\n        bool rightAns = isBalanced(root->right);\n        return (ans1 && leftAns && rightAns);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "balanced-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947448299,
            "question_id": 110,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683661811,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "117 ms",
            "url": "/submissions/detail/947448299/",
            "is_pending": "Not Pending",
            "title": "Balanced Binary Tree",
            "memory": "21 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        return max(leftHeight,rightHeight)+1;\n    }\n    bool isBalanced(TreeNode* root) {\n        if(root == NULL) return true;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        bool ans1 = abs(rightHeight-leftHeight) <= 1;\n        \n        bool leftAns = isBalanced(root->left);\n        bool rightAns = isBalanced(root->right);\n        return (ans1 && leftAns && rightAns);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "balanced-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947447678,
            "question_id": 110,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683661722,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/947447678/",
            "is_pending": "Not Pending",
            "title": "Balanced Binary Tree",
            "memory": "N/A",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        return max(leftHeight,rightHeight)+1;\n    }\n    bool isBalanced(TreeNode* root) {\n        if(root == NULL) return true;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        bool ans1 = abs(rightHeight-leftHeight) <= 1;\n        \n        int leftAns = isBalanced(root->left);\n        int rightAns = isBalanced(root->right);\n        bool ans2 = abs(leftAns-rightAns) <= 1;\n        return (ans1 && ans2);\n    }\n};",
            "compare_result": "111111111111011011110011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110010000100000011000011111111111111111111111111111111111111111111111111111111111111111000001111",
            "title_slug": "balanced-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947447449,
            "question_id": 110,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683661690,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/947447449/",
            "is_pending": "Not Pending",
            "title": "Balanced Binary Tree",
            "memory": "N/A",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        return max(leftHeight,rightHeight)+1;\n    }\n    bool isBalanced(TreeNode* root) {\n        if(root == NULL) return false;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        bool ans1 = abs(rightHeight-leftHeight) <= 1;\n        \n        int leftAns = isBalanced(root->left);\n        int rightAns = isBalanced(root->right);\n        bool ans2 = abs(leftAns-rightAns) <= 1;\n        return (ans1 && ans2);\n    }\n};",
            "compare_result": "110111111111011011110011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110010000100000011000011111111111111111111111111111111111111111111111111111111111111111000001111",
            "title_slug": "balanced-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947443254,
            "question_id": 110,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683661132,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/947443254/",
            "is_pending": "Not Pending",
            "title": "Balanced Binary Tree",
            "memory": "N/A",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        return max(leftHeight,rightHeight)+1;\n    }\n    bool isBalanced(TreeNode* root) {\n        if(root == NULL) return false;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        if(rightHeight-leftHeight <= 1) return true;\n        return false;\n    }\n};",
            "compare_result": "100111111100011011010011111111100000111111111111111111111110010000000000000000111111111111111111111111111111111111111111111111111111110010000100000011000000000000000000000000000000000000000000000000000000000000111111111000001000",
            "title_slug": "balanced-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947427397,
            "question_id": 543,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683659077,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "25 ms",
            "url": "/submissions/detail/947427397/",
            "is_pending": "Not Pending",
            "title": "Diameter of Binary Tree",
            "memory": "20.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left,right)+1;\n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        if(root == NULL) return 0;\n        int op1 = diameterOfBinaryTree(root->left);\n        int op2 = diameterOfBinaryTree(root->right);\n        int op3 = maxDepth(root->left) + maxDepth(root->right);\n        return max(op1,max(op2,op3));\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "diameter-of-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947427330,
            "question_id": 543,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683659069,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "37 ms",
            "url": "/submissions/detail/947427330/",
            "is_pending": "Not Pending",
            "title": "Diameter of Binary Tree",
            "memory": "20.2 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left,right)+1;\n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        if(root == NULL) return 0;\n        int op1 = diameterOfBinaryTree(root->left);\n        int op2 = diameterOfBinaryTree(root->right);\n        int op3 = maxDepth(root->left) + maxDepth(root->right);\n        return max(op1,max(op2,op3));\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "diameter-of-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947416540,
            "question_id": 104,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683657825,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/947416540/",
            "is_pending": "Not Pending",
            "title": "Maximum Depth of Binary Tree",
            "memory": "18.7 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        return max(leftHeight, rightHeight) + 1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "maximum-depth-of-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 947416447,
            "question_id": 104,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683657816,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "13 ms",
            "url": "/submissions/detail/947416447/",
            "is_pending": "Not Pending",
            "title": "Maximum Depth of Binary Tree",
            "memory": "18.8 MB",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        int leftHeight = maxDepth(root->left);\n        int rightHeight = maxDepth(root->right);\n        return max(leftHeight, rightHeight) + 1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "maximum-depth-of-binary-tree",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945454952,
            "question_id": 53,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683373283,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "161 ms",
            "url": "/submissions/detail/945454952/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "67.7 MB",
            "code": "class Solution {\npublic:\n    // TC - O(n)\n    // int maxSubArray(vector<int>& nums) {\n    //     int maxsum = nums[0];\n    //     int sum = 0;\n    //     for(int i=0; i<nums.size(); i++) {\n    //         sum += nums[i];\n    //         if(sum > maxsum) {\n    //             maxsum = sum;\n    //         }\n    //         if(sum < 0) {\n    //             sum = 0;\n    //         }\n    //     }\n    //     return maxsum;\n    // }\n    \n    // Divide and Conquer Approach\n    int maxSumSubArrayHelper(vector<int>& nums, int start, int end) {\n        if(start == end) return nums[start];\n        int mid = start + ((end-start) >> 1);\n        int maxLeftSum = maxSumSubArrayHelper(nums, start, mid);\n        int maxRightSum = maxSumSubArrayHelper(nums, mid+1, end);\n        \n        int maxLeftBorderSum = INT_MIN, maxRightBorderSum = INT_MIN;\n        int leftBorderSum = 0, rightBorderSum = 0;\n        for(int i=mid; i>=start; i--) {\n            leftBorderSum += nums[i];\n            if(leftBorderSum > maxLeftBorderSum) maxLeftBorderSum = leftBorderSum;\n        }\n        for(int i=mid+1; i<=end; i++) {\n            rightBorderSum += nums[i];\n            if(rightBorderSum > maxRightBorderSum) maxRightBorderSum = rightBorderSum;\n        }\n        int crossBorderSum = maxLeftBorderSum + maxRightBorderSum;\n        return max(maxLeftSum, max(crossBorderSum, maxRightSum));\n    }\n    int maxSubArray(vector<int>& nums) {\n        return maxSumSubArrayHelper(nums, 0, nums.size()-1);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945445222,
            "question_id": 53,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683371647,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "176 ms",
            "url": "/submissions/detail/945445222/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "67.6 MB",
            "code": "class Solution {\npublic:\n    // TC - O(n)\n    // int maxSubArray(vector<int>& nums) {\n    //     int maxsum = nums[0];\n    //     int sum = 0;\n    //     for(int i=0; i<nums.size(); i++) {\n    //         sum += nums[i];\n    //         if(sum > maxsum) {\n    //             maxsum = sum;\n    //         }\n    //         if(sum < 0) {\n    //             sum = 0;\n    //         }\n    //     }\n    //     return maxsum;\n    // }\n    \n    // Divide and Conquer Approach\n    int maxSumSubArrayHelper(vector<int>& nums, int start, int end) {\n        if(start == end) return nums[start];\n        int maxLeftBorderSum = INT_MIN, maxRightBorderSum = INT_MIN;\n        int mid = start + ((end-start) >> 1);\n        \n        int maxLeftSum = maxSumSubArrayHelper(nums, start, mid);\n        int maxRightSum = maxSumSubArrayHelper(nums, mid+1, end);\n        \n        int leftBorderSum = 0, rightBorderSum = 0;\n        for(int i=mid; i>=start; i--) {\n            leftBorderSum += nums[i];\n            if(leftBorderSum > maxLeftBorderSum) maxLeftBorderSum = leftBorderSum;\n        }\n        for(int i=mid+1; i<=end; i++) {\n            rightBorderSum += nums[i];\n            if(rightBorderSum > maxRightBorderSum) maxRightBorderSum = rightBorderSum;\n        }\n        int crossBorderSum = maxLeftBorderSum + maxRightBorderSum;\n        return max(maxLeftSum,max(crossBorderSum, maxRightSum));\n    }\n    int maxSubArray(vector<int>& nums) {\n        return maxSumSubArrayHelper(nums, 0, nums.size()-1);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945445127,
            "question_id": 53,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683371630,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "183 ms",
            "url": "/submissions/detail/945445127/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "67.7 MB",
            "code": "class Solution {\npublic:\n    // TC - O(n)\n    // int maxSubArray(vector<int>& nums) {\n    //     int maxsum = nums[0];\n    //     int sum = 0;\n    //     for(int i=0; i<nums.size(); i++) {\n    //         sum += nums[i];\n    //         if(sum > maxsum) {\n    //             maxsum = sum;\n    //         }\n    //         if(sum < 0) {\n    //             sum = 0;\n    //         }\n    //     }\n    //     return maxsum;\n    // }\n    \n    // Divide and Conquer Approach\n    int maxSumSubArrayHelper(vector<int>& nums, int start, int end) {\n        if(start == end) return nums[start];\n        int maxLeftBorderSum = INT_MIN, maxRightBorderSum = INT_MIN;\n        int mid = start + ((end-start) >> 1);\n        \n        int maxLeftSum = maxSumSubArrayHelper(nums, start, mid);\n        int maxRightSum = maxSumSubArrayHelper(nums, mid+1, end);\n        \n        int leftBorderSum = 0, rightBorderSum = 0;\n        for(int i=mid; i>=start; i--) {\n            leftBorderSum += nums[i];\n            if(leftBorderSum > maxLeftBorderSum) maxLeftBorderSum = leftBorderSum;\n        }\n        for(int i=mid+1; i<=end; i++) {\n            rightBorderSum += nums[i];\n            if(rightBorderSum > maxRightBorderSum) maxRightBorderSum = rightBorderSum;\n        }\n        int crossBorderSum = maxLeftBorderSum + maxRightBorderSum;\n        return max(maxLeftSum,max(crossBorderSum, maxRightSum));\n    }\n    int maxSubArray(vector<int>& nums) {\n        return maxSumSubArrayHelper(nums, 0, nums.size()-1);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945311320,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "11 months, 3 weeks",
            "timestamp": 1683351221,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/945311320/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "51.9 MB",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            if(sum > maxsum) {\n                maxsum = sum;\n            }\n            if(sum < 0) {\n                sum = 0;\n            }\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945311067,
            "question_id": 53,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683351181,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "122 ms",
            "url": "/submissions/detail/945311067/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "67.7 MB",
            "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.size(); i++) {\n            sum += nums[i];\n            if(sum > maxsum) {\n                maxsum = sum;\n            }\n            if(sum < 0) {\n                sum = 0;\n            }\n        }\n        return maxsum;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945311007,
            "question_id": 53,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683351172,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "117 ms",
            "url": "/submissions/detail/945311007/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "67.7 MB",
            "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.size(); i++) {\n            sum += nums[i];\n            if(sum > maxsum) {\n                maxsum = sum;\n            }\n            if(sum < 0) {\n                sum = 0;\n            }\n        }\n        return maxsum;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945310895,
            "question_id": 53,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683351155,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/945310895/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=1; i<nums.size(); i++) {\n            sum += nums[i];\n            if(sum > maxsum) {\n                maxsum = sum;\n            }\n            if(sum < 0) {\n                sum = 0;\n            }\n        }\n        return maxsum;\n    }\n};",
            "compare_result": "110111111011111110101100111110111111111111111111111101110101011011011111111101111101101111111011101110110110110111011111011111111110111101111101011011010110110110110111111110011111111111100111111011111111111010",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945264309,
            "question_id": 948,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683342785,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "525 ms",
            "url": "/submissions/detail/945264309/",
            "is_pending": "Not Pending",
            "title": "Sort an Array",
            "memory": "66.6 MB",
            "code": "class Solution {\npublic:\n    // void merge(vector<int> &v, vector<int> &temp, int start, int mid, int end) {\n    //     int i = start, j = mid+1, k = start;\n    //     while(i <= mid && j<=end) {\n    //         if(v[i] <= v[j]) {\n    //             temp[k++] = v[i++];\n    //         }\n    //         else {\n    //             temp[k++] = v[j++];\n    //         }\n    //     }\n    //     while(i<=mid) {\n    //         temp[k++] = v[i++];\n    //     }\n    //     while(j<=end) {\n    //         temp[k++] = v[j++];\n    //     }\n    //     while(start<=end) {\n    //         v[start] = temp[start];\n    //         start++;\n    //     }\n    // }\n    \n    // void mergeSort(vector<int> &v, vector<int> &temp, int start, int end) {\n    //     if(start>=end) return;\n    //     int mid = start + (end-start) / 2;\n    //     mergeSort(v, temp, start, mid);\n    //     mergeSort(v, temp, mid+1, end);\n    //     merge(v, temp, start, mid, end);\n    // }\n    \n    // vector<int> sortArray(vector<int>& nums) {\n    //     vector<int> temp(nums.size(), 0);\n    //     mergeSort(nums, temp, 0, nums.size()-1);\n    //     return nums;\n    // }\n    \n    \n    \n    \n    // Inplace merge sort using gap method\n    void merge(vector<int> &v, int start, int mid, int end) {\n        int total_len = end-start+1;\n        int gap = (total_len/2)+(total_len%2);\n        while(gap>0) {\n            int i = start, j = start+gap;\n            while(j<=end) {\n                if(v[i]>v[j]) {\n                    swap(v[i],v[j]);\n                }\n                i++, j++;\n            }\n            gap = gap <= 1 ? 0 : (gap/2)+(gap%2);\n        }\n    }\n    \n    void mergeSort(vector<int> &v, int start, int end) {\n        if(start>=end) return;\n        int mid = start + (end-start) / 2;\n        mergeSort(v, start, mid);\n        mergeSort(v, mid+1, end);\n        merge(v, start, mid, end);\n    }\n    \n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};",
            "compare_result": "11111111111111111111",
            "title_slug": "sort-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 945264266,
            "question_id": 948,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683342776,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "510 ms",
            "url": "/submissions/detail/945264266/",
            "is_pending": "Not Pending",
            "title": "Sort an Array",
            "memory": "66.6 MB",
            "code": "class Solution {\npublic:\n    // void merge(vector<int> &v, vector<int> &temp, int start, int mid, int end) {\n    //     int i = start, j = mid+1, k = start;\n    //     while(i <= mid && j<=end) {\n    //         if(v[i] <= v[j]) {\n    //             temp[k++] = v[i++];\n    //         }\n    //         else {\n    //             temp[k++] = v[j++];\n    //         }\n    //     }\n    //     while(i<=mid) {\n    //         temp[k++] = v[i++];\n    //     }\n    //     while(j<=end) {\n    //         temp[k++] = v[j++];\n    //     }\n    //     while(start<=end) {\n    //         v[start] = temp[start];\n    //         start++;\n    //     }\n    // }\n    \n    // void mergeSort(vector<int> &v, vector<int> &temp, int start, int end) {\n    //     if(start>=end) return;\n    //     int mid = start + (end-start) / 2;\n    //     mergeSort(v, temp, start, mid);\n    //     mergeSort(v, temp, mid+1, end);\n    //     merge(v, temp, start, mid, end);\n    // }\n    \n    // vector<int> sortArray(vector<int>& nums) {\n    //     vector<int> temp(nums.size(), 0);\n    //     mergeSort(nums, temp, 0, nums.size()-1);\n    //     return nums;\n    // }\n    \n    \n    \n    \n    // Inplace merge sort using gap method\n    void merge(vector<int> &v, int start, int mid, int end) {\n        int total_len = end-start+1;\n        int gap = (total_len/2)+(total_len%2);\n        while(gap>0) {\n            int i = start, j = start+gap;\n            while(j<=end) {\n                if(v[i]>v[j]) {\n                    swap(v[i],v[j]);\n                }\n                i++, j++;\n            }\n            gap = gap <= 1 ? 0 : (gap/2)+(gap%2);\n        }\n    }\n    \n    void mergeSort(vector<int> &v, int start, int end) {\n        if(start>=end) return;\n        int mid = start + (end-start) / 2;\n        mergeSort(v, start, mid);\n        mergeSort(v, mid+1, end);\n        merge(v, start, mid, end);\n    }\n    \n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};",
            "compare_result": "11111111111111111111",
            "title_slug": "sort-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124617,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683169034,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "300 ms",
            "url": "/submissions/detail/944124617/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.5 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124542,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683169021,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "317 ms",
            "url": "/submissions/detail/944124542/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.8 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124416,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683168999,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "308 ms",
            "url": "/submissions/detail/944124416/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.6 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124315,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683168984,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "322 ms",
            "url": "/submissions/detail/944124315/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.8 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124274,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683168976,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "322 ms",
            "url": "/submissions/detail/944124274/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.6 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124157,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683168958,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "311 ms",
            "url": "/submissions/detail/944124157/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.8 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124093,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683168946,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "311 ms",
            "url": "/submissions/detail/944124093/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.6 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944124015,
            "question_id": 239,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683168932,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "302 ms",
            "url": "/submissions/detail/944124015/",
            "is_pending": "Not Pending",
            "title": "Sliding Window Maximum",
            "memory": "134.5 MB",
            "code": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> dq;\n        vector<int> ans;\n        for(int i=0; i<k; i++) {\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n        }\n        ans.push_back(nums[dq.front()]);\n        for(int i=k; i<nums.size(); i++) {\n            // Remove out of window elements from deque\n            if(!dq.empty() && i-dq.front() >= k) {\n                dq.pop_front();\n            }\n            // Remove small elements that current element from deque\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            // Inserting index, so that we can check window out of element\n            dq.push_back(i);\n            ans.push_back(nums[dq.front()]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111",
            "title_slug": "sliding-window-maximum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944109298,
            "question_id": 134,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683166130,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "131 ms",
            "url": "/submissions/detail/944109298/",
            "is_pending": "Not Pending",
            "title": "Gas Station",
            "memory": "108.6 MB",
            "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int deficit = 0;\n        int balance = 0;\n        int start = 0;\n        \n        for(int i=0; i<gas.size(); i++) {\n            balance += gas[i]-cost[i];\n            if(balance < 0) {\n                deficit += abs(balance);\n                start = i+1;\n                balance = 0;\n            }\n        }\n        if(balance >= deficit) {\n            return start;\n        }\n        return -1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "gas-station",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944109252,
            "question_id": 134,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683166119,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "140 ms",
            "url": "/submissions/detail/944109252/",
            "is_pending": "Not Pending",
            "title": "Gas Station",
            "memory": "108.4 MB",
            "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int deficit = 0;\n        int balance = 0;\n        int start = 0;\n        \n        for(int i=0; i<gas.size(); i++) {\n            balance += gas[i]-cost[i];\n            if(balance < 0) {\n                deficit += abs(balance);\n                start = i+1;\n                balance = 0;\n            }\n        }\n        if(balance >= deficit) {\n            return start;\n        }\n        return -1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "gas-station",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944109210,
            "question_id": 134,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683166109,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "143 ms",
            "url": "/submissions/detail/944109210/",
            "is_pending": "Not Pending",
            "title": "Gas Station",
            "memory": "108.5 MB",
            "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int deficit = 0;\n        int balance = 0;\n        int start = 0;\n        \n        for(int i=0; i<gas.size(); i++) {\n            balance += gas[i]-cost[i];\n            if(balance < 0) {\n                deficit += abs(balance);\n                start = i+1;\n                balance = 0;\n            }\n        }\n        if(balance >= deficit) {\n            return start;\n        }\n        return -1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "gas-station",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944108676,
            "question_id": 134,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683165997,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "135 ms",
            "url": "/submissions/detail/944108676/",
            "is_pending": "Not Pending",
            "title": "Gas Station",
            "memory": "108.5 MB",
            "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int deficit = 0;\n        int balance = 0;\n        int start = 0;\n        \n        for(int i=0; i<gas.size(); i++) {\n            balance += gas[i]-cost[i];\n            if(balance < 0) {\n                deficit += balance;\n                start = i+1;\n                balance = 0;\n            }\n        }\n        if(deficit + balance >= 0) {\n            return start;\n        }\n        return -1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "gas-station",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 944108610,
            "question_id": 134,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 3 weeks",
            "timestamp": 1683165986,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "163 ms",
            "url": "/submissions/detail/944108610/",
            "is_pending": "Not Pending",
            "title": "Gas Station",
            "memory": "108.5 MB",
            "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int deficit = 0;\n        int balance = 0;\n        int start = 0;\n        \n        for(int i=0; i<gas.size(); i++) {\n            balance += gas[i]-cost[i];\n            if(balance < 0) {\n                deficit += balance;\n                start = i+1;\n                balance = 0;\n            }\n        }\n        if(deficit + balance >= 0) {\n            return start;\n        }\n        return -1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111",
            "title_slug": "gas-station",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 942606328,
            "question_id": 948,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "11 months, 4 weeks",
            "timestamp": 1682943726,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "320 ms",
            "url": "/submissions/detail/942606328/",
            "is_pending": "Not Pending",
            "title": "Sort an Array",
            "memory": "68.7 MB",
            "code": "class Solution {\npublic:\n    void merge(vector<int> &v, vector<int> &temp, int start, int mid, int end) {\n        int i = start, j = mid+1, k = start;\n        while(i <= mid && j<=end) {\n            if(v[i] <= v[j]) {\n                temp[k++] = v[i++];\n            }\n            else {\n                temp[k++] = v[j++];\n            }\n        }\n        while(i<=mid) {\n            temp[k++] = v[i++];\n        }\n        while(j<=end) {\n            temp[k++] = v[j++];\n        }\n        while(start<=end) {\n            v[start] = temp[start];\n            start++;\n        }\n    }\n    void mergeSort(vector<int> &v, vector<int> &temp, int start, int end) {\n        if(start>=end) return;\n        int mid = start + (end-start) / 2;\n        mergeSort(v, temp, start, mid);\n        mergeSort(v, temp, mid+1, end);\n        merge(v, temp, start, mid, end);\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        vector<int> temp(nums.size(), 0);\n        mergeSort(nums, temp, 0, nums.size()-1);\n        return nums;\n    }\n};",
            "compare_result": "11111111111111111111",
            "title_slug": "sort-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941770363,
            "question_id": 84,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682801199,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "236 ms",
            "url": "/submissions/detail/941770363/",
            "is_pending": "Not Pending",
            "title": "Largest Rectangle in Histogram",
            "memory": "81.4 MB",
            "code": "class Solution {\npublic:\n    vector<int> prevSmallerElement(vector<int> &input) {\n        stack<int> s;\n        s.push(-1);\n        vector<int> ans(input.size());\n\n        for(int i=0; i<input.size(); i++) {\n            int curr = input[i];\n            while(s.top() != -1 && input[s.top()] >= curr) {\n                s.pop();\n            }\n            ans[i] = s.top();\n            s.push(i);\n        }\n        return ans;\n    }\n    vector<int> nextSmallerElement(vector<int> &input) {\n        stack<int> s;\n        s.push(-1);\n        vector<int> ans(input.size());\n\n        for(int i=input.size()-1; i>=0; i--) {\n            int curr = input[i];\n            while(s.top() != -1 && input[s.top()] >= curr) {\n                s.pop();\n            }\n            ans[i] = s.top();\n            s.push(i);\n        }\n        return ans;\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        vector<int> prev = prevSmallerElement(heights);\n        vector<int> next = nextSmallerElement(heights);\n        int maxArea = INT_MIN;\n        for(int i=0; i<heights.size(); i++) {\n            int height = heights[i];\n            if(next[i] == -1) {\n                next[i] = heights.size();\n            }\n            int width = next[i] - prev[i] - 1;\n            maxArea = max(height*width, maxArea);\n        }\n        return maxArea;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "largest-rectangle-in-histogram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941770311,
            "question_id": 84,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682801188,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "259 ms",
            "url": "/submissions/detail/941770311/",
            "is_pending": "Not Pending",
            "title": "Largest Rectangle in Histogram",
            "memory": "81.4 MB",
            "code": "class Solution {\npublic:\n    vector<int> prevSmallerElement(vector<int> &input) {\n        stack<int> s;\n        s.push(-1);\n        vector<int> ans(input.size());\n\n        for(int i=0; i<input.size(); i++) {\n            int curr = input[i];\n            while(s.top() != -1 && input[s.top()] >= curr) {\n                s.pop();\n            }\n            ans[i] = s.top();\n            s.push(i);\n        }\n        return ans;\n    }\n    vector<int> nextSmallerElement(vector<int> &input) {\n        stack<int> s;\n        s.push(-1);\n        vector<int> ans(input.size());\n\n        for(int i=input.size()-1; i>=0; i--) {\n            int curr = input[i];\n            while(s.top() != -1 && input[s.top()] >= curr) {\n                s.pop();\n            }\n            ans[i] = s.top();\n            s.push(i);\n        }\n        return ans;\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        vector<int> prev = prevSmallerElement(heights);\n        vector<int> next = nextSmallerElement(heights);\n        int maxArea = INT_MIN;\n        for(int i=0; i<heights.size(); i++) {\n            int height = heights[i];\n            if(next[i] == -1) {\n                next[i] = heights.size();\n            }\n            int width = next[i] - prev[i] - 1;\n            maxArea = max(height*width, maxArea);\n        }\n        return maxArea;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "largest-rectangle-in-histogram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941608813,
            "question_id": 32,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682780612,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/941608813/",
            "is_pending": "Not Pending",
            "title": "Longest Valid Parentheses",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> st;\n        st.push(-1);\n        int maxLen = 0;\n        for(int i=0; i<s.length(); i++) {\n            char ch = s[i];\n            if(ch == '(') {\n                st.push(i);\n            } else {\n                st.pop();\n                if(st.empty()) {\n                    st.push(i);\n                } else {\n                    int len = i - st.top();\n                    maxLen = max(len, maxLen);\n                }\n            }\n        }\n        return maxLen;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941608710,
            "question_id": 32,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682780603,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/941608710/",
            "is_pending": "Not Pending",
            "title": "Longest Valid Parentheses",
            "memory": "7.3 MB",
            "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> st;\n        st.push(-1);\n        int maxLen = 0;\n        for(int i=0; i<s.length(); i++) {\n            char ch = s[i];\n            if(ch == '(') {\n                st.push(i);\n            } else {\n                st.pop();\n                if(st.empty()) {\n                    st.push(i);\n                } else {\n                    int len = i - st.top();\n                    maxLen = max(len, maxLen);\n                }\n            }\n        }\n        return maxLen;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941608496,
            "question_id": 32,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682780589,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/941608496/",
            "is_pending": "Not Pending",
            "title": "Longest Valid Parentheses",
            "memory": "7.3 MB",
            "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> st;\n        st.push(-1);\n        int maxLen = 0;\n        for(int i=0; i<s.length(); i++) {\n            char ch = s[i];\n            if(ch == '(') {\n                st.push(i);\n            } else {\n                st.pop();\n                if(st.empty()) {\n                    st.push(i);\n                } else {\n                    int len = i - st.top();\n                    maxLen = max(len, maxLen);\n                }\n            }\n        }\n        return maxLen;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941608350,
            "question_id": 32,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682780579,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/941608350/",
            "is_pending": "Not Pending",
            "title": "Longest Valid Parentheses",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int> st;\n        st.push(-1);\n        int maxLen = 0;\n        for(int i=0; i<s.length(); i++) {\n            char ch = s[i];\n            if(ch == '(') {\n                st.push(i);\n            } else {\n                st.pop();\n                if(st.empty()) {\n                    st.push(i);\n                } else {\n                    int len = i - st.top();\n                    maxLen = max(len, maxLen);\n                }\n            }\n        }\n        return maxLen;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941584650,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779204,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "21 ms",
            "url": "/submissions/detail/941584650/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.2 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941584462,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779195,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "29 ms",
            "url": "/submissions/detail/941584462/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.3 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941583636,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779157,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "26 ms",
            "url": "/submissions/detail/941583636/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.3 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941583377,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779146,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "21 ms",
            "url": "/submissions/detail/941583377/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.3 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941582988,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779128,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "22 ms",
            "url": "/submissions/detail/941582988/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.3 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941582759,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779119,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "25 ms",
            "url": "/submissions/detail/941582759/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.4 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941582357,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779100,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "25 ms",
            "url": "/submissions/detail/941582357/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.2 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941582138,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779090,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "33 ms",
            "url": "/submissions/detail/941582138/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.3 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 941581925,
            "question_id": 155,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682779080,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "18 ms",
            "url": "/submissions/detail/941581925/",
            "is_pending": "Not Pending",
            "title": "Min Stack",
            "memory": "16.2 MB",
            "code": "class MinStack {\npublic:\n    vector<pair<int,int>> st;\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        if(st.empty()) {\n            pair<int,int> p = make_pair(val,val);\n            st.push_back(p);\n        } else {\n            pair<int,int> p;\n            p.first = val;\n            p.second = min(val, st.back().second);\n            st.push_back(p);\n        }\n    }\n    \n    void pop() {\n        st.pop_back();\n    }\n    \n    int top() {\n        return st.back().first;\n    }\n    \n    int getMin() {\n        return st.back().second;\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "min-stack",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 940460807,
            "question_id": 20,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682578217,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/940460807/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "6.2 MB",
            "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for(int i=0; i<s.length(); i++) {\n            char ch = s[i];\n            char sTop;\n            if (!st.empty())\n                sTop = (char)st.top();\n            else\n                sTop = '-';\n            if(ch == '(' || ch == '{' || ch == '[')\n                st.push(ch);\n            else {\n                if(ch == ')' && sTop == '(') {\n                    st.pop();\n                } else if(ch == '}' && sTop == '{') {\n                    st.pop();\n                } else if(ch == ']' && sTop == '[') {\n                    st.pop();\n                } else {\n                    return false;\n                }\n            }\n        }\n        return st.empty();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 940374126,
            "question_id": 20,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682564581,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/940374126/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        if(s[0] == ')' || s[0] == '}' || s[0] == ']') {\n            return false;\n        }\n        stack<char> st;\n        for(int i=0; i<s.length(); i++) {\n            if(s[i] == '(' || s[i] == '{' || s[i] == '[')\n                st.push(s[i]);\n            else {\n                if(s[i] == ')' && st.top() == '(') {\n                    st.pop();\n                } else if(s[i] == '}' && st.top() == '{') {\n                    st.pop();\n                } else if(s[i] == ']' && st.top() == '[') {\n                    st.pop();\n                } else {\n                    return false;\n                }\n            }\n        }\n        if(st.empty()) return true;\n        return false;\n    }\n};",
            "compare_result": "111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 940372421,
            "question_id": 20,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682564277,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/940372421/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for(int i=0; i<s.length(); i++) {\n            if(s[i] == '(' || s[i] == '{' || s[i] == '[')\n                st.push(s[i]);\n            else {\n                if(s[i] == ')' && st.top() == '(') {\n                    st.pop();\n                } else if(s[i] == '}' && st.top() == '{') {\n                    st.pop();\n                } else if(s[i] == ']' && st.top() == '[') {\n                    st.pop();\n                }\n            }\n        }\n        if(st.empty()) return true;\n        return false;\n    }\n};",
            "compare_result": "111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 940369910,
            "question_id": 20,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "12 months",
            "timestamp": 1682563809,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/940369910/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for(int i=0; i<s.length(); i++) {\n            if(s[i] == '(' || s[i] == '{' || s[i] == '[')\n                st.push(s[i]);\n            else\n                st.pop();\n        }\n        if(st.empty()) return true;\n        return false;\n    }\n};",
            "compare_result": "110011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 935151342,
            "question_id": 37,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681724623,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "34 ms",
            "url": "/submissions/detail/935151342/",
            "is_pending": "Not Pending",
            "title": "Sudoku Solver",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    bool isSafeToInsert(char value, vector<vector<char>> &board, int curr_row, int curr_col)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            // For rows\n            if(board[curr_row][i] == value) return false;\n            \n            // For columns\n            if(board[i][curr_col] == value) return false;\n            \n            // 3 x 3 box\n            if(board[3 * (curr_row/3) + (i/3)][3 * (curr_col/3) + (i%3)] == value) return false;\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>> &board)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(board[i][j] == '.') {\n                    for(char value = '1'; value <= '9'; value++) {\n                        if(isSafeToInsert(value, board, i, j)) {\n                            board[i][j] = value;\n                            bool remainingSoln = solve(board);\n                            if(remainingSoln) {\n                                return true;\n                            } else {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
            "compare_result": "111111",
            "title_slug": "sudoku-solver",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 935151287,
            "question_id": 37,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681724602,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "34 ms",
            "url": "/submissions/detail/935151287/",
            "is_pending": "Not Pending",
            "title": "Sudoku Solver",
            "memory": "6.5 MB",
            "code": "class Solution {\npublic:\n    bool isSafeToInsert(char value, vector<vector<char>> &board, int curr_row, int curr_col)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            // For rows\n            if(board[curr_row][i] == value) return false;\n            \n            // For columns\n            if(board[i][curr_col] == value) return false;\n            \n            // 3 x 3 box\n            if(board[3 * (curr_row/3) + (i/3)][3 * (curr_col/3) + (i%3)] == value) return false;\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>> &board)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(board[i][j] == '.') {\n                    for(char value = '1'; value <= '9'; value++) {\n                        if(isSafeToInsert(value, board, i, j)) {\n                            board[i][j] = value;\n                            bool remainingSoln = solve(board);\n                            if(remainingSoln) {\n                                return true;\n                            } else {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
            "compare_result": "111111",
            "title_slug": "sudoku-solver",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 935151255,
            "question_id": 37,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681724586,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "34 ms",
            "url": "/submissions/detail/935151255/",
            "is_pending": "Not Pending",
            "title": "Sudoku Solver",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    bool isSafeToInsert(char value, vector<vector<char>> &board, int curr_row, int curr_col)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            // For rows\n            if(board[curr_row][i] == value) return false;\n            \n            // For columns\n            if(board[i][curr_col] == value) return false;\n            \n            // 3 x 3 box\n            if(board[3 * (curr_row/3) + (i/3)][3 * (curr_col/3) + (i%3)] == value) return false;\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>> &board)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(board[i][j] == '.') {\n                    for(char value = '1'; value <= '9'; value++) {\n                        if(isSafeToInsert(value, board, i, j)) {\n                            board[i][j] = value;\n                            bool remainingSoln = solve(board);\n                            if(remainingSoln) {\n                                return true;\n                            } else {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
            "compare_result": "111111",
            "title_slug": "sudoku-solver",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 935151226,
            "question_id": 37,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681724576,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "34 ms",
            "url": "/submissions/detail/935151226/",
            "is_pending": "Not Pending",
            "title": "Sudoku Solver",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    bool isSafeToInsert(char value, vector<vector<char>> &board, int curr_row, int curr_col)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            // For rows\n            if(board[curr_row][i] == value) return false;\n            \n            // For columns\n            if(board[i][curr_col] == value) return false;\n            \n            // 3 x 3 box\n            if(board[3 * (curr_row/3) + (i/3)][3 * (curr_col/3) + (i%3)] == value) return false;\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>> &board)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(board[i][j] == '.') {\n                    for(char value = '1'; value <= '9'; value++) {\n                        if(isSafeToInsert(value, board, i, j)) {\n                            board[i][j] = value;\n                            bool remainingSoln = solve(board);\n                            if(remainingSoln) {\n                                return true;\n                            } else {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
            "compare_result": "111111",
            "title_slug": "sudoku-solver",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 935151205,
            "question_id": 37,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681724566,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "34 ms",
            "url": "/submissions/detail/935151205/",
            "is_pending": "Not Pending",
            "title": "Sudoku Solver",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    bool isSafeToInsert(char value, vector<vector<char>> &board, int curr_row, int curr_col)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            // For rows\n            if(board[curr_row][i] == value) return false;\n            \n            // For columns\n            if(board[i][curr_col] == value) return false;\n            \n            // 3 x 3 box\n            if(board[3 * (curr_row/3) + (i/3)][3 * (curr_col/3) + (i%3)] == value) return false;\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>> &board)\n    {\n        int n = board.size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(board[i][j] == '.') {\n                    for(char value = '1'; value <= '9'; value++) {\n                        if(isSafeToInsert(value, board, i, j)) {\n                            board[i][j] = value;\n                            bool remainingSoln = solve(board);\n                            if(remainingSoln) {\n                                return true;\n                            } else {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
            "compare_result": "111111",
            "title_slug": "sudoku-solver",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 935145628,
            "question_id": 37,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681722523,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "30 ms",
            "url": "/submissions/detail/935145628/",
            "is_pending": "Not Pending",
            "title": "Sudoku Solver",
            "memory": "6.5 MB",
            "code": "class Solution {\npublic:\n    bool isSafeToInsert(char value, vector<vector<char>> &board, int curr_row, int curr_col)\n    {\n        int n = board.size();\n        for (int i = 0; i < n; i++)\n        {\n            // Row check\n            if (board[curr_row][i] == value)\n            {\n                return false;\n            }\n            // Column check\n            if (board[i][curr_col] == value)\n            {\n                return false;\n            }\n            // 3*3 box check\n            if (board[3 * (curr_row / 3) + (i / 3)][3 * (curr_col / 3) + (i % 3)] == value)\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    bool solve(vector<vector<char>> &board)\n    {\n        int n = board.size();\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (board[i][j] == '.')\n                {\n                    for (char value = '1'; value <= '9'; value++)\n                    {\n                        if (isSafeToInsert(value, board, i, j))\n                        {\n                            board[i][j] = value;\n                            bool remainingSoln = solve(board);\n                            if (remainingSoln == true)\n                            {\n                                return true;\n                            }\n                            else\n                            {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
            "compare_result": "111111",
            "title_slug": "sudoku-solver",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 935145578,
            "question_id": 37,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681722509,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "34 ms",
            "url": "/submissions/detail/935145578/",
            "is_pending": "Not Pending",
            "title": "Sudoku Solver",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    bool isSafeToInsert(char value, vector<vector<char>> &board, int curr_row, int curr_col)\n    {\n        int n = board.size();\n        for (int i = 0; i < n; i++)\n        {\n            // Row check\n            if (board[curr_row][i] == value)\n            {\n                return false;\n            }\n            // Column check\n            if (board[i][curr_col] == value)\n            {\n                return false;\n            }\n            // 3*3 box check\n            if (board[3 * (curr_row / 3) + (i / 3)][3 * (curr_col / 3) + (i % 3)] == value)\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    bool solve(vector<vector<char>> &board)\n    {\n        int n = board.size();\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                if (board[i][j] == '.')\n                {\n                    for (char value = '1'; value <= '9'; value++)\n                    {\n                        if (isSafeToInsert(value, board, i, j))\n                        {\n                            board[i][j] = value;\n                            bool remainingSoln = solve(board);\n                            if (remainingSoln == true)\n                            {\n                                return true;\n                            }\n                            else\n                            {\n                                board[i][j] = '.';\n                            }\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};",
            "compare_result": "111111",
            "title_slug": "sudoku-solver",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932242738,
            "question_id": 792,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681268226,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "29 ms",
            "url": "/submissions/detail/932242738/",
            "is_pending": "Not Pending",
            "title": "Binary Search",
            "memory": "27.7 MB",
            "code": "class Solution {\npublic:\n    int binarySearch(vector<int> &nums, int target) {\n        int s = 0, e = nums.size()-1;\n        int mid = s + (e-s) / 2;\n        while(s <= e) {\n            if(nums[mid] == target) {\n                return mid;\n            }\n            else if(nums[mid] > target) {\n                e = mid - 1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s) / 2;\n        }\n        return -1;\n    }\n    int search(vector<int>& nums, int target) {\n        return binarySearch(nums, target);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111",
            "title_slug": "binary-search",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932242674,
            "question_id": 792,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681268213,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "46 ms",
            "url": "/submissions/detail/932242674/",
            "is_pending": "Not Pending",
            "title": "Binary Search",
            "memory": "27.5 MB",
            "code": "class Solution {\npublic:\n    int binarySearch(vector<int> &nums, int target) {\n        int s = 0, e = nums.size()-1;\n        int mid = s + (e-s) / 2;\n        while(s <= e) {\n            if(nums[mid] == target) {\n                return mid;\n            }\n            else if(nums[mid] > target) {\n                e = mid - 1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s) / 2;\n        }\n        return -1;\n    }\n    int search(vector<int>& nums, int target) {\n        return binarySearch(nums, target);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111",
            "title_slug": "binary-search",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932242555,
            "question_id": 792,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681268196,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "36 ms",
            "url": "/submissions/detail/932242555/",
            "is_pending": "Not Pending",
            "title": "Binary Search",
            "memory": "27.6 MB",
            "code": "class Solution {\npublic:\n    int binarySearch(vector<int> &nums, int target) {\n        int s = 0, e = nums.size()-1;\n        int mid = s + (e-s) / 2;\n        while(s <= e) {\n            if(nums[mid] == target) {\n                return mid;\n            }\n            else if(nums[mid] > target) {\n                e = mid - 1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s) / 2;\n        }\n        return -1;\n    }\n    int search(vector<int>& nums, int target) {\n        return binarySearch(nums, target);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111",
            "title_slug": "binary-search",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932242495,
            "question_id": 792,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681268185,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "50 ms",
            "url": "/submissions/detail/932242495/",
            "is_pending": "Not Pending",
            "title": "Binary Search",
            "memory": "27.6 MB",
            "code": "class Solution {\npublic:\n    int binarySearch(vector<int> &nums, int target) {\n        int s = 0, e = nums.size()-1;\n        int mid = s + (e-s) / 2;\n        while(s <= e) {\n            if(nums[mid] == target) {\n                return mid;\n            }\n            else if(nums[mid] > target) {\n                e = mid - 1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s) / 2;\n        }\n        return -1;\n    }\n    int search(vector<int>& nums, int target) {\n        return binarySearch(nums, target);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111",
            "title_slug": "binary-search",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932050971,
            "question_id": 908,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681235602,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/932050971/",
            "is_pending": "Not Pending",
            "title": "Middle of the Linked List",
            "memory": "6.9 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode *head)\n    {\n        int i = 0;\n        ListNode *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    ListNode* middleNode(ListNode* head) {\n        int len = findLength(head);\n        int i = 1;\n        if(len%2 == 0) {\n            i = (len/2)+1;\n            while(i > 1) {\n                head = head->next;\n                i--;\n            }\n        } else {\n            i = (int)(ceil(len/2));\n            while(i > 0 && head) {\n                head = head->next;\n                i--;\n            }\n        }\n        return head;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111",
            "title_slug": "middle-of-the-linked-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932050746,
            "question_id": 908,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681235582,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/932050746/",
            "is_pending": "Not Pending",
            "title": "Middle of the Linked List",
            "memory": "7.2 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findLength(ListNode *head)\n    {\n        int i = 0;\n        ListNode *temp = head;\n        while (temp != NULL)\n        {\n            i++;\n            temp = temp->next;\n        }\n        return i;\n    }\n    ListNode* middleNode(ListNode* head) {\n        int len = findLength(head);\n        int i = 1;\n        if(len%2 == 0) {\n            i = (len/2)+1;\n            while(i > 1) {\n                head = head->next;\n                i--;\n            }\n        } else {\n            i = (int)(ceil(len/2));\n            while(i > 0 && head) {\n                head = head->next;\n                i--;\n            }\n        }\n        return head;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111",
            "title_slug": "middle-of-the-linked-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932039828,
            "question_id": 21,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681234412,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/932039828/",
            "is_pending": "Not Pending",
            "title": "Merge Two Sorted Lists",
            "memory": "14.8 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* listN1, ListNode* listN2) {\n        ListNode *list1 = listN1;\n        ListNode *list2 = listN2;\n        ListNode *temp = new ListNode();\n        ListNode *dummy = temp;\n        while(list1 != NULL && list2 != NULL) {\n            if(list2->val > list1->val) {\n                dummy->next = list1;\n                list1 = list1->next;\n            } else {\n                dummy->next = list2;\n                list2 = list2->next;\n            }\n            dummy = dummy->next;\n        }\n        if(list1) dummy->next = list1;\n        if(list2) dummy->next = list2;\n        dummy = temp->next;\n        delete temp;\n        return dummy;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "merge-two-sorted-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932039723,
            "question_id": 21,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681234402,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/932039723/",
            "is_pending": "Not Pending",
            "title": "Merge Two Sorted Lists",
            "memory": "14.8 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* listN1, ListNode* listN2) {\n        ListNode *list1 = listN1;\n        ListNode *list2 = listN2;\n        ListNode *temp = new ListNode();\n        ListNode *dummy = temp;\n        while(list1 != NULL && list2 != NULL) {\n            if(list2->val > list1->val) {\n                dummy->next = list1;\n                list1 = list1->next;\n            } else {\n                dummy->next = list2;\n                list2 = list2->next;\n            }\n            dummy = dummy->next;\n        }\n        if(list1) dummy->next = list1;\n        if(list2) dummy->next = list2;\n        dummy = temp->next;\n        delete temp;\n        return dummy;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "merge-two-sorted-lists",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 932025411,
            "question_id": 206,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1681232988,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/932025411/",
            "is_pending": "Not Pending",
            "title": "Reverse Linked List",
            "memory": "8.1 MB",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev = NULL;\n        ListNode *curr = head;\n        while (curr != NULL)\n        {\n            ListNode *forward = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = forward;\n        }\n        return prev;\n    }\n};",
            "compare_result": "1111111111111111111111111111",
            "title_slug": "reverse-linked-list",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928994070,
            "question_id": 205,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680778050,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/928994070/",
            "is_pending": "Not Pending",
            "title": "Isomorphic Strings",
            "memory": "6.9 MB",
            "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        char hash[256] = {0};\n        char tIsVisited[256] = {0};\n        \n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] == 0 && tIsVisited[t[i]] != 1) {\n                hash[s[i]] = t[i];\n                tIsVisited[t[i]] = 1;\n            }\n        }\n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] != t[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "isomorphic-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928994003,
            "question_id": 205,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680778040,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/928994003/",
            "is_pending": "Not Pending",
            "title": "Isomorphic Strings",
            "memory": "6.7 MB",
            "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        char hash[256] = {0};\n        char tIsVisited[256] = {0};\n        \n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] == 0 && tIsVisited[t[i]] != 1) {\n                hash[s[i]] = t[i];\n                tIsVisited[t[i]] = 1;\n            }\n        }\n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] != t[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "isomorphic-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928983688,
            "question_id": 392,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680776420,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/928983688/",
            "is_pending": "Not Pending",
            "title": "Is Subsequence",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int j = 0;\n        for(int i=0; i<t.length(); i++) {\n            if(j < s.length() && t[i] == s[j]) {\n                j++;\n            }\n        }\n        return (j == s.length());\n    }\n};",
            "compare_result": "111111111111111111",
            "title_slug": "is-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928983549,
            "question_id": 392,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680776399,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/928983549/",
            "is_pending": "Not Pending",
            "title": "Is Subsequence",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int j = 0;\n        for(int i=0; i<t.length(); i++) {\n            if(j < s.length() && t[i] == s[j]) {\n                j++;\n            }\n        }\n        return (j == s.length());\n    }\n};",
            "compare_result": "111111111111111111",
            "title_slug": "is-subsequence",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928974703,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680775053,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/928974703/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "10 MB",
            "code": "class Solution {\npublic:\n    // bool checkIfInAsc(vector<int> nums, int i) {\n    //     nums.erase(nums.begin()+i);\n    //     for(int i=0; i<nums.size()-1; i++) {\n    //         if(nums[i] >= nums[i+1]) return 0;\n    //     }\n    //     return 1;\n    // }\n    // bool canBeIncreasing(vector<int>& nums) {\n    //     for(int i=0; i<nums.size(); i++) {\n    //         if(checkIfInAsc(nums, i)) {\n    //             return 1;\n    //         }\n    //     }\n    //     return 0;\n    // }\n    bool canBeIncreasing(vector<int>& nums) {\n        int p = 0, count = 0;\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[i] >= nums[i+1]) {\n                count++;\n                p = i;\n            }\n        }\n        if(count > 1) return 0;\n        else if(count == 1) {\n            if(p == 0 || p == nums.size()-2) return 1;\n            if(nums[p+1] > nums[p-1] || nums[p] < nums[p+2]) return 1;\n            else return 0;\n        }\n        return 1;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928974632,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680775040,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/928974632/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "10 MB",
            "code": "class Solution {\npublic:\n    // bool checkIfInAsc(vector<int> nums, int i) {\n    //     nums.erase(nums.begin()+i);\n    //     for(int i=0; i<nums.size()-1; i++) {\n    //         if(nums[i] >= nums[i+1]) return 0;\n    //     }\n    //     return 1;\n    // }\n    // bool canBeIncreasing(vector<int>& nums) {\n    //     for(int i=0; i<nums.size(); i++) {\n    //         if(checkIfInAsc(nums, i)) {\n    //             return 1;\n    //         }\n    //     }\n    //     return 0;\n    // }\n    bool canBeIncreasing(vector<int>& nums) {\n        int p = 0, count = 0;\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[i] >= nums[i+1]) {\n                count++;\n                p = i;\n            }\n        }\n        if(count > 1) return 0;\n        else if(count == 1) {\n            if(p == 0 || p == nums.size()-2) return 1;\n            if(nums[p+1] > nums[p-1] || nums[p] < nums[p+2]) return 1;\n            else return 0;\n        }\n        return 1;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928973878,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680774924,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/928973878/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    // bool checkIfInAsc(vector<int> nums, int i) {\n    //     nums.erase(nums.begin()+i);\n    //     for(int i=0; i<nums.size()-1; i++) {\n    //         if(nums[i] >= nums[i+1]) return 0;\n    //     }\n    //     return 1;\n    // }\n    // bool canBeIncreasing(vector<int>& nums) {\n    //     for(int i=0; i<nums.size(); i++) {\n    //         if(checkIfInAsc(nums, i)) {\n    //             return 1;\n    //         }\n    //     }\n    //     return 0;\n    // }\n    bool canBeIncreasing(vector<int>& nums) {\n        int p = 0, count = 0;\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[i] >= nums[i+1]) {\n                count++;\n                p = i;\n            }\n        }\n        if(count > 1) return 0;\n        else if(count == 1) {\n            if(p == 0 || p == nums.size()-2) return 1;\n            if(nums[p+1] > nums[p-1] || nums[p] < nums[p+2]) return 1;\n            else return 0;\n        }\n        return 0;\n    }\n};",
            "compare_result": "1110101111001111111111111111101111101111111111111111111111111111111111111011111111111111111111111111111111011",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928973215,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680774822,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/928973215/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    // bool checkIfInAsc(vector<int> nums, int i) {\n    //     nums.erase(nums.begin()+i);\n    //     for(int i=0; i<nums.size()-1; i++) {\n    //         if(nums[i] >= nums[i+1]) return 0;\n    //     }\n    //     return 1;\n    // }\n    // bool canBeIncreasing(vector<int>& nums) {\n    //     for(int i=0; i<nums.size(); i++) {\n    //         if(checkIfInAsc(nums, i)) {\n    //             return 1;\n    //         }\n    //     }\n    //     return 0;\n    // }\n    bool canBeIncreasing(vector<int>& nums) {\n        int p = 0, count = 0;\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[i] >= nums[i+1]) {\n                count++;\n                p = i;\n            }\n            if(count > 1) return 0;\n            else if(count == 1) {\n                if(p == 0 || p == nums.size()-2) return 1;\n                if(nums[p+1] > nums[p-1] || nums[p] < nums[p+2]) return 1;\n                else return 0;\n            }\n        }\n        return 0;\n    }\n};",
            "compare_result": "1100101011001111111111111111001101000111010101011101010101010101010101010001010101010101010101010100111101010",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928972470,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680774718,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/928972470/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    // bool checkIfInAsc(vector<int> nums, int i) {\n    //     nums.erase(nums.begin()+i);\n    //     for(int i=0; i<nums.size()-1; i++) {\n    //         if(nums[i] >= nums[i+1]) return 0;\n    //     }\n    //     return 1;\n    // }\n    // bool canBeIncreasing(vector<int>& nums) {\n    //     for(int i=0; i<nums.size(); i++) {\n    //         if(checkIfInAsc(nums, i)) {\n    //             return 1;\n    //         }\n    //     }\n    //     return 0;\n    // }\n    bool canBeIncreasing(vector<int>& nums) {\n        int p = 0, count = 0;\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[i] > nums[i+1]) {\n                count++;\n                p = i;\n            }\n            if(count > 1) return 0;\n            else if(count == 1) {\n                if(p == 0 || p == nums.size()-2) return 1;\n                if(nums[p+1] > nums[p-1] || nums[p] < nums[p+2]) return 1;\n                else return 0;\n            }\n        }\n        return 0;\n    }\n};",
            "compare_result": "1110001011001111111111111111001101000111010101011101010101010101010101010001010101010101010101010101111110010",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928865670,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680759046,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "78 ms",
            "url": "/submissions/detail/928865670/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "75.4 MB",
            "code": "class Solution {\npublic:\n    bool checkIfInAsc(vector<int> nums, int i) {\n        nums.erase(nums.begin()+i);\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[i] >= nums[i+1]) return 0;\n        }\n        return 1;\n    }\n    bool canBeIncreasing(vector<int>& nums) {\n        for(int i=0; i<nums.size(); i++) {\n            if(checkIfInAsc(nums, i)) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928865530,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680759026,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "83 ms",
            "url": "/submissions/detail/928865530/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "75.3 MB",
            "code": "class Solution {\npublic:\n    bool checkIfInAsc(vector<int> nums, int i) {\n        nums.erase(nums.begin()+i);\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[i] >= nums[i+1]) return 0;\n        }\n        return 1;\n    }\n    bool canBeIncreasing(vector<int>& nums) {\n        for(int i=0; i<nums.size(); i++) {\n            if(checkIfInAsc(nums, i)) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928539400,
            "question_id": 1263,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680709495,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/928539400/",
            "is_pending": "Not Pending",
            "title": "Number of Dice Rolls With Target Sum",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int numRollsToTarget(int n, int k, int target) {\n        if(target < 0) return 0;\n        if(n == 0 && target == 0) return 1;\n        if(n == 0 && target != 0) return 0;\n        if(n != 0 && target == 0) return 0;\n        \n        int ans = 0;\n        for(int i=1; i<=k; i++) {\n            ans += numRollsToTarget(n-1, k, target-i);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "number-of-dice-rolls-with-target-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928515083,
            "question_id": 1025,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680706620,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/928515083/",
            "is_pending": "Not Pending",
            "title": "Minimum Cost For Tickets",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int minCostTickets_helper(vector<int>& days, vector<int>& costs, int i) {\n        if(i >= days.size()) {\n            return 0;\n        }\n        \n        int cost1 = costs[0] + minCostTickets_helper(days, costs, i+1);\n        \n        int passEndDay = days[i] + 7 - 1;\n        int j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost7 = costs[1] + minCostTickets_helper(days, costs, j);\n        \n        passEndDay = days[i] + 30 - 1;\n        j = i;\n        while(j < days.size() && days[j] <= passEndDay) {\n            j++;\n        }\n        \n        int cost30 = costs[2] + minCostTickets_helper(days, costs, j);\n        \n        return min(cost1, min(cost7, cost30));\n    }\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        return minCostTickets_helper(days, costs, 0);\n    }\n};",
            "compare_result": "1111111111111111111111111100000000000000000000000000000000000000000000",
            "title_slug": "minimum-cost-for-tickets",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928427816,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680695345,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/928427816/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool canBeIncreasing(vector<int>& nums) {\n        int c = 0;\n        for(int i=1; i<nums.size(); i++) {\n            if(nums.size() > 2 && nums[i-1] == nums[i]) return 0;\n            if(nums[i-1] > nums[i]) {\n                nums.erase(nums.begin()+(i-1));\n                if(i>1)\n                    i -= 2;\n                else \n                    i -= 1;\n                c++;\n            }\n        }\n        return (c == 1 || c == 0);\n    }\n};",
            "compare_result": "1111111111111110111111101011111011111111101111111011111010101010111110111110111011111011111011101011110111111",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928424493,
            "question_id": 2020,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680694881,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/928424493/",
            "is_pending": "Not Pending",
            "title": "Remove One Element to Make the Array Strictly Increasing",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool canBeIncreasing(vector<int>& nums) {\n        int c = 0;\n        for(int i=1; i<nums.size(); i++) {\n            if(nums[i-1] > nums[i]) {\n                nums.erase(nums.begin()+(i-1));\n                if(i>1)\n                    i -= 2;\n                else \n                    i -= 1;\n                c++;\n            }\n        }\n        return c == 1;\n    }\n};",
            "compare_result": "1110001111001110111111101011101011101111101111111011111010101010111110111010111011111011111011101011111010010",
            "title_slug": "remove-one-element-to-make-the-array-strictly-increasing",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928383069,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680688612,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "24 ms",
            "url": "/submissions/detail/928383069/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "31.2 MB",
            "code": "class Solution {\npublic:\n    int findPivot(vector<int>& nums) {\n        if(nums.size() == 0) return -1;\n        int leftSum = 0;\n        int rightSum = accumulate(nums.begin(), nums.end(), 0);\n        for(int i=0; i<nums.size(); i++) {\n            rightSum -= nums[i];\n            if(leftSum == rightSum) {\n                return i;\n            }\n            leftSum += nums[i];\n        }\n        return -1;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928382995,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680688601,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "32 ms",
            "url": "/submissions/detail/928382995/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "31.2 MB",
            "code": "class Solution {\npublic:\n    int findPivot(vector<int>& nums) {\n        if(nums.size() == 0) return -1;\n        int leftSum = 0;\n        int rightSum = accumulate(nums.begin(), nums.end(), 0);\n        for(int i=0; i<nums.size(); i++) {\n            rightSum -= nums[i];\n            if(leftSum == rightSum) {\n                return i;\n            }\n            leftSum += nums[i];\n        }\n        return -1;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928381870,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680688432,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "24 ms",
            "url": "/submissions/detail/928381870/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "31.1 MB",
            "code": "class Solution {\npublic:\n    int findPivot(vector<int>& nums) {\n        int leftSum = 0;\n        int rightSum = accumulate(nums.begin(), nums.end(), 0);\n        for(int i=0; i<nums.size(); i++) {\n            rightSum -= nums[i];\n            if(leftSum == rightSum) {\n                return i;\n            }\n            leftSum += nums[i];\n        }\n        return -1;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928381770,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680688418,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "28 ms",
            "url": "/submissions/detail/928381770/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "31.1 MB",
            "code": "class Solution {\npublic:\n    int findPivot(vector<int>& nums) {\n        int leftSum = 0;\n        int rightSum = accumulate(nums.begin(), nums.end(), 0);\n        for(int i=0; i<nums.size(); i++) {\n            rightSum -= nums[i];\n            if(leftSum == rightSum) {\n                return i;\n            }\n            leftSum += nums[i];\n        }\n        return -1;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928353672,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680684321,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/928353672/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findSum(vector<int> nums, int start, int end) {\n        int sum = 0;\n        for(int i=start; i<=end; i++) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n    int findPivot(vector<int>& nums) {\n        int mid = nums.size()/2;\n        int leftSum = findSum(nums, 0, mid-1);\n        int lSum = leftSum;\n        int rightSum = findSum(nums, mid+1, nums.size()-1);\n        int rSum = rightSum;\n        while(leftSum != rightSum) {\n            if(abs(leftSum) > abs(rightSum)) {\n                mid--;\n            } else {\n                mid++;\n            }\n            if(mid > 0) {\n                leftSum = findSum(nums, 0, mid-1);\n            } else {\n                leftSum = 0;\n            }\n            if(mid < nums.size()-1) {\n                rightSum = findSum(nums, mid+1, nums.size()-1);\n            } else {\n                rightSum = 0;\n            }\n            if(leftSum == rightSum) {\n                return mid;\n            } else if(leftSum == rSum && rightSum == lSum) {\n                return -1;\n            } else if(mid == 0 || mid == nums.size()-1) {\n                return -1;\n            }\n            lSum = leftSum;\n            rSum = rightSum;\n        }\n        return mid;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928350256,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680683784,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/928350256/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findSum(vector<int> nums, int start, int end) {\n        int sum = 0;\n        for(int i=start; i<=end; i++) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n    int findPivot(vector<int>& nums) {\n        int mid = nums.size()/2;\n        int leftSum = findSum(nums, 0, mid-1);\n        int lSum = leftSum;\n        int rightSum = findSum(nums, mid+1, nums.size()-1);\n        int rSum = rightSum;\n        while(leftSum != rightSum) {\n            if(abs(leftSum) > abs(rightSum)) {\n                mid--;\n            } else {\n                mid++;\n            }\n            if(mid > 0) {\n                leftSum = findSum(nums, 0, mid-1);\n            } else {\n                leftSum = 0;\n            }\n            if(mid < nums.size()-1) {\n                rightSum = findSum(nums, mid+1, nums.size()-1);\n            } else {\n                rightSum = 0;\n            }\n            if(leftSum == rightSum) {\n                return mid;\n            } else if(leftSum == rSum && rightSum == lSum) {\n                return -1;\n            } else if(mid == 0 || mid == nums.size()-1) {\n                return -1;\n            }\n        }\n        return mid;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928323197,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680679690,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/928323197/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findSum(vector<int> nums, int start, int end) {\n        int sum = 0;\n        for(int i=start; i<=end; i++) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n    int findPivot(vector<int>& nums) {\n        int mid = nums.size()/2;\n        int leftSum = findSum(nums, 0, mid-1);\n        int rightSum = findSum(nums, mid+1, nums.size()-1);\n        while(leftSum != rightSum) {\n            if(abs(leftSum) > abs(rightSum)) {\n                mid--;\n            } else {\n                mid++;\n            }\n            if(mid > 0) {\n                leftSum = findSum(nums, 0, mid-1);\n            } else {\n                leftSum = 0;\n            }\n            if(mid < nums.size()-1) {\n                rightSum = findSum(nums, mid+1, nums.size()-1);\n            } else {\n                rightSum = 0;\n            }\n            if(leftSum == rightSum) {\n                return mid;\n            } else if(mid == 0 || mid == nums.size()-1) {\n                return -1;\n            }\n        }\n        return mid;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928319404,
            "question_id": 724,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680679139,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/928319404/",
            "is_pending": "Not Pending",
            "title": "Find Pivot Index",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findSum(vector<int> nums, int start, int end) {\n        int sum = 0;\n        for(int i=start; i<=end; i++) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n    int findPivot(vector<int>& nums) {\n        int mid = nums.size()/2;\n        int leftSum = findSum(nums, 0, mid-1);\n        int rightSum = findSum(nums, mid+1, nums.size()-1);\n        while(leftSum != rightSum) {\n            if(leftSum > rightSum) {\n                mid--;\n            } else {\n                mid++;\n            }\n            if(mid > 0) {\n                leftSum = findSum(nums, 0, mid-1);\n            } else {\n                leftSum = 0;\n            }\n            if(mid < nums.size()-1) {\n                rightSum = findSum(nums, mid+1, nums.size()-1);\n            } else {\n                rightSum = 0;\n            }\n            if(leftSum == rightSum) {\n                return mid;\n            } else if(mid == 0 || mid == nums.size()-1) {\n                return -1;\n            }\n        }\n        return mid;\n    }\n    int pivotIndex(vector<int>& nums) {\n        return findPivot(nums);\n    }\n};",
            "compare_result": "11110101010101010101010101010110000101000101010101010101110101010101010101100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "find-pivot-index",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928287678,
            "question_id": 1603,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680674980,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/928287678/",
            "is_pending": "Not Pending",
            "title": "Running Sum of 1d Array",
            "memory": "8.4 MB",
            "code": "class Solution {\npublic:\n    vector<int> runningSum(vector<int>& nums) {\n        for(int i=1; i<nums.size(); i++) {\n            nums[i] += nums[i-1];\n        }\n        return nums;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "title_slug": "running-sum-of-1d-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928285888,
            "question_id": 1603,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680674744,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "16 ms",
            "url": "/submissions/detail/928285888/",
            "is_pending": "Not Pending",
            "title": "Running Sum of 1d Array",
            "memory": "8.6 MB",
            "code": "class Solution {\npublic:\n    vector<int> runningSum(vector<int>& nums) {\n        vector<int> ans(nums.size());\n        for(int i=0; i<nums.size(); i++) {\n            for(int j=0; j<=i; j++) {\n                ans[i] += nums[j];\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "title_slug": "running-sum-of-1d-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928285751,
            "question_id": 1603,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680674728,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "13 ms",
            "url": "/submissions/detail/928285751/",
            "is_pending": "Not Pending",
            "title": "Running Sum of 1d Array",
            "memory": "8.6 MB",
            "code": "class Solution {\npublic:\n    vector<int> runningSum(vector<int>& nums) {\n        vector<int> ans(nums.size());\n        for(int i=0; i<nums.size(); i++) {\n            for(int j=0; j<=i; j++) {\n                ans[i] += nums[j];\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "title_slug": "running-sum-of-1d-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928261752,
            "question_id": 4,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680671605,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "28 ms",
            "url": "/submissions/detail/928261752/",
            "is_pending": "Not Pending",
            "title": "Median of Two Sorted Arrays",
            "memory": "90.2 MB",
            "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> nums3;\n        double d1;\n        for(int i=0; i<nums1.size(); i++) {\n            nums3.push_back(nums1[i]);\n        }\n        for(int i=0; i<nums2.size(); i++) {\n            nums3.push_back(nums2[i]);\n        }\n        sort(nums3.begin(), nums3.end());\n        int len = nums3.size();\n        if(len%2 == 0) {\n            int l1 = len/2, l2 = (len/2)-1;\n            d1 = ((double)nums3[l1]+nums3[l2])/2;\n            return d1;\n        } else {\n            int l1 = len/2;\n            d1 = nums3[l1];\n            return d1;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "median-of-two-sorted-arrays",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 928261662,
            "question_id": 4,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680671594,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "47 ms",
            "url": "/submissions/detail/928261662/",
            "is_pending": "Not Pending",
            "title": "Median of Two Sorted Arrays",
            "memory": "90.2 MB",
            "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> nums3;\n        double d1;\n        for(int i=0; i<nums1.size(); i++) {\n            nums3.push_back(nums1[i]);\n        }\n        for(int i=0; i<nums2.size(); i++) {\n            nums3.push_back(nums2[i]);\n        }\n        sort(nums3.begin(), nums3.end());\n        int len = nums3.size();\n        if(len%2 == 0) {\n            int l1 = len/2, l2 = (len/2)-1;\n            d1 = ((double)nums3[l1]+nums3[l2])/2;\n            return d1;\n        } else {\n            int l1 = len/2;\n            d1 = nums3[l1];\n            return d1;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "median-of-two-sorted-arrays",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927784322,
            "question_id": 168,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680603354,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/927784322/",
            "is_pending": "Not Pending",
            "title": "Excel Sheet Column Title",
            "memory": "5.8 MB",
            "code": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        string str = \"\";\n        while (columnNumber > 0)\n        {\n            int rem = columnNumber % 26;\n            if (rem == 0)\n            {\n                str.push_back('Z');\n                columnNumber = (columnNumber / 26) - 1;\n            }\n            else\n            {\n                str.push_back(rem + 'A' - 1);\n                columnNumber /= 26;\n            }\n        }\n        reverse(str.begin(), str.end());\n        return str;\n    }\n};",
            "compare_result": "111111111111111111",
            "title_slug": "excel-sheet-column-title",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927784137,
            "question_id": 168,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680603324,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/927784137/",
            "is_pending": "Not Pending",
            "title": "Excel Sheet Column Title",
            "memory": "6 MB",
            "code": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        string str = \"\";\n        while (columnNumber > 0)\n        {\n            int rem = columnNumber % 26;\n            if (rem == 0)\n            {\n                str.push_back('Z');\n                columnNumber = (columnNumber / 26) - 1;\n            }\n            else\n            {\n                str.push_back(rem + 'A' - 1);\n                columnNumber /= 26;\n            }\n        }\n        reverse(str.begin(), str.end());\n        return str;\n    }\n};",
            "compare_result": "111111111111111111",
            "title_slug": "excel-sheet-column-title",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927760248,
            "question_id": 168,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680600186,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/927760248/",
            "is_pending": "Not Pending",
            "title": "Excel Sheet Column Title",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        string str = \"\";\n        while (columnNumber > 0)\n        {\n            int rem = columnNumber % 26;\n            str.push_back(rem + 'A' - 1);\n            columnNumber /= 26;\n        }\n        reverse(str.begin(), str.end());\n        return str;\n    }\n};",
            "compare_result": "110111011011011111",
            "title_slug": "excel-sheet-column-title",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927705750,
            "question_id": 171,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680592899,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/927705750/",
            "is_pending": "Not Pending",
            "title": "Excel Sheet Column Number",
            "memory": "5.8 MB",
            "code": "class Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int finalAns = 0;\n        for (int i = 1; i <= columnTitle.length(); i++)\n        {\n            char ch = columnTitle.at(i - 1);\n            int num = (int)(ch - 'A' + 1);\n            int len = columnTitle.length();\n            while (len - i > 0)\n            {\n                num *= 26;\n                len--;\n            }\n            finalAns += num;\n        }\n        return finalAns;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "excel-sheet-column-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927705668,
            "question_id": 171,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680592888,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/927705668/",
            "is_pending": "Not Pending",
            "title": "Excel Sheet Column Number",
            "memory": "5.9 MB",
            "code": "class Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int finalAns = 0;\n        for (int i = 1; i <= columnTitle.length(); i++)\n        {\n            char ch = columnTitle.at(i - 1);\n            int num = (int)(ch - 'A' + 1);\n            int len = columnTitle.length();\n            while (len - i > 0)\n            {\n                num *= 26;\n                len--;\n            }\n            finalAns += num;\n        }\n        return finalAns;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "excel-sheet-column-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927139668,
            "question_id": 88,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680517616,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/927139668/",
            "is_pending": "Not Pending",
            "title": "Merge Sorted Array",
            "memory": "9.1 MB",
            "code": "class Solution {\npublic:\n    void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)\n    {\n        vector<int> dNum1(m);\n        for (int i = 0; i < m; i++)\n        {\n            dNum1[i] = nums1[i];\n        }\n        sort(dNum1.begin(), dNum1.end());\n        for (int i = 0; i < m; i++)\n        {\n            nums1[i] = dNum1[i];\n        }\n        reverse(nums1.begin(), nums1.end());\n        int j = 0;\n        for (int i = 0; i < nums1.size() - m; i++)\n        {\n            if (nums1[i] == 0)\n            {\n                int t1 = nums1.at(i);\n                nums1.at(i) = nums2[j];\n                j++;\n            }\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111",
            "title_slug": "merge-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927139579,
            "question_id": 88,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680517604,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/927139579/",
            "is_pending": "Not Pending",
            "title": "Merge Sorted Array",
            "memory": "9 MB",
            "code": "class Solution {\npublic:\n    void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)\n    {\n        vector<int> dNum1(m);\n        for (int i = 0; i < m; i++)\n        {\n            dNum1[i] = nums1[i];\n        }\n        sort(dNum1.begin(), dNum1.end());\n        for (int i = 0; i < m; i++)\n        {\n            nums1[i] = dNum1[i];\n        }\n        reverse(nums1.begin(), nums1.end());\n        int j = 0;\n        for (int i = 0; i < nums1.size() - m; i++)\n        {\n            if (nums1[i] == 0)\n            {\n                int t1 = nums1.at(i);\n                nums1.at(i) = nums2[j];\n                j++;\n            }\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111",
            "title_slug": "merge-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927139419,
            "question_id": 88,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680517582,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/927139419/",
            "is_pending": "Not Pending",
            "title": "Merge Sorted Array",
            "memory": "9.1 MB",
            "code": "class Solution {\npublic:\n    void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)\n    {\n        vector<int> dNum1(m);\n        for (int i = 0; i < m; i++)\n        {\n            dNum1[i] = nums1[i];\n        }\n        sort(dNum1.begin(), dNum1.end());\n        for (int i = 0; i < m; i++)\n        {\n            nums1[i] = dNum1[i];\n        }\n        reverse(nums1.begin(), nums1.end());\n        int j = 0;\n        for (int i = 0; i < nums1.size() - m; i++)\n        {\n            if (nums1[i] == 0)\n            {\n                int t1 = nums1.at(i);\n                nums1.at(i) = nums2[j];\n                j++;\n            }\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111",
            "title_slug": "merge-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927111891,
            "question_id": 88,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680513714,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/927111891/",
            "is_pending": "Not Pending",
            "title": "Merge Sorted Array",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int j = 0;\n        for (int i = 0; i < nums1.size(); i++)\n        {\n            if (nums1[i] == 0)\n            {\n                nums1.at(i) = nums2[j];\n                j++;\n            }\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};",
            "compare_result": "11111111111110000000000000000000000000000000000000000000000",
            "title_slug": "merge-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927105392,
            "question_id": 279,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680512821,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/927105392/",
            "is_pending": "Not Pending",
            "title": "Perfect Squares",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    map<int, int> mp;\n\n    int numSquaresHelper(int n)\n    {\n        if (n == 0)\n            return 1;\n        if (n < 0)\n            return 0;\n        int i = 1;\n        int end = sqrt(n);\n        int ans = INT_MAX;\n        while (i <= end)\n        {\n            int perfectSquare = i * i;\n            int calcNewPerfSquare = 0;\n            if (mp[n - perfectSquare] > 0)\n            {\n                calcNewPerfSquare = mp[n - perfectSquare];\n            }\n            else\n            {\n                calcNewPerfSquare = numSquaresHelper(n - perfectSquare);\n                mp[n - perfectSquare] = calcNewPerfSquare;\n            }\n            int noOfPerfectSqaures = 1 + calcNewPerfSquare;\n            if (noOfPerfectSqaures < ans)\n            {\n                ans = noOfPerfectSqaures;\n            }\n            ++i;\n        }\n        return ans;\n    }\n    int numSquares(int n) {\n        return numSquaresHelper(n) - 1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000",
            "title_slug": "perfect-squares",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 927049480,
            "question_id": 279,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680504862,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/927049480/",
            "is_pending": "Not Pending",
            "title": "Perfect Squares",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int numSquaresHelper(int n)\n    {\n        if (n == 0)\n            return 1;\n        if (n < 0)\n            return 0;\n        int i = 1;\n        int end = sqrt(n);\n        int ans = INT_MAX;\n        while (i <= end)\n        {\n            int perfectSquare = i * i;\n            int noOfPerfectSqaures = 1 + numSquaresHelper(n - perfectSquare);\n            if (noOfPerfectSqaures < ans)\n            {\n                ans = noOfPerfectSqaures;\n            }\n            ++i;\n        }\n        return ans;\n    }\n    int numSquares(int n) {\n        return numSquaresHelper(n) - 1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "perfect-squares",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 926352182,
            "question_id": 44,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680407824,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/926352182/",
            "is_pending": "Not Pending",
            "title": "Wildcard Matching",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isMatchHelper(string s, int si, string p, int pi) {\n        // BC: All chars matched\n        if(si == s.size() && pi == p.size()) {\n            return true;\n        }\n        // When s is empty but p exists\n        if(si == s.size() && pi < p.size()) {\n            while(pi < p.size()) {\n                if(p[pi] != '*')\n                    return false;\n                pi++;\n            } \n            return true;\n        }\n        // Single char matching\n        if(s[si] == p[pi] || p[pi] == '?') {\n            return isMatchHelper(s, si+1, p, pi+1);\n        }\n        \n        // If * occurs\n        if(p[pi] == '*') {\n            // Treat * as null\n            bool caseA = isMatchHelper(s, si, p, pi+1);\n            // Treat * to match single char\n            bool caseB = isMatchHelper(s, si+1, p, pi);\n            return caseA || caseB;\n        }\n        \n        // Char doesn't match\n        return false;\n    }\n    bool isMatch(string s, string p) {\n        int si = 0, pi = 0;\n        \n        return isMatchHelper(s,si,p,pi);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "wildcard-matching",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 926345930,
            "question_id": 44,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680407372,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/926345930/",
            "is_pending": "Not Pending",
            "title": "Wildcard Matching",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isMatchHelper(string s, int si, string p, int pi) {\n        // All chars matched\n        if(si == s.size() && pi == p.size()) {\n            return true;\n        }\n        if(si == s.size() && pi < p.size()) {\n            while(pi < p.size()) {\n                if(p[pi] != '*')\n                    return false;\n                pi--;\n            }\n            return true;\n        }\n        // Single char matching\n        if(s[si] == p[pi] || p[pi] == '?') {\n            isMatchHelper(s, si+1, p, pi+1);\n        }\n        \n        // If * occurs\n        if(p[pi] == '*') {\n            // Treat * as null\n            bool caseA = isMatchHelper(s, si, p, pi+1);\n            // Treat * to match single char\n            bool caseB = isMatchHelper(s, si+1, p, pi);\n            return caseA || caseB;\n        }\n        \n        // Char doesn't match\n        return false;\n    }\n    bool isMatch(string s, string p) {\n        int si = 0, pi = 0;\n        \n        return isMatchHelper(s,si,p,pi);\n    }\n};",
            "compare_result": "11111110100101110001111111001010110011011011100101111110100101111101001001001001110111001110001100010001111010101110100111111110110111101101101101111110011001011010110111111111010100011000111111110011111111111111111101111111111010010010010010111011100111011000100011011001001011101111100010111010110010010011111111111111011001100111111110111111111111011111011111011101111111111001111111110111010111111111101101100110011111111011110011100111000110101110101100011111111011111111110011101101111101110110001111111011111110111011111100111111011001101011101010111111111011011111111111010111101111010111100100111010011011111111111001010111100111111010111101011101111011111111111111101111111110111110110111100111111111100100011111001111111111101110110010011111111111011101111111101100010001101111110110110101011111100111011011000111100111101100110101100101111101111111110001011110111010100111111101101101011111110111111111111101111110101011111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "wildcard-matching",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 925868196,
            "question_id": 273,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680349272,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/925868196/",
            "is_pending": "Not Pending",
            "title": "Integer to English Words",
            "memory": "7.3 MB",
            "code": "class Solution {\npublic:\n    vector<pair<int,string>> mp = {\n        {1000000000,\"Billion\"}, {1000000, \"Million\"}, {1000, \"Thousand\"},\n        {100, \"Hundred\"}, {90, \"Ninety\"}, {80, \"Eighty\"}, {70, \"Seventy\"},\n        {60, \"Sixty\"}, {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"},\n        {20, \"Twenty\"}, {19, \"Nineteen\"}, {18, \"Eighteen\"}, {17, \"Seventeen\"},\n        {16, \"Sixteen\"}, {15, \"Fifteen\"}, {14, \"Fourteen\"}, {13, \"Thirteen\"},\n        {12, \"Twelve\"}, {11, \"Eleven\"}, {10, \"Ten\"}, {9, \"Nine\"}, {8, \"Eight\"},\n        {7, \"Seven\"}, {6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"},\n        {2, \"Two\"}, {1, \"One\"}\n    };\n    string numberToWords(int num) {\n        if(num == 0) {\n            return \"Zero\";\n        }\n        for(auto it : mp) {\n            if(num >= it.first) {\n                string a = \"\";\n                if(num >= 100) {\n                    a = numberToWords(num / it.first) + \" \";\n                }\n                string b = it.second;\n                string c = \"\";\n                if(num % it.first != 0) {\n                    c = \" \" + numberToWords(num % it.first);\n                }\n                return a + b + c;\n            }\n        }\n        return \"\";\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "integer-to-english-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 925320650,
            "question_id": 88,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680259239,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/925320650/",
            "is_pending": "Not Pending",
            "title": "Merge Sorted Array",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int j = 0;\n        for (int i = 0; i < nums1.size(); i++)\n        {\n            if (nums1[i] == 0)\n            {\n                nums1.at(i) = nums2[j];\n                j++;\n            }\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};",
            "compare_result": "11111111111110000000000000000000000000000000000000000000000",
            "title_slug": "merge-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 925099574,
            "question_id": 273,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680220051,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/925099574/",
            "is_pending": "Not Pending",
            "title": "Integer to English Words",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string rtrim(const string &s)\n    {\n        const string WHITESPACE = \" \\n\\r\\t\\f\\v\";\n        size_t end = s.find_last_not_of(WHITESPACE);\n        return (end == string::npos) ? \"\" : s.substr(0, end + 1);\n    }\n    vector<string> numberToWords(int num, int len)\n    {\n        string orderMagnitude[] = {\" Hundred\", \" Thousand\", \" Million\", \" Billion\"};\n        map<int, string> mpOnes;\n        mpOnes[0] = \"Zero\";\n        mpOnes[1] = \"One\";\n        mpOnes[2] = \"Two\";\n        mpOnes[3] = \"Three\";\n        mpOnes[4] = \"Four\";\n        mpOnes[5] = \"Five\";\n        mpOnes[6] = \"Six\";\n        mpOnes[7] = \"Seven\";\n        mpOnes[8] = \"Eight\";\n        mpOnes[9] = \"Nine\";\n\n        map<int, string> mpTOnes;\n        mpTOnes[0] = \"Ten\";\n        mpTOnes[1] = \"Eleven\";\n        mpTOnes[2] = \"Twelve\";\n        mpTOnes[3] = \"Thirteen\";\n        mpTOnes[4] = \"Fourteen\";\n        mpTOnes[5] = \"Fifteen\";\n        mpTOnes[6] = \"Sixteen\";\n        mpTOnes[7] = \"Seventeen\";\n        mpTOnes[8] = \"Eighteen\";\n        mpTOnes[9] = \"Nineteen\";\n\n        map<int, string> mpTens;\n        mpTens[2] = \"Twenty\";\n        mpTens[3] = \"Thirty\";\n        mpTens[4] = \"Forty\";\n        mpTens[5] = \"Fifty\";\n        mpTens[6] = \"Sixty\";\n        mpTens[7] = \"Seventy\";\n        mpTens[8] = \"Eighty\";\n        mpTens[9] = \"Ninety\";\n\n        map<string, int> mNToVal;\n        mNToVal[\"On\"] = 1;\n        mNToVal[\"Tw\"] = 2;\n        mNToVal[\"Th\"] = 3;\n        mNToVal[\"Fo\"] = 4;\n        mNToVal[\"Fi\"] = 5;\n        mNToVal[\"Si\"] = 6;\n        mNToVal[\"Se\"] = 7;\n        mNToVal[\"Ei\"] = 8;\n        mNToVal[\"Ni\"] = 9;\n\n        vector<string> ans;\n        int i = 0;\n        if (len == 1)\n        {\n            ans.push_back(mpOnes[num]);\n            return ans;\n        }\n        do\n        {\n            int rem = num % 10;\n            // if (len == 1)\n            // {\n            //     ans.push_back(mpOnes[rem]);\n            //     break;\n            // }\n            if (i == 0 && rem > 0)\n            {\n                ans.push_back(mpOnes[rem]);\n            }\n            if (i == 2 || i == 5 || i == 8)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[0]);\n            }\n            if (i == 1 || i == 4 || i == 7)\n            {\n                if (rem == 1)\n                {\n                    if(ans.size() > 0) {\n                        string lastStr = ans.back();\n                        int temp = mNToVal[lastStr.substr(0, 2)];\n                        int pos = lastStr.find(' ');\n                        string finalWord = \"\";\n                        if (pos != string::npos)\n                        {\n                            string orderOfMagnitude = lastStr.substr(pos + 1);\n                            finalWord = mpTOnes[temp] + \" \" + orderOfMagnitude;\n                        }\n                        else\n                        {\n                            finalWord = mpTOnes[temp];\n                        }\n                        ans.pop_back();\n                        ans.push_back(finalWord);\n                    } else {\n                        if (rem == 1)\n                            ans.push_back(mpTOnes[0]);\n                    }\n                }\n                else\n                {\n                    if (rem > 1)\n                        ans.push_back(mpTens[rem]);\n                }\n            }\n            if (i == 3)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[1]);\n            }\n            if (i == 6)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[2]);\n            }\n            if (i == 9)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[3]);\n            }\n            num /= 10;\n            i++;\n        } while (num);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n    string numberToWords(int num) {\n        vector<string> ans = numberToWords(num, to_string(num).length());\n        string finalAns = \"\";\n        for (auto i : ans)\n        {\n            finalAns.append(i + \" \");\n        }\n        return rtrim(finalAns.substr(0, finalAns.length()-1));\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000011000100101111111101110111000010100111010110000000000110010111010100000110000001111",
            "title_slug": "integer-to-english-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 924937163,
            "question_id": 273,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680196001,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/924937163/",
            "is_pending": "Not Pending",
            "title": "Integer to English Words",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string rtrim(const string &s)\n    {\n        const string WHITESPACE = \" \\n\\r\\t\\f\\v\";\n        size_t end = s.find_last_not_of(WHITESPACE);\n        return (end == string::npos) ? \"\" : s.substr(0, end + 1);\n    }\n    vector<string> numberToWords(int num, int len)\n    {\n        string orderMagnitude[] = {\" Hundred\", \" Thousand\", \" Million\", \" Billion\"};\n        map<int, string> mpOnes;\n        mpOnes[0] = \"Zero\";\n        mpOnes[1] = \"One\";\n        mpOnes[2] = \"Two\";\n        mpOnes[3] = \"Three\";\n        mpOnes[4] = \"Four\";\n        mpOnes[5] = \"Five\";\n        mpOnes[6] = \"Six\";\n        mpOnes[7] = \"Seven\";\n        mpOnes[8] = \"Eight\";\n        mpOnes[9] = \"Nine\";\n\n        map<int, string> mpTOnes;\n        mpTOnes[0] = \"Ten\";\n        mpTOnes[1] = \"Eleven\";\n        mpTOnes[2] = \"Twelve\";\n        mpTOnes[3] = \"Thirteen\";\n        mpTOnes[4] = \"Fourteen\";\n        mpTOnes[5] = \"Fifteen\";\n        mpTOnes[6] = \"Sixteen\";\n        mpTOnes[7] = \"Seventeen\";\n        mpTOnes[8] = \"Eighteen\";\n        mpTOnes[9] = \"Nineteen\";\n\n        map<int, string> mpTens;\n        mpTens[2] = \"Twenty\";\n        mpTens[3] = \"Thirty\";\n        mpTens[4] = \"Forty\";\n        mpTens[5] = \"Fifty\";\n        mpTens[6] = \"Sixty\";\n        mpTens[7] = \"Seventy\";\n        mpTens[8] = \"Eighty\";\n        mpTens[9] = \"Ninety\";\n\n        map<string, int> mNToVal;\n        mNToVal[\"On\"] = 1;\n        mNToVal[\"Tw\"] = 2;\n        mNToVal[\"Th\"] = 3;\n        mNToVal[\"Fo\"] = 4;\n        mNToVal[\"Fi\"] = 5;\n        mNToVal[\"Si\"] = 6;\n        mNToVal[\"Se\"] = 7;\n        mNToVal[\"Ei\"] = 8;\n        mNToVal[\"Ni\"] = 9;\n\n        vector<string> ans;\n        int i = 0;\n        if (len == 1)\n        {\n            ans.push_back(mpOnes[num]);\n            return ans;\n        }\n        do\n        {\n            int rem = num % 10;\n            // if (len == 1)\n            // {\n            //     ans.push_back(mpOnes[rem]);\n            //     break;\n            // }\n            if (i == 0 && rem > 0)\n            {\n                ans.push_back(mpOnes[rem]);\n            }\n            if (i == 2 || i == 5 || i == 8)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[0]);\n            }\n            if (i == 1 || i == 4 || i == 7)\n            {\n                if (rem == 1)\n                {\n                    if(ans.size() > 0) {\n                        string lastStr = ans.back();\n                        int temp = mNToVal[lastStr.substr(0, 2)];\n                        int pos = lastStr.find(' ');\n                        string finalWord = \"\";\n                        if (pos != string::npos)\n                        {\n                            string orderOfMagnitude = lastStr.substr(pos + 1);\n                            finalWord = mpTOnes[temp] + \" \" + orderOfMagnitude;\n                        }\n                        else\n                        {\n                            finalWord = mpTOnes[temp];\n                        }\n                        ans.pop_back();\n                        ans.push_back(finalWord);\n                    } else {\n                        if (rem == 1)\n                            ans.push_back(mpTOnes[0]);\n                    }\n                }\n                else\n                {\n                    ans.push_back(mpTens[rem]);\n                }\n            }\n            if (i == 3)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[1]);\n            }\n            if (i == 6)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[2]);\n            }\n            if (i == 9)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[3]);\n            }\n            num /= 10;\n            i++;\n        } while (num);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n    string numberToWords(int num) {\n        vector<string> ans = numberToWords(num, to_string(num).length());\n        string finalAns = \"\";\n        for (auto i : ans)\n        {\n            finalAns.append(i + \" \");\n        }\n        return rtrim(finalAns.substr(0, finalAns.length()-1));\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000011000100101111110101110101000010100110010010000000000100010111010100000010000001111",
            "title_slug": "integer-to-english-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 924936844,
            "question_id": 273,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680195969,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/924936844/",
            "is_pending": "Not Pending",
            "title": "Integer to English Words",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string rtrim(const string &s)\n    {\n        const string WHITESPACE = \" \\n\\r\\t\\f\\v\";\n        size_t end = s.find_last_not_of(WHITESPACE);\n        return (end == string::npos) ? \"\" : s.substr(0, end + 1);\n    }\n    vector<string> numberToWords(int num, int len)\n    {\n        string orderMagnitude[] = {\" Hundred\", \" Thousand\", \" Million\", \" Billion\"};\n        map<int, string> mpOnes;\n        mpOnes[0] = \"Zero\";\n        mpOnes[1] = \"One\";\n        mpOnes[2] = \"Two\";\n        mpOnes[3] = \"Three\";\n        mpOnes[4] = \"Four\";\n        mpOnes[5] = \"Five\";\n        mpOnes[6] = \"Six\";\n        mpOnes[7] = \"Seven\";\n        mpOnes[8] = \"Eight\";\n        mpOnes[9] = \"Nine\";\n\n        map<int, string> mpTOnes;\n        mpTOnes[0] = \"Ten\";\n        mpTOnes[1] = \"Eleven\";\n        mpTOnes[2] = \"Twelve\";\n        mpTOnes[3] = \"Thriteen\";\n        mpTOnes[4] = \"Fourteen\";\n        mpTOnes[5] = \"Fifteen\";\n        mpTOnes[6] = \"Sixteen\";\n        mpTOnes[7] = \"Seventeen\";\n        mpTOnes[8] = \"Eighteen\";\n        mpTOnes[9] = \"Nineteen\";\n\n        map<int, string> mpTens;\n        mpTens[2] = \"Twenty\";\n        mpTens[3] = \"Thirty\";\n        mpTens[4] = \"Forty\";\n        mpTens[5] = \"Fifty\";\n        mpTens[6] = \"Sixty\";\n        mpTens[7] = \"Seventy\";\n        mpTens[8] = \"Eighty\";\n        mpTens[9] = \"Ninety\";\n\n        map<string, int> mNToVal;\n        mNToVal[\"On\"] = 1;\n        mNToVal[\"Tw\"] = 2;\n        mNToVal[\"Th\"] = 3;\n        mNToVal[\"Fo\"] = 4;\n        mNToVal[\"Fi\"] = 5;\n        mNToVal[\"Si\"] = 6;\n        mNToVal[\"Se\"] = 7;\n        mNToVal[\"Ei\"] = 8;\n        mNToVal[\"Ni\"] = 9;\n\n        vector<string> ans;\n        int i = 0;\n        if (len == 1)\n        {\n            ans.push_back(mpOnes[num]);\n            return ans;\n        }\n        do\n        {\n            int rem = num % 10;\n            // if (len == 1)\n            // {\n            //     ans.push_back(mpOnes[rem]);\n            //     break;\n            // }\n            if (i == 0 && rem > 0)\n            {\n                ans.push_back(mpOnes[rem]);\n            }\n            if (i == 2 || i == 5 || i == 8)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[0]);\n            }\n            if (i == 1 || i == 4 || i == 7)\n            {\n                if (rem == 1)\n                {\n                    if(ans.size() > 0) {\n                        string lastStr = ans.back();\n                        int temp = mNToVal[lastStr.substr(0, 2)];\n                        int pos = lastStr.find(' ');\n                        string finalWord = \"\";\n                        if (pos != string::npos)\n                        {\n                            string orderOfMagnitude = lastStr.substr(pos + 1);\n                            finalWord = mpTOnes[temp] + \" \" + orderOfMagnitude;\n                        }\n                        else\n                        {\n                            finalWord = mpTOnes[temp];\n                        }\n                        ans.pop_back();\n                        ans.push_back(finalWord);\n                    } else {\n                        if (rem == 1)\n                            ans.push_back(mpTOnes[0]);\n                    }\n                }\n                else\n                {\n                    ans.push_back(mpTens[rem]);\n                }\n            }\n            if (i == 3)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[1]);\n            }\n            if (i == 6)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[2]);\n            }\n            if (i == 9)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[3]);\n            }\n            num /= 10;\n            i++;\n        } while (num);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n    string numberToWords(int num) {\n        vector<string> ans = numberToWords(num, to_string(num).length());\n        string finalAns = \"\";\n        for (auto i : ans)\n        {\n            finalAns.append(i + \" \");\n        }\n        return rtrim(finalAns.substr(0, finalAns.length()-1));\n    }\n};",
            "compare_result": "1111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000011101111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000001110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000011000100101111110101110101000010100010010010000000000100010111000100000010000001111",
            "title_slug": "integer-to-english-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 924931960,
            "question_id": 273,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680195459,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/924931960/",
            "is_pending": "Not Pending",
            "title": "Integer to English Words",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string rtrim(const string &s)\n    {\n        const string WHITESPACE = \" \\n\\r\\t\\f\\v\";\n        size_t end = s.find_last_not_of(WHITESPACE);\n        return (end == string::npos) ? \"\" : s.substr(0, end + 1);\n    }\n    vector<string> numberToWords(int num, int len)\n    {\n        string orderMagnitude[] = {\" Hundred\", \" Thousand\", \" Million\", \" Billion\"};\n        map<int, string> mpOnes;\n        mpOnes[0] = \"Zero\";\n        mpOnes[1] = \"One\";\n        mpOnes[2] = \"Two\";\n        mpOnes[3] = \"Three\";\n        mpOnes[4] = \"Four\";\n        mpOnes[5] = \"Five\";\n        mpOnes[6] = \"Six\";\n        mpOnes[7] = \"Seven\";\n        mpOnes[8] = \"Eight\";\n        mpOnes[9] = \"Nine\";\n\n        map<int, string> mpTOnes;\n        mpTOnes[0] = \"Ten\";\n        mpTOnes[1] = \"Eleven\";\n        mpTOnes[2] = \"Twelve\";\n        mpTOnes[3] = \"Thriteen\";\n        mpTOnes[4] = \"Fourteen\";\n        mpTOnes[5] = \"Fifteen\";\n        mpTOnes[6] = \"Sixteen\";\n        mpTOnes[7] = \"Seventeen\";\n        mpTOnes[8] = \"Eighteen\";\n        mpTOnes[9] = \"Nineteen\";\n\n        map<int, string> mpTens;\n        mpTens[2] = \"Twenty\";\n        mpTens[3] = \"Thirty\";\n        mpTens[4] = \"Forty\";\n        mpTens[5] = \"Fifty\";\n        mpTens[6] = \"Sixty\";\n        mpTens[7] = \"Seventy\";\n        mpTens[8] = \"Eighty\";\n        mpTens[9] = \"Ninety\";\n\n        map<string, int> mNToVal;\n        mNToVal[\"On\"] = 1;\n        mNToVal[\"Tw\"] = 2;\n        mNToVal[\"Th\"] = 3;\n        mNToVal[\"Fo\"] = 4;\n        mNToVal[\"Fi\"] = 5;\n        mNToVal[\"Si\"] = 6;\n        mNToVal[\"Se\"] = 7;\n        mNToVal[\"Ei\"] = 8;\n        mNToVal[\"Ni\"] = 9;\n\n        vector<string> ans;\n        int i = 0;\n        if (len == 1)\n        {\n            ans.push_back(mpOnes[num]);\n            return ans;\n        }\n        do\n        {\n            int rem = num % 10;\n            // if (len == 1)\n            // {\n            //     ans.push_back(mpOnes[rem]);\n            //     break;\n            // }\n            if (i == 0 && rem > 0)\n            {\n                ans.push_back(mpOnes[rem]);\n            }\n            if (i == 2 || i == 5 || i == 8)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[0]);\n            }\n            if (i == 1 || i == 4 || i == 7)\n            {\n                if (rem == 1)\n                {\n                    string lastStr = ans.back();\n                    int temp = mNToVal[lastStr.substr(0, 2)];\n                    int pos = lastStr.find(' ');\n                    string finalWord = \"\";\n                    if (pos != string::npos)\n                    {\n                        string orderOfMagnitude = lastStr.substr(pos + 1);\n                        finalWord = mpTOnes[temp] + \" \" + orderOfMagnitude;\n                    }\n                    else\n                    {\n                        finalWord = mpTOnes[temp];\n                    }\n                    ans.pop_back();\n                    ans.push_back(finalWord);\n                }\n                else\n                {\n                    ans.push_back(mpTens[rem]);\n                }\n            }\n            if (i == 3)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[1]);\n            }\n            if (i == 6)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[2]);\n            }\n            if (i == 9)\n            {\n                ans.push_back(mpOnes[rem] + orderMagnitude[3]);\n            }\n            num /= 10;\n            i++;\n        } while (num);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n    string numberToWords(int num) {\n        vector<string> ans = numberToWords(num, to_string(num).length());\n        string finalAns = \"\";\n        for (auto i : ans)\n        {\n            finalAns.append(i + \" \");\n        }\n        return rtrim(finalAns.substr(0, finalAns.length()-1));\n    }\n};",
            "compare_result": "1111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "integer-to-english-words",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 924660324,
            "question_id": 198,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680159056,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/924660324/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int robHelper(vector<int>& nums, int i) {\n        if(i>=nums.size()) {\n            return 0;\n        }\n        int rob1 = nums[i] + robHelper(nums, i+2);\n        int rob2 = 0 + robHelper(nums, i+1);\n        return max(rob1, rob2);\n    }\n    int rob(vector<int>& nums) {\n        return robHelper(nums, 0);\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111000000000000000",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 924120076,
            "question_id": 121,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680079643,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "137 ms",
            "url": "/submissions/detail/924120076/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "93.4 MB",
            "code": "class Solution {\npublic:\n    void maxProfit(vector<int> &prices, int &leastBuyPrice, int &overallProfit, int &profitIfSoldToday, int i)\n    {\n        if (i < prices.size())\n        {\n            if (prices[i] < leastBuyPrice)\n            {\n                leastBuyPrice = prices[i];\n            }\n            else\n            {\n                profitIfSoldToday = prices[i] - leastBuyPrice;\n                if (overallProfit < profitIfSoldToday)\n                {\n                    overallProfit = profitIfSoldToday;\n                }\n            }\n            maxProfit(prices, leastBuyPrice, overallProfit, profitIfSoldToday, i + 1);\n        }\n        else\n            return;\n    }\n    int maxProfit(vector<int>& prices) {\n        int leastBuyPrice = INT_MAX, overallProfit = 0, profitIfSoldToday = 0;\n        maxProfit(prices, leastBuyPrice, overallProfit, profitIfSoldToday, 0);\n        return overallProfit;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 924119958,
            "question_id": 121,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1680079624,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "147 ms",
            "url": "/submissions/detail/924119958/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "93.3 MB",
            "code": "class Solution {\npublic:\n    void maxProfit(vector<int> &prices, int &leastBuyPrice, int &overallProfit, int &profitIfSoldToday, int i)\n    {\n        if (i < prices.size())\n        {\n            if (prices[i] < leastBuyPrice)\n            {\n                leastBuyPrice = prices[i];\n            }\n            else\n            {\n                profitIfSoldToday = prices[i] - leastBuyPrice;\n                if (overallProfit < profitIfSoldToday)\n                {\n                    overallProfit = profitIfSoldToday;\n                }\n            }\n            maxProfit(prices, leastBuyPrice, overallProfit, profitIfSoldToday, i + 1);\n        }\n        else\n            return;\n    }\n    int maxProfit(vector<int>& prices) {\n        int leastBuyPrice = INT_MAX, overallProfit = 0, profitIfSoldToday = 0;\n        maxProfit(prices, leastBuyPrice, overallProfit, profitIfSoldToday, 0);\n        return overallProfit;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923557081,
            "question_id": 2021,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679999869,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/923557081/",
            "is_pending": "Not Pending",
            "title": "Remove All Occurrences of a Substring",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    void removeOccurrences(string &s, string part, int strInd)\n    {\n        strInd = s.find(part);\n        if (strInd != string::npos)\n        {\n            s.erase(strInd, part.length());\n            strInd = s.find(part);\n            removeOccurrences(s, part, strInd);\n        }\n        else\n        {\n            return;\n        }\n    }\n    string removeOccurrences(string s, string part) {\n        removeOccurrences(s, part, 0);\n        return s;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-occurrences-of-a-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923556980,
            "question_id": 2021,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679999856,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/923556980/",
            "is_pending": "Not Pending",
            "title": "Remove All Occurrences of a Substring",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    void removeOccurrences(string &s, string part, int strInd)\n    {\n        strInd = s.find(part);\n        if (strInd != string::npos)\n        {\n            s.erase(strInd, part.length());\n            strInd = s.find(part);\n            removeOccurrences(s, part, strInd);\n        }\n        else\n        {\n            return;\n        }\n    }\n    string removeOccurrences(string s, string part) {\n        removeOccurrences(s, part, 0);\n        return s;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-occurrences-of-a-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923556929,
            "question_id": 2021,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679999845,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/923556929/",
            "is_pending": "Not Pending",
            "title": "Remove All Occurrences of a Substring",
            "memory": "7.1 MB",
            "code": "class Solution {\npublic:\n    void removeOccurrences(string &s, string part, int strInd)\n    {\n        strInd = s.find(part);\n        if (strInd != string::npos)\n        {\n            s.erase(strInd, part.length());\n            strInd = s.find(part);\n            removeOccurrences(s, part, strInd);\n        }\n        else\n        {\n            return;\n        }\n    }\n    string removeOccurrences(string s, string part) {\n        removeOccurrences(s, part, 0);\n        return s;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-occurrences-of-a-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923556697,
            "question_id": 2021,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679999813,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/923556697/",
            "is_pending": "Not Pending",
            "title": "Remove All Occurrences of a Substring",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    void removeOccurrences(string &s, string part, int strInd)\n    {\n        strInd = s.find(part);\n        if (strInd != string::npos)\n        {\n            s.erase(strInd, part.length());\n            strInd = s.find(part);\n            removeOccurrences(s, part, strInd);\n        }\n        else\n        {\n            return;\n        }\n    }\n    string removeOccurrences(string s, string part) {\n        removeOccurrences(s, part, 0);\n        return s;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-occurrences-of-a-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923541478,
            "question_id": 125,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679997485,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/923541478/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string str, int start, int end)\n    {\n        if (start >= end)\n        {\n            if (end > 0 && str[start] == str[end - 1])\n                return true;\n            return false;\n        }\n        if (str[start] == str[end - 1])\n        {\n            return isPalindrome(str, start + 1, end - 1);\n        }\n        return false;\n    }\n    void removeAllNonAlphanumericCharacters(string &str)\n    {\n        for (int i = 0; i < str.length(); i++)\n        {\n            if ((!isalpha(str[i]) && !isdigit(str[i])) || str[i] == ' ')\n            {\n                str.erase(i, 1);\n                i--;\n            }\n        }\n        transform(str.begin(), str.end(), str.begin(), ::tolower);\n    }\n    bool isPalindrome(string s) {\n        if (s.length() == 1)\n    {\n        return true;\n    }\n    removeAllNonAlphanumericCharacters(s);\n    if (s.length() == 0)\n    {\n        return true;\n    }\n    int start = 0, end = s.length();\n    if (start == end - 1)\n        return true;\n    else\n    {\n        return isPalindrome(s, start, end);\n    }\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000",
            "title_slug": "valid-palindrome",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923521943,
            "question_id": 125,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679994630,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/923521943/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string str, int start, int end)\n    {\n        if (start >= end)\n        {\n            if (str[start] == str[end - 1])\n                return true;\n            return false;\n        }\n        if (str[start] == str[end - 1])\n        {\n            return isPalindrome(str, start + 1, end - 1);\n        }\n        return false;\n    }\n    void removeAllNonAlphanumericCharacters(string &str)\n    {\n        for (int i = 0; i < str.length(); i++)\n        {\n            if (!isalpha(str[i]) || str[i] == ' ')\n            {\n                str.erase(i, 1);\n                i--;\n            }\n        }\n        transform(str.begin(), str.end(), str.begin(), ::tolower);\n    }\n    bool isPalindrome(string s) {\n        if(s.length() == 1) {\n            return true;\n        }\n        removeAllNonAlphanumericCharacters(s);\n        if (s.length() == 0) return true;\n        int start = 0, end = s.length();\n        if(start == end - 1) {\n            return true;\n        } else {\n            return isPalindrome(s, start, end);\n        }\n    }\n};",
            "compare_result": "11111111111011111110110111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111111101111101111101110101111110111111111111111011101101111010111111111011101101011111111111110011000000",
            "title_slug": "valid-palindrome",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923519929,
            "question_id": 125,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679994340,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/923519929/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string str, int start, int end)\n    {\n        if (start >= end)\n        {\n            if (str[start] == str[end - 1])\n                return true;\n            return false;\n        }\n        if (str[start] == str[end - 1])\n        {\n            return isPalindrome(str, start + 1, end - 1);\n        }\n        return false;\n    }\n    void removeAllNonAlphanumericCharacters(string &str)\n    {\n        for (int i = 0; i < str.length(); i++)\n        {\n            if (!isalpha(str[i]) || str[i] == ' ')\n            {\n                str.erase(i, 1);\n                i--;\n            }\n        }\n        transform(str.begin(), str.end(), str.begin(), ::tolower);\n    }\n    bool isPalindrome(string s) {\n        if(s.length() == 1) {\n            return true;\n        }\n        removeAllNonAlphanumericCharacters(s);\n        int start = 0, end = s.length();\n        if(start == end - 1) {\n            return true;\n        } else {\n            return isPalindrome(s, start, end);\n        }\n    }\n};",
            "compare_result": "11111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-palindrome",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923482210,
            "question_id": 125,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679988368,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/923482210/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string str, int start, int end)\n    {\n        if (start >= end)\n        {\n            if (str[start] == str[end - 1])\n                return true;\n            return false;\n        }\n        if (str[start] == str[end - 1])\n        {\n            return isPalindrome(str, start + 1, end - 1);\n        }\n        return false;\n    }\n    void removeAllNonAlphanumericCharacters(string &str)\n    {\n        for (int i = 0; i < str.length(); i++)\n        {\n            if (!isalpha(str[i]) || str[i] == ' ')\n            {\n                str.erase(i, 1);\n                i--;\n            }\n        }\n        transform(str.begin(), str.end(), str.begin(), ::tolower);\n    }\n    bool isPalindrome(string s) {\n        removeAllNonAlphanumericCharacters(s);\n        int start = 0, end = s.length();\n        if(end == 0) {\n            return true;\n        } else {\n            return isPalindrome(s, start, end);\n        }\n    }\n};",
            "compare_result": "11110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-palindrome",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923414874,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679979160,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "75 ms",
            "url": "/submissions/detail/923414874/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "181.4 MB",
            "code": "class Solution {\npublic:\n    void addTwoStrNumbers(string str1, string str2, int l1, int l2, string &finalStr, int carry)\n    {\n        int num = 0;\n        if (l1 <= 0 && l2 <= 0)\n        {\n            if (carry > 0)\n            {\n                finalStr.append(to_string(carry));\n            }\n            reverse(finalStr.begin(), finalStr.end());\n            return;\n        }\n        else\n        {\n            int n1 = l1 > 0 ? (int)(str1[l1 - 1] - '0') : 0;\n            int n2 = l2 > 0 ? (int)(str2[l2 - 1] - '0') : 0;\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            addTwoStrNumbers(str1, str2, l1 - 1, l2 - 1, finalStr, carry);\n        }\n    }\n    string addStrings(string num1, string num2) {\n        int l1 = num1.length();\n        int l2 = num2.length();\n        string finalStr = \"\";\n        int carry = 0;\n        addTwoStrNumbers(num1, num2, l1, l2, finalStr, carry);\n        return finalStr;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923414260,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679979074,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "44 ms",
            "url": "/submissions/detail/923414260/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "181.4 MB",
            "code": "class Solution {\npublic:\n    void addTwoStrNumbers(string str1, string str2, int l1, int l2, string &finalStr, int carry)\n    {\n        int num = 0;\n        if (l1 <= 0 && l2 <= 0)\n        {\n            if (carry > 0)\n            {\n                finalStr.append(to_string(carry));\n            }\n            reverse(finalStr.begin(), finalStr.end());\n            return;\n        }\n        else\n        {\n            int n1 = l1 > 0 ? (int)(str1[l1 - 1] - '0') : 0;\n            int n2 = l2 > 0 ? (int)(str2[l2 - 1] - '0') : 0;\n            if(n1 < 0) n1 = 0;\n            if(n2 < 0) n2 = 0;\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            addTwoStrNumbers(str1, str2, l1 - 1, l2 - 1, finalStr, carry);\n        }\n    }\n    string addStrings(string num1, string num2) {\n        int l1 = num1.length();\n        int l2 = num2.length();\n        string finalStr = \"\";\n        int carry = 0;\n        addTwoStrNumbers(num1, num2, l1, l2, finalStr, carry);\n        return finalStr;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 923414146,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679979060,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "80 ms",
            "url": "/submissions/detail/923414146/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "181.4 MB",
            "code": "class Solution {\npublic:\n    void addTwoStrNumbers(string str1, string str2, int l1, int l2, string &finalStr, int carry)\n    {\n        int num = 0;\n        if (l1 <= 0 && l2 <= 0)\n        {\n            if (carry > 0)\n            {\n                finalStr.append(to_string(carry));\n            }\n            reverse(finalStr.begin(), finalStr.end());\n            return;\n        }\n        else\n        {\n            int n1 = l1 > 0 ? (int)(str1[l1 - 1] - '0') : 0;\n            int n2 = l2 > 0 ? (int)(str2[l2 - 1] - '0') : 0;\n            if(n1 < 0) n1 = 0;\n            if(n2 < 0) n2 = 0;\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            addTwoStrNumbers(str1, str2, l1 - 1, l2 - 1, finalStr, carry);\n        }\n    }\n    string addStrings(string num1, string num2) {\n        int l1 = num1.length();\n        int l2 = num2.length();\n        string finalStr = \"\";\n        int carry = 0;\n        addTwoStrNumbers(num1, num2, l1, l2, finalStr, carry);\n        return finalStr;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922950020,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679913644,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/922950020/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "6.9 MB",
            "code": "class Solution {\npublic:\n    string addTwoStrNumbers(string &str1, string &str2)\n    {\n        string finalStr;\n        int l1 = str1.length();\n        int l2 = str2.length();\n\n        int num, carry = 0;\n        while (l1 > 0 && l2 > 0)\n        {\n            int n1 = (int)(str1[l1 - 1] - '0');\n            int n2 = (int)(str2[l2 - 1] - '0');\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            l1--, l2--;\n        }\n        while (l1 > 0)\n        {\n            int n = ((int)(str1[l1 - 1] - '0') + carry) % 10;\n            carry = ((int)(str1[l1 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l1--;\n        }\n        while (l2 > 0)\n        {\n            int n = ((int)(str2[l2 - 1] - '0') + carry) % 10;\n            carry = ((int)(str2[l2 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l2--;\n        }\n        if (carry > 0)\n        {\n            finalStr.append(to_string(carry));\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n    string addStrings(string num1, string num2) {\n        return addTwoStrNumbers(num1, num2);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922949874,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679913622,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/922949874/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "6.8 MB",
            "code": "class Solution {\npublic:\n    string addTwoStrNumbers(string &str1, string &str2)\n    {\n        string finalStr;\n        int l1 = str1.length();\n        int l2 = str2.length();\n\n        int num, carry = 0;\n        while (l1 > 0 && l2 > 0)\n        {\n            int n1 = (int)(str1[l1 - 1] - '0');\n            int n2 = (int)(str2[l2 - 1] - '0');\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            l1--, l2--;\n        }\n        while (l1 > 0)\n        {\n            int n = ((int)(str1[l1 - 1] - '0') + carry) % 10;\n            carry = ((int)(str1[l1 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l1--;\n        }\n        while (l2 > 0)\n        {\n            int n = ((int)(str2[l2 - 1] - '0') + carry) % 10;\n            carry = ((int)(str2[l2 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l2--;\n        }\n        if (carry > 0)\n        {\n            finalStr.append(to_string(carry));\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n    string addStrings(string num1, string num2) {\n        return addTwoStrNumbers(num1, num2);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922949785,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679913608,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/922949785/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "6.8 MB",
            "code": "class Solution {\npublic:\n    string addTwoStrNumbers(string &str1, string &str2)\n    {\n        string finalStr;\n        int l1 = str1.length();\n        int l2 = str2.length();\n\n        int num, carry = 0;\n        while (l1 > 0 && l2 > 0)\n        {\n            int n1 = (int)(str1[l1 - 1] - '0');\n            int n2 = (int)(str2[l2 - 1] - '0');\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            l1--, l2--;\n        }\n        while (l1 > 0)\n        {\n            int n = ((int)(str1[l1 - 1] - '0') + carry) % 10;\n            carry = ((int)(str1[l1 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l1--;\n        }\n        while (l2 > 0)\n        {\n            int n = ((int)(str2[l2 - 1] - '0') + carry) % 10;\n            carry = ((int)(str2[l2 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l2--;\n        }\n        if (carry > 0)\n        {\n            finalStr.append(to_string(carry));\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n    string addStrings(string num1, string num2) {\n        return addTwoStrNumbers(num1, num2);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922949685,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679913592,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/922949685/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "6.8 MB",
            "code": "class Solution {\npublic:\n    string addTwoStrNumbers(string &str1, string &str2)\n    {\n        string finalStr;\n        int l1 = str1.length();\n        int l2 = str2.length();\n\n        int num, carry = 0;\n        while (l1 > 0 && l2 > 0)\n        {\n            int n1 = (int)(str1[l1 - 1] - '0');\n            int n2 = (int)(str2[l2 - 1] - '0');\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            l1--, l2--;\n        }\n        while (l1 > 0)\n        {\n            int n = ((int)(str1[l1 - 1] - '0') + carry) % 10;\n            carry = ((int)(str1[l1 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l1--;\n        }\n        while (l2 > 0)\n        {\n            int n = ((int)(str2[l2 - 1] - '0') + carry) % 10;\n            carry = ((int)(str2[l2 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l2--;\n        }\n        if (carry > 0)\n        {\n            finalStr.append(to_string(carry));\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n    string addStrings(string num1, string num2) {\n        return addTwoStrNumbers(num1, num2);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922949614,
            "question_id": 415,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year",
            "timestamp": 1679913580,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/922949614/",
            "is_pending": "Not Pending",
            "title": "Add Strings",
            "memory": "6.8 MB",
            "code": "class Solution {\npublic:\n    string addTwoStrNumbers(string &str1, string &str2)\n    {\n        string finalStr;\n        int l1 = str1.length();\n        int l2 = str2.length();\n\n        int num, carry = 0;\n        while (l1 > 0 && l2 > 0)\n        {\n            int n1 = (int)(str1[l1 - 1] - '0');\n            int n2 = (int)(str2[l2 - 1] - '0');\n            num = (((n1 + n2) % 10) + carry) % 10;\n            carry = ((n1 + n2) + carry) / 10;\n            string strAdd = to_string(num);\n            finalStr.append(strAdd);\n            l1--, l2--;\n        }\n        while (l1 > 0)\n        {\n            int n = ((int)(str1[l1 - 1] - '0') + carry) % 10;\n            carry = ((int)(str1[l1 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l1--;\n        }\n        while (l2 > 0)\n        {\n            int n = ((int)(str2[l2 - 1] - '0') + carry) % 10;\n            carry = ((int)(str2[l2 - 1] - '0') + carry) / 10;\n            finalStr.append(to_string(n));\n            l2--;\n        }\n        if (carry > 0)\n        {\n            finalStr.append(to_string(carry));\n        }\n        reverse(finalStr.begin(), finalStr.end());\n        return finalStr;\n    }\n    string addStrings(string num1, string num2) {\n        return addTwoStrNumbers(num1, num2);\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922454593,
            "question_id": 17,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679838360,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/922454593/",
            "is_pending": "Not Pending",
            "title": "Letter Combinations of a Phone Number",
            "memory": "6.4 MB",
            "code": "class Solution {\npublic:\n    void solve(int index, vector<string>& ans, string output, vector<string>& mapping, string digits) {\n        if(index >= digits.length()) {\n            ans.push_back(output);\n            return;\n        }\n        \n        int digit = digits[index] - '0';\n        string value = mapping[digit];\n        for(int i=0; i<value.length(); i++) {\n            char ch = value[i];\n            output.push_back(ch);\n            solve(index+1, ans, output, mapping, digits);\n            output.pop_back();\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        int index = 0;\n        vector<string> ans;\n        string output = \"\";\n        if(digits.length() == 0) {\n            return ans;\n        }\n        vector<string> mapping(10);\n        mapping[2] = \"abc\";\n        mapping[3] = \"def\";\n        mapping[4] = \"ghi\";\n        mapping[5] = \"jkl\";\n        mapping[6] = \"mno\";\n        mapping[7] = \"pqrs\";\n        mapping[8] = \"tuv\";\n        mapping[9] = \"wxyz\";\n        \n        solve(index, ans, output, mapping, digits);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111",
            "title_slug": "letter-combinations-of-a-phone-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922454471,
            "question_id": 17,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679838342,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/922454471/",
            "is_pending": "Not Pending",
            "title": "Letter Combinations of a Phone Number",
            "memory": "6.5 MB",
            "code": "class Solution {\npublic:\n    void solve(int index, vector<string>& ans, string output, vector<string>& mapping, string digits) {\n        if(index >= digits.length()) {\n            ans.push_back(output);\n            return;\n        }\n        \n        int digit = digits[index] - '0';\n        string value = mapping[digit];\n        for(int i=0; i<value.length(); i++) {\n            char ch = value[i];\n            output.push_back(ch);\n            solve(index+1, ans, output, mapping, digits);\n            output.pop_back();\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        int index = 0;\n        vector<string> ans;\n        string output = \"\";\n        if(digits.length() == 0) {\n            return ans;\n        }\n        vector<string> mapping(10);\n        mapping[2] = \"abc\";\n        mapping[3] = \"def\";\n        mapping[4] = \"ghi\";\n        mapping[5] = \"jkl\";\n        mapping[6] = \"mno\";\n        mapping[7] = \"pqrs\";\n        mapping[8] = \"tuv\";\n        mapping[9] = \"wxyz\";\n        \n        solve(index, ans, output, mapping, digits);\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111",
            "title_slug": "letter-combinations-of-a-phone-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922454016,
            "question_id": 17,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679838280,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/922454016/",
            "is_pending": "Not Pending",
            "title": "Letter Combinations of a Phone Number",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    void solve(int index, vector<string>& ans, string output, vector<string>& mapping, string digits) {\n        if(index >= digits.length()) {\n            ans.push_back(output);\n            return;\n        }\n        \n        int digit = digits[index] - '0';\n        string value = mapping[digit];\n        for(int i=0; i<value.length(); i++) {\n            char ch = value[i];\n            output.push_back(ch);\n            solve(index+1, ans, output, mapping, digits);\n            output.pop_back();\n        }\n    }\n    vector<string> letterCombinations(string digits) {\n        int index = 0;\n        vector<string> ans;\n        string output = \"\";\n        vector<string> mapping(10);\n        mapping[2] = \"abc\";\n        mapping[3] = \"def\";\n        mapping[4] = \"ghi\";\n        mapping[5] = \"jkl\";\n        mapping[6] = \"mno\";\n        mapping[7] = \"pqrs\";\n        mapping[8] = \"tuv\";\n        mapping[9] = \"wxyz\";\n        \n        solve(index, ans, output, mapping, digits);\n        return ans;\n    }\n};",
            "compare_result": "1011111111111111111111111",
            "title_slug": "letter-combinations-of-a-phone-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922417620,
            "question_id": 22,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679833420,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/922417620/",
            "is_pending": "Not Pending",
            "title": "Generate Parentheses",
            "memory": "15.6 MB",
            "code": "class Solution {\npublic:\n    void solve(vector<string>& ans, int open, int close, string output) {\n        if(open == 0 && close == 0) {\n            ans.push_back(output);\n            return;\n        }\n        if(open > 0) {\n            output.push_back('(');\n            solve(ans, open-1, close, output);\n            output.pop_back();\n        }\n        if(close > open) {\n            output.push_back(')');\n            solve(ans, open, close-1, output);\n            output.pop_back();\n        }\n    }\n    vector<string> generateParenthesis(int n) {\n        int open = n, close = n;\n        string output = \"\";\n        vector<string> ans;\n        solve(ans, open, close, output);\n        return ans;\n    }\n};",
            "compare_result": "11111111",
            "title_slug": "generate-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922219437,
            "question_id": 51,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679807382,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "9 ms",
            "url": "/submissions/detail/922219437/",
            "is_pending": "Not Pending",
            "title": "N-Queens",
            "memory": "8 MB",
            "code": "class Solution {\npublic:\n    unordered_map<int, bool> rowCheck;\n    unordered_map<int, bool> upperLeftDiagonalCheck;\n    unordered_map<int, bool> bottomLeftDiagonalCheck;\n    \n    void storeSolution(vector<vector<char>> &board, int n, vector<vector<string>>& ans) {\n        vector<string> temp;\n        for (int i = 0; i < n; i++)\n        {\n            string output = \"\";\n            for (int j = 0; j < n; j++)\n            {\n                output.push_back(board[i][j]);\n            }\n            temp.push_back(output);\n        }\n        ans.push_back(temp);\n    }\n    bool isSafe(int row, int col, vector<vector<char>> &board, int n)\n    {\n        if (rowCheck[row] == true)\n        {\n            return false;\n        }\n        if (upperLeftDiagonalCheck[n - 1 + col - row] == true)\n        {\n            return false;\n        }\n        if (bottomLeftDiagonalCheck[row + col] == true)\n        {\n            return false;\n        }\n        return true;\n    }\n    void solve(vector<vector<char>> &board, int col, int n, vector<vector<string>>& ans)\n    {\n        // Base case\n        if (col >= n)\n        {\n            storeSolution(board, n, ans);\n            return;\n        }\n\n        // Solve 1 case, else everthing recursion will handle\n        for (int row = 0; row < n; row++)\n        {\n            if (isSafe(row, col, board, n))\n            {\n                board[row][col] = 'Q';\n                rowCheck[row] = true;\n                upperLeftDiagonalCheck[n - 1 + col - row] = true;\n                bottomLeftDiagonalCheck[row + col] = true;\n\n                solve(board, col + 1, n, ans);\n\n                board[row][col] = '.';\n                rowCheck[row] = false;\n                upperLeftDiagonalCheck[n - 1 + col - row] = false;\n                bottomLeftDiagonalCheck[row + col] = false;\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> ans;\n        vector<vector<char>> board(n, vector<char>(n, '.'));\n        int col = 0;\n        solve(board, col, n, ans);\n        return ans;\n    }\n};",
            "compare_result": "111111111",
            "title_slug": "n-queens",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922219281,
            "question_id": 51,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679807364,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "14 ms",
            "url": "/submissions/detail/922219281/",
            "is_pending": "Not Pending",
            "title": "N-Queens",
            "memory": "8 MB",
            "code": "class Solution {\npublic:\n    unordered_map<int, bool> rowCheck;\n    unordered_map<int, bool> upperLeftDiagonalCheck;\n    unordered_map<int, bool> bottomLeftDiagonalCheck;\n    \n    void storeSolution(vector<vector<char>> &board, int n, vector<vector<string>>& ans) {\n        vector<string> temp;\n        for (int i = 0; i < n; i++)\n        {\n            string output = \"\";\n            for (int j = 0; j < n; j++)\n            {\n                output.push_back(board[i][j]);\n            }\n            temp.push_back(output);\n        }\n        ans.push_back(temp);\n    }\n    bool isSafe(int row, int col, vector<vector<char>> &board, int n)\n    {\n        if (rowCheck[row] == true)\n        {\n            return false;\n        }\n        if (upperLeftDiagonalCheck[n - 1 + col - row] == true)\n        {\n            return false;\n        }\n        if (bottomLeftDiagonalCheck[row + col] == true)\n        {\n            return false;\n        }\n        return true;\n    }\n    void solve(vector<vector<char>> &board, int col, int n, vector<vector<string>>& ans)\n    {\n        // Base case\n        if (col >= n)\n        {\n            storeSolution(board, n, ans);\n            return;\n        }\n\n        // Solve 1 case, else everthing recursion will handle\n        for (int row = 0; row < n; row++)\n        {\n            if (isSafe(row, col, board, n))\n            {\n                board[row][col] = 'Q';\n                rowCheck[row] = true;\n                upperLeftDiagonalCheck[n - 1 + col - row] = true;\n                bottomLeftDiagonalCheck[row + col] = true;\n\n                solve(board, col + 1, n, ans);\n\n                board[row][col] = '.';\n                rowCheck[row] = false;\n                upperLeftDiagonalCheck[n - 1 + col - row] = false;\n                bottomLeftDiagonalCheck[row + col] = false;\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> ans;\n        vector<vector<char>> board(n, vector<char>(n, '.'));\n        int col = 0;\n        solve(board, col, n, ans);\n        return ans;\n    }\n};",
            "compare_result": "111111111",
            "title_slug": "n-queens",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922219182,
            "question_id": 51,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679807352,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/922219182/",
            "is_pending": "Not Pending",
            "title": "N-Queens",
            "memory": "7.9 MB",
            "code": "class Solution {\npublic:\n    unordered_map<int, bool> rowCheck;\n    unordered_map<int, bool> upperLeftDiagonalCheck;\n    unordered_map<int, bool> bottomLeftDiagonalCheck;\n    \n    void storeSolution(vector<vector<char>> &board, int n, vector<vector<string>>& ans) {\n        vector<string> temp;\n        for (int i = 0; i < n; i++)\n        {\n            string output = \"\";\n            for (int j = 0; j < n; j++)\n            {\n                output.push_back(board[i][j]);\n            }\n            temp.push_back(output);\n        }\n        ans.push_back(temp);\n    }\n    bool isSafe(int row, int col, vector<vector<char>> &board, int n)\n    {\n        if (rowCheck[row] == true)\n        {\n            return false;\n        }\n        if (upperLeftDiagonalCheck[n - 1 + col - row] == true)\n        {\n            return false;\n        }\n        if (bottomLeftDiagonalCheck[row + col] == true)\n        {\n            return false;\n        }\n        return true;\n    }\n    void solve(vector<vector<char>> &board, int col, int n, vector<vector<string>>& ans)\n    {\n        // Base case\n        if (col >= n)\n        {\n            storeSolution(board, n, ans);\n            return;\n        }\n\n        // Solve 1 case, else everthing recursion will handle\n        for (int row = 0; row < n; row++)\n        {\n            if (isSafe(row, col, board, n))\n            {\n                board[row][col] = 'Q';\n                rowCheck[row] = true;\n                upperLeftDiagonalCheck[n - 1 + col - row] = true;\n                bottomLeftDiagonalCheck[row + col] = true;\n\n                solve(board, col + 1, n, ans);\n\n                board[row][col] = '.';\n                rowCheck[row] = false;\n                upperLeftDiagonalCheck[n - 1 + col - row] = false;\n                bottomLeftDiagonalCheck[row + col] = false;\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> ans;\n        vector<vector<char>> board(n, vector<char>(n, '.'));\n        int col = 0;\n        solve(board, col, n, ans);\n        return ans;\n    }\n};",
            "compare_result": "111111111",
            "title_slug": "n-queens",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 922219115,
            "question_id": 51,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679807342,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "9 ms",
            "url": "/submissions/detail/922219115/",
            "is_pending": "Not Pending",
            "title": "N-Queens",
            "memory": "8.2 MB",
            "code": "class Solution {\npublic:\n    unordered_map<int, bool> rowCheck;\n    unordered_map<int, bool> upperLeftDiagonalCheck;\n    unordered_map<int, bool> bottomLeftDiagonalCheck;\n    \n    void storeSolution(vector<vector<char>> &board, int n, vector<vector<string>>& ans) {\n        vector<string> temp;\n        for (int i = 0; i < n; i++)\n        {\n            string output = \"\";\n            for (int j = 0; j < n; j++)\n            {\n                output.push_back(board[i][j]);\n            }\n            temp.push_back(output);\n        }\n        ans.push_back(temp);\n    }\n    bool isSafe(int row, int col, vector<vector<char>> &board, int n)\n    {\n        if (rowCheck[row] == true)\n        {\n            return false;\n        }\n        if (upperLeftDiagonalCheck[n - 1 + col - row] == true)\n        {\n            return false;\n        }\n        if (bottomLeftDiagonalCheck[row + col] == true)\n        {\n            return false;\n        }\n        return true;\n    }\n    void solve(vector<vector<char>> &board, int col, int n, vector<vector<string>>& ans)\n    {\n        // Base case\n        if (col >= n)\n        {\n            storeSolution(board, n, ans);\n            return;\n        }\n\n        // Solve 1 case, else everthing recursion will handle\n        for (int row = 0; row < n; row++)\n        {\n            if (isSafe(row, col, board, n))\n            {\n                board[row][col] = 'Q';\n                rowCheck[row] = true;\n                upperLeftDiagonalCheck[n - 1 + col - row] = true;\n                bottomLeftDiagonalCheck[row + col] = true;\n\n                solve(board, col + 1, n, ans);\n\n                board[row][col] = '.';\n                rowCheck[row] = false;\n                upperLeftDiagonalCheck[n - 1 + col - row] = false;\n                bottomLeftDiagonalCheck[row + col] = false;\n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> ans;\n        vector<vector<char>> board(n, vector<char>(n, '.'));\n        int col = 0;\n        solve(board, col, n, ans);\n        return ans;\n    }\n};",
            "compare_result": "111111111",
            "title_slug": "n-queens",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 921501799,
            "question_id": 179,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679688740,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/921501799/",
            "is_pending": "Not Pending",
            "title": "Largest Number",
            "memory": "11.4 MB",
            "code": "class Solution {\npublic:\n    static bool mycomp(string a, string b) {\n        string t1 = a+b, t2 = b+a;\n        return t1 > t2;\n    }\n    string largestNumber(vector<int>& nums) {\n        vector<string> snums;\n        for(auto i : nums) {\n            snums.push_back(to_string(i));\n        }\n        \n        sort(snums.begin(), snums.end(), mycomp);\n        \n        if(snums[0] == \"0\") return \"0\";\n        \n        string ans = \"\";\n        for(auto i : snums) {\n            ans += i;\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "largest-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 921501710,
            "question_id": 179,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679688725,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "14 ms",
            "url": "/submissions/detail/921501710/",
            "is_pending": "Not Pending",
            "title": "Largest Number",
            "memory": "11.6 MB",
            "code": "class Solution {\npublic:\n    static bool mycomp(string a, string b) {\n        string t1 = a+b, t2 = b+a;\n        return t1 > t2;\n    }\n    string largestNumber(vector<int>& nums) {\n        vector<string> snums;\n        for(auto i : nums) {\n            snums.push_back(to_string(i));\n        }\n        \n        sort(snums.begin(), snums.end(), mycomp);\n        \n        if(snums[0] == \"0\") return \"0\";\n        \n        string ans = \"\";\n        for(auto i : snums) {\n            ans += i;\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "largest-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 921047542,
            "question_id": 179,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679624781,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/921047542/",
            "is_pending": "Not Pending",
            "title": "Largest Number",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int partition(vector<string>& arr, int s, int e)\n    {\n        // Choose the pivot element\n        int pivotIndex = s;\n        string pivotElement = arr[s];\n\n        // Find the right place of pivot index\n        int count = 0;\n        for (int i = s + 1; i <= e; i++)\n        {\n            // if (pivotElement >= arr[i]) \n            if(stoi(pivotElement+arr[i]) >= stoi(arr[i]+pivotElement))\n            {\n                count++;\n            }\n        }\n\n        // Place the pivot element at it's right position\n        swap(arr[pivotIndex], arr[count + s]);\n        pivotIndex = count + s;\n\n        // Sort left and right side of pivot element\n        int i = s, j = e;\n        while (i < pivotIndex && j > pivotIndex)\n        {\n            // while (arr[i] < pivotElement)\n            while (stoi(arr[i]+pivotElement) < stoi(pivotElement+arr[i]))\n            {\n                i++;\n            }\n            // while (arr[j] > pivotElement)\n            while (stoi(arr[j]+pivotElement) > stoi(pivotElement+arr[j]))\n            {\n                j--;\n            }\n\n            // if you got the elements to swap then swap\n            if (i < pivotIndex && j > pivotIndex)\n            {\n                swap(arr[i], arr[j]);\n            }\n        }\n        return pivotIndex;\n    }\n\n    void quickSort(vector<string>& arr, int s, int e)\n    {\n        // base case: if s is greater than or equal to e then return\n        if(s>=e) {\n            return;\n        }\n        // Returns partition index around which all the left elements are smaller and right elements are bigger\n        int p = partition(arr, s, e);\n\n        // Pivot left side\n        quickSort(arr, s, p - 1);\n\n        // Pivot right side\n        quickSort(arr, p + 1, e);\n    }\n    string largestNumber(vector<int>& nums) {\n        vector<string> str;\n        for(int i=0; i<nums.size(); i++) {\n            str.push_back(to_string(nums[i]));\n        }\n        int s = 0, n = str.size();\n        int e = n - 1;\n        quickSort(str, s, e);\n        reverse(str.begin(), str.end());\n        string ans;\n        for(int i=0; i<str.size(); i++) {\n            ans.append(str[i]);\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "largest-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 920135159,
            "question_id": 6,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679492445,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/920135159/",
            "is_pending": "Not Pending",
            "title": "Zigzag Conversion",
            "memory": "10.7 MB",
            "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if(numRows == 1) return s;\n        vector<string> vec(numRows);\n        int row = 0, i=0;\n        bool direction = 1;\n\n        while(true) {\n            if(direction) {\n                while(row < numRows && i < s.length()) {\n                    vec[row++].push_back(s[i++]);\n                }\n                row = numRows-2;\n            }\n            else {\n                while(row >= 0 && i < s.length()) {\n                    vec[row--].push_back(s[i++]);\n                }\n                row = 1;\n            }\n            if(i >= s.length()) break;\n            direction = !direction;\n        }\n        string ans = \"\";\n        for(int k=0; k<vec.size(); k++) {\n            ans += vec[k];\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "zigzag-conversion",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 920134450,
            "question_id": 6,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679492364,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/920134450/",
            "is_pending": "Not Pending",
            "title": "Zigzag Conversion",
            "memory": "10.8 MB",
            "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if(numRows == 1) return s;\n        vector<string> vec(numRows);\n        int row = 0, i=0;\n        bool direction = 1;\n\n        while(true) {\n            if(direction) {\n                while(row < numRows && i < s.length()) {\n                    vec[row++].push_back(s[i++]);\n                }\n                row = numRows-2;\n            }\n            else {\n                while(row >= 0 && i < s.length()) {\n                    vec[row--].push_back(s[i++]);\n                }\n                row = 1;\n            }\n            if(i >= s.length()) break;\n            direction = !direction;\n        }\n        string ans = \"\";\n        for(int k=0; k<vec.size(); k++) {\n            ans += vec[k];\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "zigzag-conversion",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 920119999,
            "question_id": 6,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679490574,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/920119999/",
            "is_pending": "Not Pending",
            "title": "Zigzag Conversion",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        vector<string> vec(numRows);\n        int row = 0, i=0;\n        bool direction = 1;\n\n        while(true) {\n            if(direction) {\n                while(row < numRows && i < s.length()) {\n                    vec[row++].push_back(s[i++]);\n                }\n                row = numRows-2;\n            }\n            else {\n                while(row >= 0 && i < s.length()) {\n                    vec[row--].push_back(s[i++]);\n                }\n                row = 1;\n            }\n            if(i >= s.length()) break;\n            direction = !direction;\n        }\n        string ans = \"\";\n        for(int k=0; k<vec.size(); k++) {\n            ans += vec[k];\n        }\n        return ans;\n    }\n};",
            "compare_result": "11111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "zigzag-conversion",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 919432575,
            "question_id": 443,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679396672,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/919432575/",
            "is_pending": "Not Pending",
            "title": "String Compression",
            "memory": "8.9 MB",
            "code": "class Solution {\npublic:\n    int compress(vector<char>& s) {\n        char prev = s[0];\n        int index = 0;\n        int len = s.size();\n        int count = 1;\n        for(int i=1; i<len; i++) {\n            if(prev == s[i]) {\n                count++;\n            } else {\n                s[index++] = prev;\n                if(count > 9) {\n                    int start = index;\n                    while(count > 0) {\n                        int rem = count%10;\n                        s[index++] = rem + '0';\n                        count /= 10;\n                    }\n                    reverse(s.begin() + start, s.begin() + index);\n                } else if(count > 1) {\n                    s[index++] = count + '0';\n                }\n                prev = s[i];\n                count = 1;\n            }\n        }\n        s[index++] = prev;\n        if(count > 9) {\n            int start = index;\n            while(count) {\n                int rem = count%10;\n                s[index++] = rem + '0';\n                count /= 10;\n            }\n            reverse(s.begin() + start, s.begin() + index);\n        } else if(count > 1) {\n            s[index++] = count + '0';\n        }\n        return index;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "string-compression",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 919432469,
            "question_id": 443,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679396657,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/919432469/",
            "is_pending": "Not Pending",
            "title": "String Compression",
            "memory": "9.1 MB",
            "code": "class Solution {\npublic:\n    int compress(vector<char>& s) {\n        char prev = s[0];\n        int index = 0;\n        int len = s.size();\n        int count = 1;\n        for(int i=1; i<len; i++) {\n            if(prev == s[i]) {\n                count++;\n            } else {\n                s[index++] = prev;\n                if(count > 9) {\n                    int start = index;\n                    while(count > 0) {\n                        int rem = count%10;\n                        s[index++] = rem + '0';\n                        count /= 10;\n                    }\n                    reverse(s.begin() + start, s.begin() + index);\n                } else if(count > 1) {\n                    s[index++] = count + '0';\n                }\n                prev = s[i];\n                count = 1;\n            }\n        }\n        s[index++] = prev;\n        if(count > 9) {\n            int start = index;\n            while(count) {\n                int rem = count%10;\n                s[index++] = rem + '0';\n                count /= 10;\n            }\n            reverse(s.begin() + start, s.begin() + index);\n        } else if(count > 1) {\n            s[index++] = count + '0';\n        }\n        return index;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "string-compression",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 919285104,
            "question_id": 12,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679378802,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/919285104/",
            "is_pending": "Not Pending",
            "title": "Integer to Roman",
            "memory": "6 MB",
            "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string romanChar[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        int values[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string ans = \"\";\n        for(int i=0; i<13; i++) {\n            while(num >= values[i]) {\n                ans += romanChar[i];\n                num -= values[i];\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "integer-to-roman",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 919285005,
            "question_id": 12,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679378790,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "13 ms",
            "url": "/submissions/detail/919285005/",
            "is_pending": "Not Pending",
            "title": "Integer to Roman",
            "memory": "6 MB",
            "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string romanChar[] = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\n        int values[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        string ans = \"\";\n        for(int i=0; i<13; i++) {\n            while(num >= values[i]) {\n                ans += romanChar[i];\n                num -= values[i];\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "integer-to-roman",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 918738144,
            "question_id": 443,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679314175,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/918738144/",
            "is_pending": "Not Pending",
            "title": "String Compression",
            "memory": "9.2 MB",
            "code": "class Solution {\npublic:\n    int compress(vector<char>& chars) {\n        vector<char> vc;\n        int len = chars.size();\n        for(int i=0; i<len; i++) {\n            int count = 1;\n            while(i < len - 1 && chars[i] == chars[i+1]) {\n                count++;\n                i++;\n            }\n            if(count == 1) {\n                vc.push_back(chars[i]);\n            } else {\n                vc.push_back(chars[i]);\n                vector<int> tempVc;\n                while(count > 0) {\n                    int rem = count%10;\n                    tempVc.push_back(rem);\n                    count /= 10;\n                }\n                reverse(tempVc.begin(), tempVc.end());\n                for(int k=0; k<tempVc.size(); k++) {\n                    vc.push_back(tempVc[k] + '0');\n                }\n            }\n        }\n        chars = vc;\n        return vc.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "string-compression",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 918737916,
            "question_id": 443,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679314147,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/918737916/",
            "is_pending": "Not Pending",
            "title": "String Compression",
            "memory": "9.2 MB",
            "code": "class Solution {\npublic:\n    int compress(vector<char>& chars) {\n        vector<char> vc;\n        int len = chars.size();\n        for(int i=0; i<len; i++) {\n            int count = 1;\n            while(i < len - 1 && chars[i] == chars[i+1]) {\n                count++;\n                i++;\n            }\n            if(count == 1) {\n                vc.push_back(chars[i]);\n            } else {\n                vc.push_back(chars[i]);\n                vector<int> tempVc;\n                while(count > 0) {\n                    int rem = count%10;\n                    tempVc.push_back(rem);\n                    count /= 10;\n                }\n                reverse(tempVc.begin(), tempVc.end());\n                for(int k=0; k<tempVc.size(); k++) {\n                    vc.push_back(tempVc[k] + '0');\n                }\n            }\n        }\n        chars = vc;\n        return vc.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "string-compression",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 918460460,
            "question_id": 8,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679281856,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/918460460/",
            "is_pending": "Not Pending",
            "title": "String to Integer (atoi)",
            "memory": "7.1 MB",
            "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        int num = 0, i = 0, sign = 1;\n        \n        // Check if contains any leading spaces\n        while(s[i] == ' ') {\n            i++;\n        }\n        \n        // Check if contains a positive or neagtive sign\n        while(i < s.size() && (s[i] == '-' || s[i] == '+')) {\n            sign = s[i] == '-' ? -1 : 1;\n            ++i;\n            break;\n        }\n        \n        if(s[i] == '-' || s[i] == '+') {\n            return 0;\n        }\n        \n        // Check if contains numbers\n        while(i < s.size() && isdigit(s[i])) {\n            if(num > INT_MAX/10 || (num == INT_MAX/10 && s[i] > '7')) {\n                return sign == -1 ? INT_MIN : INT_MAX;\n            }\n            num = num  * 10 + (s[i] - '0');\n            ++i;\n        }\n        return num*sign;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "string-to-integer-atoi",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 918460322,
            "question_id": 8,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679281838,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "9 ms",
            "url": "/submissions/detail/918460322/",
            "is_pending": "Not Pending",
            "title": "String to Integer (atoi)",
            "memory": "7.1 MB",
            "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        int num = 0, i = 0, sign = 1;\n        \n        // Check if contains any leading spaces\n        while(s[i] == ' ') {\n            i++;\n        }\n        \n        // Check if contains a positive or neagtive sign\n        while(i < s.size() && (s[i] == '-' || s[i] == '+')) {\n            sign = s[i] == '-' ? -1 : 1;\n            ++i;\n            break;\n        }\n        \n        if(s[i] == '-' || s[i] == '+') {\n            return 0;\n        }\n        \n        // Check if contains numbers\n        while(i < s.size() && isdigit(s[i])) {\n            if(num > INT_MAX/10 || (num == INT_MAX/10 && s[i] > '7')) {\n                return sign == -1 ? INT_MIN : INT_MAX;\n            }\n            num = num  * 10 + (s[i] - '0');\n            ++i;\n        }\n        return num*sign;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "string-to-integer-atoi",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 918459855,
            "question_id": 8,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679281777,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/918459855/",
            "is_pending": "Not Pending",
            "title": "String to Integer (atoi)",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        int num = 0, i = 0, sign = 1;\n        \n        // Check if contains any leading spaces\n        while(s[i] == ' ') {\n            i++;\n        }\n        \n        // Check if contains a positive or neagtive sign\n        while(i < s.size() && (s[i] == '-' || s[i] == '+')) {\n            sign = s[i] == '-' ? -1 : 1;\n            ++i;\n            break;\n        }\n        \n        if(s[i] == '-' || s[i] == '+') {\n            return 0;\n        }\n        \n        // Check if contains numbers\n        while(i < s.size() && isdigit(s[i])) {\n            if(num > INT_MAX/10 || (num == INT_MAX && s[i] > '7')) {\n                return sign == -1 ? INT_MIN : INT_MAX;\n            }\n            num = num  * 10 + (s[i] - '0');\n            ++i;\n        }\n        return num*sign;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "string-to-integer-atoi",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 918292837,
            "question_id": 8,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679251890,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/918292837/",
            "is_pending": "Not Pending",
            "title": "String to Integer (atoi)",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        int num = 0, i = 0, sign = 1;\n        \n        // Check if contains any leading spaces\n        while(s[i] == ' ') {\n            i++;\n        }\n        \n        // Check if contains a positive or neagtive sign\n        while(i < s.size() && (s[i] == '-' || s[i] == '+')) {\n            sign = s[i] == '-' ? -1 : 1;\n            i++;\n        }\n        \n        // Check if contains numbers\n        while(i < s.size() && isdigit(s[i])) {\n            if(num > INT_MAX/10 || (num > INT_MAX && s[i] < '7')) {\n                return sign == 1 ? INT_MAX : INT_MIN;\n            }\n            num = num  * 10 + (s[i] - '0');\n            i++;\n        }\n        return num*sign;\n    }\n};",
            "compare_result": "1111111001111111111111111111110011111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "string-to-integer-atoi",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 918292328,
            "question_id": 8,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679251822,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/918292328/",
            "is_pending": "Not Pending",
            "title": "String to Integer (atoi)",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        int num = 0, i = 0, sign = 1;\n        \n        // Check if contains any leading spaces\n        while(s[i] == ' ') {\n            i++;\n        }\n        \n        // Check if contains a positive or neagtive sign\n        while(i < s.size() && (s[i] == '-' || s[i] == '+')) {\n            sign = s[i] == '-' ? -1 : 1;\n            i++;\n        }\n        \n        // Check if contains numbers\n        while(i < s.size() && isdigit(s[i])) {\n            if(num > INT_MAX/10 || (num > INT_MAX && s[i] < '7')) {\n                return num > INT_MAX/10 ? INT_MAX : INT_MIN;\n            }\n            num = num  * 10 + (s[i] - '0');\n            i++;\n        }\n        return num*sign;\n    }\n};",
            "compare_result": "1111011001111111111111111111110011111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "string-to-integer-atoi",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917571729,
            "question_id": 5,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679156065,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2430 ms",
            "url": "/submissions/detail/917571729/",
            "is_pending": "Not Pending",
            "title": "Longest Palindromic Substring",
            "memory": "489.1 MB",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string& s,int i,int j) {\n        while(i<j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n            i++, j--;\n        }\n        return true;\n    }\n    string longestPalindrome(string s) {\n        string ans = \"\";\n        for(int i=0; i<s.size(); i++) {\n            for(int j=i; j<s.size(); j++) {\n                if(isPalindrome(s,i,j)) {\n                    string checkStr = s.substr(i,j-i+1);\n                    ans = checkStr.size() > ans.size() ? checkStr : ans;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-palindromic-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917571201,
            "question_id": 5,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679156011,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2444 ms",
            "url": "/submissions/detail/917571201/",
            "is_pending": "Not Pending",
            "title": "Longest Palindromic Substring",
            "memory": "489.2 MB",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string& s,int i,int j) {\n        while(i<j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n            i++, j--;\n        }\n        return true;\n    }\n    string longestPalindrome(string s) {\n        string ans = \"\";\n        for(int i=0; i<s.size(); i++) {\n            for(int j=i; j<s.size(); j++) {\n                if(isPalindrome(s,i,j)) {\n                    string checkStr = s.substr(i,j-i+1);\n                    ans = checkStr.size() > ans.size() ? checkStr : ans;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-palindromic-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917569961,
            "question_id": 5,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679155892,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/917569961/",
            "is_pending": "Not Pending",
            "title": "Longest Palindromic Substring",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string s,int i,int j) {\n        while(i<j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n            i++, j--;\n        }\n        return true;\n    }\n    string longestPalindrome(string s) {\n        string ans = \"\";\n        for(int i=0; i<s.size(); i++) {\n            for(int j=i; j<s.size(); j++) {\n                if(isPalindrome(s,i,j)) {\n                    string checkStr = s.substr(i,j-i+1);\n                    ans = checkStr.size() > ans.size() ? checkStr : ans;\n                }\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "longest-palindromic-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917567381,
            "question_id": 5,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679155643,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/917567381/",
            "is_pending": "Not Pending",
            "title": "Longest Palindromic Substring",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isPalindrome(string s,int i,int j) {\n        while(i<j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n            i++, j--;\n        }\n        return true;\n    }\n    string longestPalindrome(string s) {\n        vector<string> allPalindromicSubStr;\n        for(int i=0; i<s.size(); i++) {\n            for(int j=i; j<s.size(); j++) {\n                if(isPalindrome(s,i,j)) {\n                    string check = s.substr(i,j-i+1);\n                    if(std::find(allPalindromicSubStr.begin(), allPalindromicSubStr.end(), check) == allPalindromicSubStr.end()) {\n                        allPalindromicSubStr.push_back(check);\n                    }\n                }\n            }\n        }\n        string ans = \"\";\n        for(auto a:allPalindromicSubStr) {\n            if(a.length() > ans.length()) {\n                ans = a;\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "longest-palindromic-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917529300,
            "question_id": 49,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679153497,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "125 ms",
            "url": "/submissions/detail/917529300/",
            "is_pending": "Not Pending",
            "title": "Group Anagrams",
            "memory": "41.7 MB",
            "code": "class Solution {\npublic:\n    std::array<int, 256> hash(string str) {\n        std::array<int, 256> hashArr = {0};\n        for(int i=0; i<str.size(); i++) {\n            hashArr[str[i]]++;\n        }\n        return hashArr;\n    }\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n//         map<string, vector<string>> mp;\n        \n//         for(auto str: strs) {\n//             string s = str;\n//             sort(s.begin(), s.end());\n//             mp[s].push_back(str);\n//         }\n        \n//         vector<vector<string>> ans;\n//         for (auto ele : mp) {\n//              ans.push_back(ele.second);\n//         }\n//         return ans;\n        \n        map<std::array<int,256>, vector<string>> mp;\n        \n        for(auto str: strs) {\n            mp[hash(str)].push_back(str);\n        }\n        \n        vector<vector<string>> ans;\n        for (auto ele : mp) {\n             ans.push_back(ele.second);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "group-anagrams",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917528969,
            "question_id": 49,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679153482,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "133 ms",
            "url": "/submissions/detail/917528969/",
            "is_pending": "Not Pending",
            "title": "Group Anagrams",
            "memory": "41.8 MB",
            "code": "class Solution {\npublic:\n    std::array<int, 256> hash(string str) {\n        std::array<int, 256> hashArr = {0};\n        for(int i=0; i<str.size(); i++) {\n            hashArr[str[i]]++;\n        }\n        return hashArr;\n    }\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n//         map<string, vector<string>> mp;\n        \n//         for(auto str: strs) {\n//             string s = str;\n//             sort(s.begin(), s.end());\n//             mp[s].push_back(str);\n//         }\n        \n//         vector<vector<string>> ans;\n//         for (auto ele : mp) {\n//              ans.push_back(ele.second);\n//         }\n//         return ans;\n        \n        map<std::array<int,256>, vector<string>> mp;\n        \n        for(auto str: strs) {\n            mp[hash(str)].push_back(str);\n        }\n        \n        vector<vector<string>> ans;\n        for (auto ele : mp) {\n             ans.push_back(ele.second);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "group-anagrams",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917414345,
            "question_id": 49,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679145996,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "42 ms",
            "url": "/submissions/detail/917414345/",
            "is_pending": "Not Pending",
            "title": "Group Anagrams",
            "memory": "21 MB",
            "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<string, vector<string>> mp;\n        \n        for(auto str: strs) {\n            string s = str;\n            sort(s.begin(), s.end());\n            mp[s].push_back(str);\n        }\n        \n        vector<vector<string>> ans;\n        for (auto ele : mp) {\n             ans.push_back(ele.second);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "group-anagrams",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917414188,
            "question_id": 49,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679145972,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "54 ms",
            "url": "/submissions/detail/917414188/",
            "is_pending": "Not Pending",
            "title": "Group Anagrams",
            "memory": "21 MB",
            "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<string, vector<string>> mp;\n        \n        for(auto str: strs) {\n            string s = str;\n            sort(s.begin(), s.end());\n            mp[s].push_back(str);\n        }\n        \n        vector<vector<string>> ans;\n        for (auto ele : mp) {\n             ans.push_back(ele.second);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "group-anagrams",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917413799,
            "question_id": 49,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679145912,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "46 ms",
            "url": "/submissions/detail/917413799/",
            "is_pending": "Not Pending",
            "title": "Group Anagrams",
            "memory": "22 MB",
            "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<string, vector<string>> mp;\n        \n        for(auto str: strs) {\n            string s = str;\n            sort(s.begin(), s.end());\n            mp[s].push_back(str);\n        }\n        \n        vector<vector<string>> ans;\n        for (auto ele : mp) {\n            vector<string> vec = ele.second;\n             ans.push_back(vec);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "group-anagrams",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917413727,
            "question_id": 49,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679145899,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "55 ms",
            "url": "/submissions/detail/917413727/",
            "is_pending": "Not Pending",
            "title": "Group Anagrams",
            "memory": "22 MB",
            "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<string, vector<string>> mp;\n        \n        for(auto str: strs) {\n            string s = str;\n            sort(s.begin(), s.end());\n            mp[s].push_back(str);\n        }\n        \n        vector<vector<string>> ans;\n        for (auto ele : mp) {\n            vector<string> vec = ele.second;\n             ans.push_back(vec);\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "group-anagrams",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917399751,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679143631,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/917399751/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "6.2 MB",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        // Add all frequencies of all the characters from string into hash\n        for(int i=0; i<s.size(); i++) {\n            hash[s[i] - 'a']++;\n        }\n        \n        // Now find the max frequency character\n        char max_freq_char;\n        int max_freq = INT_MIN;\n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        // Now place the most freq char on all adjacent places\n        int index = 0;\n        while(max_freq > 0 && index < s.size()) {\n            s[index] = max_freq_char;\n            index += 2;\n            max_freq--;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        // Now as the most freq char is placed make its freq as 0 in hash table\n        hash[max_freq_char - 'a'] = 0;\n        \n        // Now place all other characters on remaining adjacent places\n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index >= s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917399690,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679143618,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/917399690/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "6.3 MB",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        // Add all frequencies of all the characters from string into hash\n        for(int i=0; i<s.size(); i++) {\n            hash[s[i] - 'a']++;\n        }\n        \n        // Now find the max frequency character\n        char max_freq_char;\n        int max_freq = INT_MIN;\n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        // Now place the most freq char on all adjacent places\n        int index = 0;\n        while(max_freq > 0 && index < s.size()) {\n            s[index] = max_freq_char;\n            index += 2;\n            max_freq--;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        // Now as the most freq char is placed make its freq as 0 in hash table\n        hash[max_freq_char - 'a'] = 0;\n        \n        // Now place all other characters on remaining adjacent places\n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index >= s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917399603,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679143603,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/917399603/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "6.1 MB",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        // Add all frequencies of all the characters from string into hash\n        for(int i=0; i<s.size(); i++) {\n            hash[s[i] - 'a']++;\n        }\n        \n        // Now find the max frequency character\n        char max_freq_char;\n        int max_freq = INT_MIN;\n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        // Now place the most freq char on all adjacent places\n        int index = 0;\n        while(max_freq > 0 && index < s.size()) {\n            s[index] = max_freq_char;\n            index += 2;\n            max_freq--;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        // Now as the most freq char is placed make its freq as 0 in hash table\n        hash[max_freq_char - 'a'] = 0;\n        \n        // Now place all other characters on remaining adjacent places\n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index >= s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917398999,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679143503,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/917398999/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        // Add all frequencies of all the characters from string into hash\n        for(int i=0; i<s.size(); i++) {\n            hash[s[i] - 'a']++;\n        }\n        \n        // Now find the max frequency character\n        char max_freq_char;\n        int max_freq = INT_MIN;\n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        // Now place the most freq char on all adjacent places\n        int index = 0;\n        while(max_freq > 0 && index < s.size()) {\n            s[index] = max_freq_char;\n            index += 2;\n            max_freq--;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        // Now place all other characters on remaining adjacent places\n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index >= s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1101010001000001011011001001001001001001011001001001001001011000001001",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917398789,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679143469,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/917398789/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        // Add all frequencies of all the characters from string into hash\n        for(int i=0; i<s.size(); i++) {\n            hash[s[i] - 'a']++;\n        }\n        \n        // Now find the max frequency character\n        char max_freq_char;\n        int max_freq = INT_MIN;\n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        // Now place the most freq char on all adjacent places\n        int index = 0;\n        while(max_freq > 0 && index < s.size()) {\n            s[index] = max_freq_char;\n            index += 2;\n            max_freq--;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        // Now place all other characters on remaining adjacent places\n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index > s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1101010001000001011011001001001001001001011001001001001001011000001001",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917398726,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679143458,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/917398726/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        // Add all frequencies of all the characters from string into hash\n        for(int i=0; i<s.size(); i++) {\n            hash[s[i] - 'a']++;\n        }\n        \n        // Now find the max frequency character\n        char max_freq_char;\n        int max_freq = INT_MIN;\n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        // Now place the most freq char on all adjacent places\n        int index = 0;\n        while(max_freq > 0 && index < s.size()) {\n            s[index] = max_freq_char;\n            index += 2;\n            max_freq--;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        // Now place all other characters on remaining adjacent places\n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index > s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1101010001000001011011001001001001001001011001001001001001011000001001",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917389110,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679141778,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/917389110/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "6.2 MB",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        for(int i=0; i<s.size(); i++) {\n            hash[s[i]-'a']++;\n        }\n        \n        char max_freq_char;\n        int max_freq = INT_MIN;\n        \n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        int index = 0;\n        while(max_freq > 0 && index<s.size()) {\n            s[index] = max_freq_char;\n            max_freq--;\n            index += 2;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        hash[max_freq_char - 'a'] = 0;\n        \n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index >= s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 917389022,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679141764,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/917389022/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "6.2 MB",
            "code": "class Solution {\npublic:\n    string reorganizeString(string s) {\n        int hash[26] = {0};\n        \n        for(int i=0; i<s.size(); i++) {\n            hash[s[i]-'a']++;\n        }\n        \n        char max_freq_char;\n        int max_freq = INT_MIN;\n        \n        for(int i=0; i<26; i++) {\n            if(hash[i] > max_freq) {\n                max_freq = hash[i];\n                max_freq_char = i + 'a';\n            }\n        }\n        \n        int index = 0;\n        while(max_freq > 0 && index<s.size()) {\n            s[index] = max_freq_char;\n            max_freq--;\n            index += 2;\n        }\n        \n        if(max_freq != 0) {\n            return \"\";\n        }\n        \n        hash[max_freq_char - 'a'] = 0;\n        \n        for(int i=0; i<26; i++) {\n            while(hash[i] > 0) {\n                index = index >= s.size() ? 1 : index;\n                s[index] = i + 'a';\n                hash[i]--;\n                index += 2;\n            }\n        }\n        return s;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 916690029,
            "question_id": 205,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679032480,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/916690029/",
            "is_pending": "Not Pending",
            "title": "Isomorphic Strings",
            "memory": "7 MB",
            "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        char hash[256] = {0};\n        char tIsVisited[256] = {0};\n        \n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] == 0 && tIsVisited[t[i]] != 1) {\n                hash[s[i]] = t[i];\n                tIsVisited[t[i]] = 1;\n            }\n        }\n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] != t[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "isomorphic-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 916689224,
            "question_id": 205,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679032371,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/916689224/",
            "is_pending": "Not Pending",
            "title": "Isomorphic Strings",
            "memory": "6.9 MB",
            "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        char hash[256] = {0};\n        char tIsVisited[256] = {0};\n        \n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] == 0 && tIsVisited[t[i]] != 1) {\n                hash[s[i]] = t[i];\n                tIsVisited[t[i]] = 1;\n            }\n        }\n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] != t[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "isomorphic-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 916688806,
            "question_id": 205,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1679032309,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/916688806/",
            "is_pending": "Not Pending",
            "title": "Isomorphic Strings",
            "memory": "7 MB",
            "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        char hash[256] = {0};\n        char tIsVisited[256] = {0};\n        \n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] == 0 && tIsVisited[t[i]] != 1) {\n                hash[s[i]] = t[i];\n                tIsVisited[t[i]] = 1;\n            }\n        }\n        for(int i=0; i<s.size(); i++) {\n            if(hash[s[i]] != t[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "isomorphic-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 916235640,
            "question_id": 67,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678967124,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/916235640/",
            "is_pending": "Not Pending",
            "title": "Add Binary",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    string reverseStr(string ans) {\n        int s=0, e=ans.length()-1;\n        while(s<e) {\n            swap(ans[s],ans[e]);\n            s++, e--;\n        }\n        return ans;\n    }\n    string addBinary(string num1, string num2) {\n        string ans = \"\";\n        int size_num1 = num1.length()-1;\n        int size_num2 = num2.length()-1;\n        int sum = 0;\n        int carry = 0;\n        while(size_num1 >= 0 || size_num2 >= 0 || carry == 1) {\n            int n1, n2;\n            if(size_num1 >= 0) {\n                n1 = (int)(num1[size_num1] - '0');\n            } else {\n                n1 = 0;\n            }\n            if(size_num2 >= 0) {\n                n2 = (int)(num2[size_num2] - '0');\n            } else {\n                n2 = 0;\n            }\n            sum = (n1 ^ n2) ^ carry;\n            n2 = n2 ^ carry;\n            carry = (n1 & n2);\n            ans.push_back(sum == 0 ? '0' : '1');\n            size_num1--, size_num2--;\n        }\n        if(carry == 1) ans.push_back('1');\n        return reverseStr(ans);\n    }\n};",
            "compare_result": "11111100110000100010101110111100100100110100101111100000010100010100001101111100001000110001010110011100100010100100101111111011101111011001000011000001111010111111111011110001100011010011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011",
            "title_slug": "add-binary",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 916175536,
            "question_id": 28,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678959688,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/916175536/",
            "is_pending": "Not Pending",
            "title": "Find the Index of the First Occurrence in a String",
            "memory": "6.2 MB",
            "code": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        size_t k = haystack.find(needle);\n          if(k == std::string::npos) {\n              return -1;\n          } else {\n              return k;\n          }\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-index-of-the-first-occurrence-in-a-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 916134954,
            "question_id": 778,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678953325,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/916134954/",
            "is_pending": "Not Pending",
            "title": "Reorganize String",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    vector<string> permute(string s, string answer, vector<string> ans)\n    {\n        if (s.length() == 0) {\n            return ans;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            for(int j=0; j<s.length(); j++) {\n                string str = s;\n                if(str[i] != str[j]) {\n                    str.erase(str.begin() + i);\n                    str.insert(j, 1, s[i]);\n                    if(find(ans.begin(), ans.end(), str) == ans.end())\n                        ans.push_back(str);\n                }\n            }\n        }\n        return ans;\n    }\n\n     bool twoAdjCharAreSame(string s) {\n         for(int i=1; i<s.length(); i++) {\n             if(s[i-1] == s[i]) {\n                 return true;\n             }\n         }\n         return false;\n     }\n    string reorganizeString(string s) {\n        string answer = \"\";\n        vector<string> ans;\n\n        // cout << \"\\nAll possible strings are : \";\n        ans = permute(s, answer, ans);\n        for(auto i: ans) {\n            // cout<<i<<\" \";\n            if(twoAdjCharAreSame(i)) {\n                // return \"\";\n                // cout<<\" Not valid \";\n                answer = \"\";\n                break;\n            } else {\n                return i;\n                // cout<<\" Valid \";\n                answer = i;\n                break;\n            }\n        }\n        return answer;\n    }\n};",
            "compare_result": "1101100101100100001100001100100100001001101001001100000000000000000000",
            "title_slug": "reorganize-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915542278,
            "question_id": 205,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678871262,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/915542278/",
            "is_pending": "Not Pending",
            "title": "Isomorphic Strings",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        map <char,char> mp;\n        for(int i=0; i<s.length(); i++) {\n            if(mp.find(s[i]) == mp.end()) {\n                mp.insert({s[i], t[i]});\n            }\n        }\n        vector<char> vec;\n        for (auto& [key, value]: mp) {\n            vec.push_back((char)value);\n        }\n        int len = 0;\n        for(int i=0; i<t.length(); i++) {\n            if(find(vec.begin(), vec.end(), t[i]) != vec.end()) {\n                len++;\n            }\n        }\n        if(t.length() == len) return true;\n        else return false;\n    }\n};",
            "compare_result": "11111101100011010001110101111101001110010001",
            "title_slug": "isomorphic-strings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915211442,
            "question_id": 345,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678820202,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/915211442/",
            "is_pending": "Not Pending",
            "title": "Reverse Vowels of a String",
            "memory": "7.8 MB",
            "code": "class Solution {\npublic:\n    bool isVowel(char c) {\n        bool isLowercaseVowel, isUppercaseVowel;\n        isLowercaseVowel = (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n        isUppercaseVowel = (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n        return isLowercaseVowel || isUppercaseVowel;\n    }\n    string reverseVowels(string str) {\n        int s = 0, e = str.length()-1;\n        while(s<=e) {\n            if(isVowel(str[s]) && isVowel(str[e])) {\n                swap(str[s],str[e]);\n                s++, e--;\n            } else if(!(isVowel(str[s]))) {\n                s++;\n            } else {\n                e--;\n            }\n        }\n        return str;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-vowels-of-a-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915203148,
            "question_id": 14,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678819281,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/915203148/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "15.4 MB",
            "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) {\n        int i=0;\n        string ans = \"\";\n        while(true) {\n            char ch = 0;\n            for(auto s : str) {\n                if(i >= s.size()) {\n                    ch = 0;\n                    break;\n                }\n                if(ch == 0) {\n                    ch = s[i];\n                } else if(s[i] != ch) {\n                    ch = 0;\n                    break;\n                }\n            }\n            if(ch == 0) {\n                break;\n            }\n            ans.push_back(ch);\n            i++;\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915202742,
            "question_id": 14,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678819239,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/915202742/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "15.3 MB",
            "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) {\n        int i=0;\n        string ans = \"\";\n        while(true) {\n            char ch = 0;\n            for(auto s : str) {\n                if(i >= s.size()) {\n                    ch = 0;\n                    break;\n                }\n                if(ch == 0) {\n                    ch = s[i];\n                } else if(s[i] != ch) {\n                    ch = 0;\n                    break;\n                }\n            }\n            if(ch == 0) {\n                break;\n            }\n            ans.push_back(ch);\n            i++;\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915163008,
            "question_id": 953,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678815340,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/915163008/",
            "is_pending": "Not Pending",
            "title": "Reverse Only Letters",
            "memory": "5.9 MB",
            "code": "class Solution {\npublic:\n    string reverseOnlyLetters(string str) {\n        int s = 0, e = str.length()-1;\n        while(s<=e) {\n            if(isalpha(str[s]) && isalpha(str[e])) {\n                swap(str[s],str[e]);\n                s++, e--;\n            } else if(!(isalpha(str[s]))) {\n                s++;\n            } else {\n                e--;\n            }\n        }\n        return str;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-only-letters",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915162817,
            "question_id": 953,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678815321,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/915162817/",
            "is_pending": "Not Pending",
            "title": "Reverse Only Letters",
            "memory": "6 MB",
            "code": "class Solution {\npublic:\n    string reverseOnlyLetters(string str) {\n        int s = 0, e = str.length()-1;\n        while(s<=e) {\n            if(isalpha(str[s]) && isalpha(str[e])) {\n                swap(str[s],str[e]);\n                s++, e--;\n            } else if(!(isalpha(str[s]))) {\n                s++;\n            } else {\n                e--;\n            }\n        }\n        return str;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-only-letters",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915151786,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678814286,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/915151786/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length() != t.length()) return false;\n        int freq[256] = {0};\n        for(int i=0; i<s.length(); i++) {\n            freq[s[i]]++;\n            freq[t[i]]--;\n        }\n        int len = sizeof(freq)/sizeof(freq[0]);\n        for(int i=0; i<len; i++) {\n            if(freq[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915140713,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678813210,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "20 ms",
            "url": "/submissions/detail/915140713/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length() != t.length()) return false;\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s == t) return true;\n        return false;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915140604,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678813200,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/915140604/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "7.1 MB",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length() != t.length()) return false;\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s == t) return true;\n        return false;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915140468,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678813185,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "16 ms",
            "url": "/submissions/detail/915140468/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length() != t.length()) return false;\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s == t) return true;\n        return false;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 915140307,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678813169,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "20 ms",
            "url": "/submissions/detail/915140307/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "7.4 MB",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length() != t.length()) return false;\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s == t) return true;\n        return false;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914944883,
            "question_id": 953,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678790859,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/914944883/",
            "is_pending": "Not Pending",
            "title": "Reverse Only Letters",
            "memory": "5.9 MB",
            "code": "class Solution {\npublic:\n    bool isOnlyLetter(char ch) {\n        if( ((int)ch >= 97 && (int)ch <= 122) ||\n            ((int)ch >= 65 && (int)ch <= 90) ) {\n                return true;\n            }\n        return false;\n    }\n    string reverseOnlyLetters(string str) {\n        int s = 0, e = str.length()-1;\n        while(s<=e) {\n            if(isOnlyLetter(str.at(s)) && isOnlyLetter(str.at(e))) {\n                swap(str[s],str[e]);\n                s++;\n                e--;\n                cout<<str<<endl;\n            } else if(!(isOnlyLetter(str.at(s)))) {\n                s++;\n            } else if(!(isOnlyLetter(str.at(e)))) {\n                e--;\n            }\n        }\n        return str;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-only-letters",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914944832,
            "question_id": 953,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678790850,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/914944832/",
            "is_pending": "Not Pending",
            "title": "Reverse Only Letters",
            "memory": "6.1 MB",
            "code": "class Solution {\npublic:\n    bool isOnlyLetter(char ch) {\n        if( ((int)ch >= 97 && (int)ch <= 122) ||\n            ((int)ch >= 65 && (int)ch <= 90) ) {\n                return true;\n            }\n        return false;\n    }\n    string reverseOnlyLetters(string str) {\n        int s = 0, e = str.length()-1;\n        while(s<=e) {\n            if(isOnlyLetter(str.at(s)) && isOnlyLetter(str.at(e))) {\n                swap(str[s],str[e]);\n                s++;\n                e--;\n                cout<<str<<endl;\n            } else if(!(isOnlyLetter(str.at(s)))) {\n                s++;\n            } else if(!(isOnlyLetter(str.at(e)))) {\n                e--;\n            }\n        }\n        return str;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-only-letters",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914937171,
            "question_id": 953,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678789677,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/914937171/",
            "is_pending": "Not Pending",
            "title": "Reverse Only Letters",
            "memory": "6.1 MB",
            "code": "class Solution {\npublic:\n    bool isOnlyLetter(char ch) {\n        if( ((int)ch >= 97 && (int)ch <= 122) ||\n            ((int)ch >= 65 && (int)ch <= 90) ) {\n                return true;\n            }\n        return false;\n    }\n    string reverseOnlyLetters(string str) {\n        int s = 0, e = str.length()-1;\n        while(s<=e) {\n            if(isOnlyLetter(str.at(s)) && isOnlyLetter(str.at(e))) {\n                swap(str[s],str[e]);\n                s++;\n                e--;\n                cout<<str<<endl;\n            } else if(!(isOnlyLetter(str.at(s)))) {\n                s++;\n            } else if(!(isOnlyLetter(str.at(e)))) {\n                e--;\n            }\n        }\n        return str;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-only-letters",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914937096,
            "question_id": 953,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678789666,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/914937096/",
            "is_pending": "Not Pending",
            "title": "Reverse Only Letters",
            "memory": "6.1 MB",
            "code": "class Solution {\npublic:\n    bool isOnlyLetter(char ch) {\n        if( ((int)ch >= 97 && (int)ch <= 122) ||\n            ((int)ch >= 65 && (int)ch <= 90) ) {\n                return true;\n            }\n        return false;\n    }\n    string reverseOnlyLetters(string str) {\n        int s = 0, e = str.length()-1;\n        while(s<=e) {\n            if(isOnlyLetter(str.at(s)) && isOnlyLetter(str.at(e))) {\n                swap(str[s],str[e]);\n                s++;\n                e--;\n                cout<<str<<endl;\n            } else if(!(isOnlyLetter(str.at(s)))) {\n                s++;\n            } else if(!(isOnlyLetter(str.at(e)))) {\n                e--;\n            }\n        }\n        return str;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-only-letters",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914794576,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678769545,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/914794576/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "7.1 MB",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s.length() != t.length()) return false;\n        for(int i=0; i<s.length(); i++) {\n            if(s.at(i) != t.at(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914784835,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678768283,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "20 ms",
            "url": "/submissions/detail/914784835/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "7.2 MB",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s.length() != t.length()) return false;\n        for(int i=0; i<s.length(); i++) {\n            if(s.at(i) != t.at(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914781752,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678767857,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/914781752/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        for(int i=0; i<s.length(); i++) {\n            if(s.at(i) != t.at(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "11110100000000000000000000000000000000",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 914592933,
            "question_id": 242,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678735682,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/914592933/",
            "is_pending": "Not Pending",
            "title": "Valid Anagram",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int k=0;\n        s = s+t;\n        for(int i=0; i<s.length(); i++) {\n            k = k ^ (int)s.at(i);\n        }\n        return k==0;\n    }\n};",
            "compare_result": "11111111101111111111111001111110100100",
            "title_slug": "valid-anagram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910801886,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678190021,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "38 ms",
            "url": "/submissions/detail/910801886/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "31.2 MB",
            "code": "class Solution {\npublic:\n    int lowerBound(vector<int>& arr, int x) {\n        int l = 0, h = arr.size()-1;\n        int ans = h;\n        while(l<=h) {\n            int mid = l+(h-l)/2;\n            if(arr[mid] >= x) {\n                ans = mid;\n                h = mid-1;\n            } else if(x>arr[mid]) {\n                l = mid+1;\n            } else {\n                h = mid-1;\n            }\n        }\n        return ans;\n    }\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        // // Two pointer approach:\n        // int l=0, h=arr.size()-1;\n        // while(h-l >= k) {\n        //     if(x-arr[l] > arr[h]-x) {\n        //         l++;\n        //     } else {\n        //         h--;\n        //     }\n        // }\n        // return vector<int>(arr.begin()+l, arr.begin()+h+1);\n        \n        // Binary search:\n        // Step1: Find lowerBound\n        int h = lowerBound(arr, x);\n        int l = h-1;\n        while(k--) {\n            if(l<0) {\n                h++;\n            } else if(h >= arr.size()) {\n                l--;\n            } else if(x-arr[l] > arr[h]-x) {\n                h++;\n            } else {\n                l--;\n            }\n        }\n        return vector<int>(arr.begin()+l+1, arr.begin()+h);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910588510,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678164279,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "37 ms",
            "url": "/submissions/detail/910588510/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "31.2 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(x-arr[l] > arr[h]-x) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        return vector<int>(arr.begin()+l, arr.begin()+h+1);\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910585753,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678163969,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "32 ms",
            "url": "/submissions/detail/910585753/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "31.9 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(x-arr[l] > arr[h]-x) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        for(int i=l; i<=h; i++) {\n            diffArr.push_back(arr[i]);\n        }\n        return diffArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910585606,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678163953,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "45 ms",
            "url": "/submissions/detail/910585606/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "31.8 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(x-arr[l] > arr[h]-x) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        for(int i=l; i<=h; i++) {\n            diffArr.push_back(arr[i]);\n        }\n        return diffArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910585523,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678163944,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "52 ms",
            "url": "/submissions/detail/910585523/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "31.9 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(x-arr[l] > arr[h]-x) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        for(int i=l; i<=h; i++) {\n            diffArr.push_back(arr[i]);\n        }\n        return diffArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910585366,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678163926,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "40 ms",
            "url": "/submissions/detail/910585366/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "31.9 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(x-arr[l] > arr[h]-x) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        for(int i=l; i<=h; i++) {\n            diffArr.push_back(arr[i]);\n        }\n        return diffArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910584366,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678163813,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/910584366/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(arr[x]-arr[l] > arr[h]-arr[x]) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        for(int i=l-1; i<h; i++) {\n            diffArr.push_back(arr[i]);\n        }\n        return diffArr;\n    }\n};",
            "compare_result": "100000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910573627,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678162537,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "35 ms",
            "url": "/submissions/detail/910573627/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "33.7 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        for(int i=0; i<arr.size(); i++) {\n            diffArr.push_back(abs(x-arr[i]));\n        }\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(diffArr[l] > diffArr[h]) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        diffArr.clear();\n        for(int i=l; i<=h; i++) {\n            diffArr.push_back(arr[i]);\n        }\n        return diffArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910573512,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678162522,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "52 ms",
            "url": "/submissions/detail/910573512/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "33.7 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        for(int i=0; i<arr.size(); i++) {\n            diffArr.push_back(abs(x-arr[i]));\n        }\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(diffArr[l] > diffArr[h]) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        diffArr.clear();\n        for(int i=l; i<=h; i++) {\n            diffArr.push_back(arr[i]);\n        }\n        return diffArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910571249,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678162245,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "37 ms",
            "url": "/submissions/detail/910571249/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "34.7 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        vector<int> finalArr;\n        for(int i=0; i<arr.size(); i++) {\n            diffArr.push_back(abs(x-arr[i]));\n        }\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(diffArr[l] > diffArr[h]) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        for(int i=l; i<=h; i++) {\n            finalArr.push_back(arr[i]);\n        }\n        return finalArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910571076,
            "question_id": 658,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678162223,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "45 ms",
            "url": "/submissions/detail/910571076/",
            "is_pending": "Not Pending",
            "title": "Find K Closest Elements",
            "memory": "34.7 MB",
            "code": "class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        vector<int> diffArr;\n        vector<int> finalArr;\n        for(int i=0; i<arr.size(); i++) {\n            diffArr.push_back(abs(x-arr[i]));\n        }\n        int l=0, h=arr.size()-1;\n        while(h-l >= k) {\n            if(diffArr[l] > diffArr[h]) {\n                l++;\n            } else {\n                h--;\n            }\n        }\n        for(int i=l; i<=h; i++) {\n            finalArr.push_back(arr[i]);\n        }\n        return finalArr;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-k-closest-elements",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910285758,
            "question_id": 532,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678121674,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "15 ms",
            "url": "/submissions/detail/910285758/",
            "is_pending": "Not Pending",
            "title": "K-diff Pairs in an Array",
            "memory": "13.2 MB",
            "code": "class Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        int c = 0;\n        set<pair<int,int>> ans;\n        if(nums.size() == 1) {\n            return 0;\n        } else {\n            sort(nums.begin(), nums.end());\n            int i=0, j=1;\n            while(j < nums.size()) {\n                int diff = nums[j] - nums[i];\n                if(diff == k) {\n                    ans.insert({nums[i], nums[j]});\n                    i++;\n                    j++;\n                } else if(diff < k) {\n                    j++;\n                } else {\n                    i++;\n                }\n                if(i == j) j++;\n            }\n        }\n        return ans.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "k-diff-pairs-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910285527,
            "question_id": 532,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678121654,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "22 ms",
            "url": "/submissions/detail/910285527/",
            "is_pending": "Not Pending",
            "title": "K-diff Pairs in an Array",
            "memory": "13.2 MB",
            "code": "class Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        int c = 0;\n        set<pair<int,int>> ans;\n        if(nums.size() == 1) {\n            return 0;\n        } else {\n            sort(nums.begin(), nums.end());\n            int i=0, j=1;\n            while(j < nums.size()) {\n                int diff = nums[j] - nums[i];\n                if(diff == k) {\n                    ans.insert({nums[i], nums[j]});\n                    i++;\n                    j++;\n                } else if(diff < k) {\n                    j++;\n                } else {\n                    i++;\n                }\n                if(i == j) j++;\n            }\n        }\n        return ans.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "k-diff-pairs-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910285422,
            "question_id": 532,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678121646,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "23 ms",
            "url": "/submissions/detail/910285422/",
            "is_pending": "Not Pending",
            "title": "K-diff Pairs in an Array",
            "memory": "13 MB",
            "code": "class Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        int c = 0;\n        set<pair<int,int>> ans;\n        if(nums.size() == 1) {\n            return 0;\n        } else {\n            sort(nums.begin(), nums.end());\n            int i=0, j=1;\n            while(j < nums.size()) {\n                int diff = nums[j] - nums[i];\n                if(diff == k) {\n                    ans.insert({nums[i], nums[j]});\n                    i++;\n                    j++;\n                } else if(diff < k) {\n                    j++;\n                } else {\n                    i++;\n                }\n                if(i == j) j++;\n            }\n        }\n        return ans.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "k-diff-pairs-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910285242,
            "question_id": 532,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678121630,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "23 ms",
            "url": "/submissions/detail/910285242/",
            "is_pending": "Not Pending",
            "title": "K-diff Pairs in an Array",
            "memory": "13 MB",
            "code": "class Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        int c = 0;\n        set<pair<int,int>> ans;\n        if(nums.size() == 1) {\n            return 0;\n        } else {\n            sort(nums.begin(), nums.end());\n            int i=0, j=1;\n            while(j < nums.size()) {\n                int diff = nums[j] - nums[i];\n                if(diff == k) {\n                    ans.insert({nums[i], nums[j]});\n                    i++;\n                    j++;\n                } else if(diff < k) {\n                    j++;\n                } else {\n                    i++;\n                }\n                if(i == j) j++;\n            }\n        }\n        return ans.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "k-diff-pairs-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910285123,
            "question_id": 532,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678121618,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "15 ms",
            "url": "/submissions/detail/910285123/",
            "is_pending": "Not Pending",
            "title": "K-diff Pairs in an Array",
            "memory": "13.2 MB",
            "code": "class Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        int c = 0;\n        set<pair<int,int>> ans;\n        if(nums.size() == 1) {\n            return 0;\n        } else {\n            sort(nums.begin(), nums.end());\n            int i=0, j=1;\n            while(j < nums.size()) {\n                int diff = nums[j] - nums[i];\n                if(diff == k) {\n                    ans.insert({nums[i], nums[j]});\n                    i++;\n                    j++;\n                } else if(diff < k) {\n                    j++;\n                } else {\n                    i++;\n                }\n                if(i == j) j++;\n            }\n        }\n        return ans.size();\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "k-diff-pairs-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910281228,
            "question_id": 532,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678121230,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/910281228/",
            "is_pending": "Not Pending",
            "title": "K-diff Pairs in an Array",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        int c = 0;\n        if(nums.size() == 1) {\n            return 0;\n        } else {\n            sort(nums.begin(), nums.end());\n            int i=0, j=1;\n            while(j < nums.size()) {\n                int diff = nums[j] - nums[i];\n                if(diff == k) {\n                    c++;\n                    i++;\n                    j++;\n                } else if(diff < k) {\n                    j++;\n                } else {\n                    i++;\n                }\n                if(i == j) j++;\n            }\n        }\n        return c;\n    }\n};",
            "compare_result": "111111111110010111100101111011111101011111111100000011111101",
            "title_slug": "k-diff-pairs-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 910279365,
            "question_id": 532,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1678121040,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/910279365/",
            "is_pending": "Not Pending",
            "title": "K-diff Pairs in an Array",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        int c = 0;\n        if(nums.size() == 1) {\n            return 0;\n        } else {\n            sort(nums.begin(), nums.end());\n            int i=0, j=1;\n            while(j < nums.size()) {\n                int diff = nums[j] - nums[i];\n                if(diff == k) {\n                    c++;\n                    i++;\n                    j++;\n                } else if(diff < k) {\n                    j++;\n                } else {\n                    i++;\n                }\n            }\n        }\n        return c;\n    }\n};",
            "compare_result": "110111111010010111100100011011111101011111111100000011111101",
            "title_slug": "k-diff-pairs-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907264858,
            "question_id": 539,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677692529,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "13 ms",
            "url": "/submissions/detail/907264858/",
            "is_pending": "Not Pending",
            "title": "Minimum Time Difference",
            "memory": "13.8 MB",
            "code": "class Solution {\npublic:\n    int findMinDifference(vector<string>& timePoints) {\n        // Step1: Convert to minutes;\n        vector<int> timeInMin;\n        for(int i=0; i<timePoints.size(); i++) {\n            int mins = (stoi(timePoints[i].substr(0,2)) * 60) + stoi(timePoints[i].substr(3,2));\n            timeInMin.push_back(mins);\n        }\n        \n        // Step2: Sort\n        sort(timeInMin.begin(), timeInMin.end());\n        \n        // Step3: Find diff and min\n        int mini = INT_MAX;\n        int n = timeInMin.size();\n        for(int i=0; i<n-1; i++) {\n            int diff = timeInMin[i+1] - timeInMin[i];\n            mini = min(mini, diff);\n        }\n        \n        // Step4: Compare first with last\n        int lastDiff = (timeInMin[0] + (60*24)) - timeInMin[n-1];\n        mini = min(mini, lastDiff);\n        \n        return mini;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-time-difference",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907264730,
            "question_id": 539,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677692518,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/907264730/",
            "is_pending": "Not Pending",
            "title": "Minimum Time Difference",
            "memory": "13.8 MB",
            "code": "class Solution {\npublic:\n    int findMinDifference(vector<string>& timePoints) {\n        // Step1: Convert to minutes;\n        vector<int> timeInMin;\n        for(int i=0; i<timePoints.size(); i++) {\n            int mins = (stoi(timePoints[i].substr(0,2)) * 60) + stoi(timePoints[i].substr(3,2));\n            timeInMin.push_back(mins);\n        }\n        \n        // Step2: Sort\n        sort(timeInMin.begin(), timeInMin.end());\n        \n        // Step3: Find diff and min\n        int mini = INT_MAX;\n        int n = timeInMin.size();\n        for(int i=0; i<n-1; i++) {\n            int diff = timeInMin[i+1] - timeInMin[i];\n            mini = min(mini, diff);\n        }\n        \n        // Step4: Compare first with last\n        int lastDiff = (timeInMin[0] + (60*24)) - timeInMin[n-1];\n        mini = min(mini, lastDiff);\n        \n        return mini;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-time-difference",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907264615,
            "question_id": 539,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677692508,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/907264615/",
            "is_pending": "Not Pending",
            "title": "Minimum Time Difference",
            "memory": "13.8 MB",
            "code": "class Solution {\npublic:\n    int findMinDifference(vector<string>& timePoints) {\n        // Step1: Convert to minutes;\n        vector<int> timeInMin;\n        for(int i=0; i<timePoints.size(); i++) {\n            int mins = (stoi(timePoints[i].substr(0,2)) * 60) + stoi(timePoints[i].substr(3,2));\n            timeInMin.push_back(mins);\n        }\n        \n        // Step2: Sort\n        sort(timeInMin.begin(), timeInMin.end());\n        \n        // Step3: Find diff and min\n        int mini = INT_MAX;\n        int n = timeInMin.size();\n        for(int i=0; i<n-1; i++) {\n            int diff = timeInMin[i+1] - timeInMin[i];\n            mini = min(mini, diff);\n        }\n        \n        // Step4: Compare first with last\n        int lastDiff = (timeInMin[0] + (60*24)) - timeInMin[n-1];\n        mini = min(mini, lastDiff);\n        \n        return mini;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-time-difference",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907264490,
            "question_id": 539,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677692498,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/907264490/",
            "is_pending": "Not Pending",
            "title": "Minimum Time Difference",
            "memory": "13.6 MB",
            "code": "class Solution {\npublic:\n    int findMinDifference(vector<string>& timePoints) {\n        // Step1: Convert to minutes;\n        vector<int> timeInMin;\n        for(int i=0; i<timePoints.size(); i++) {\n            int mins = (stoi(timePoints[i].substr(0,2)) * 60) + stoi(timePoints[i].substr(3,2));\n            timeInMin.push_back(mins);\n        }\n        \n        // Step2: Sort\n        sort(timeInMin.begin(), timeInMin.end());\n        \n        // Step3: Find diff and min\n        int mini = INT_MAX;\n        int n = timeInMin.size();\n        for(int i=0; i<n-1; i++) {\n            int diff = timeInMin[i+1] - timeInMin[i];\n            mini = min(mini, diff);\n        }\n        \n        // Step4: Compare first with last\n        int lastDiff = (timeInMin[0] + (60*24)) - timeInMin[n-1];\n        mini = min(mini, lastDiff);\n        \n        return mini;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "minimum-time-difference",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907231055,
            "question_id": 680,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677689298,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "47 ms",
            "url": "/submissions/detail/907231055/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome II",
            "memory": "24.1 MB",
            "code": "class Solution {\npublic:\n    bool checkPalindrome(string s, int i, int j) {\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n    bool validPalindrome(string s) {\n        int i=0, j = s.length()-1;\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                // remove i once and remove j once\n                return checkPalindrome(s, i+1, j) || checkPalindrome(s, i, j-1);\n            } else {\n                i++;\n                j--;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-palindrome-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907230617,
            "question_id": 680,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677689257,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "52 ms",
            "url": "/submissions/detail/907230617/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome II",
            "memory": "24.2 MB",
            "code": "class Solution {\npublic:\n    bool checkPalindrome(string s, int i, int j) {\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n    bool validPalindrome(string s) {\n        int i=0, j = s.length()-1;\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                // remove i once and remove j once\n                return checkPalindrome(s, i+1, j) || checkPalindrome(s, i, j-1);\n            } else {\n                i++;\n                j--;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-palindrome-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907230471,
            "question_id": 680,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677689241,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "63 ms",
            "url": "/submissions/detail/907230471/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome II",
            "memory": "24.1 MB",
            "code": "class Solution {\npublic:\n    bool checkPalindrome(string s, int i, int j) {\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n    bool validPalindrome(string s) {\n        int i=0, j = s.length()-1;\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                // remove i once and remove j once\n                return checkPalindrome(s, i+1, j) || checkPalindrome(s, i, j-1);\n            } else {\n                i++;\n                j--;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-palindrome-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907229227,
            "question_id": 680,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677689125,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/907229227/",
            "is_pending": "Not Pending",
            "title": "Valid Palindrome II",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool checkPalindrome(string s, int i, int j) {\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool validPalindrome(string s) {\n        int i=0, j = s.length()-1;\n        while(i<=j) {\n            if(s[i] != s[j]) {\n                // remove i once and remove j once\n                return checkPalindrome(s, i+1, j) || checkPalindrome(s, i, j-1);\n            } else {\n                i++;\n                j--;\n            }\n        }\n        return true;\n    }\n};",
            "compare_result": "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-palindrome-ii",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907222144,
            "question_id": 2021,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677688409,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/907222144/",
            "is_pending": "Not Pending",
            "title": "Remove All Occurrences of a Substring",
            "memory": "6.5 MB",
            "code": "class Solution {\npublic:\n    string removeOccurrences(string s, string part) {\n        int strInd = s.find(part);\n        while(strInd != string::npos) {\n            s.erase(strInd, part.length());\n            strInd = s.find(part);\n        }\n        return s;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-occurrences-of-a-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907222046,
            "question_id": 2021,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677688399,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/907222046/",
            "is_pending": "Not Pending",
            "title": "Remove All Occurrences of a Substring",
            "memory": "6.7 MB",
            "code": "class Solution {\npublic:\n    string removeOccurrences(string s, string part) {\n        int strInd = s.find(part);\n        while(strInd != string::npos) {\n            s.erase(strInd, part.length());\n            strInd = s.find(part);\n        }\n        return s;\n    }\n};",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-occurrences-of-a-substring",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907212659,
            "question_id": 1128,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677687433,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/907212659/",
            "is_pending": "Not Pending",
            "title": "Remove All Adjacent Duplicates In String",
            "memory": "11 MB",
            "code": "class Solution {\npublic:\n    string removeDuplicates(string s) {\n        string ans =\"\";\n        for(int i=0; i<s.length(); i++) {\n            if((ans.length() > 0) && s[i] == ans[ans.length()-1]) {\n                ans.pop_back();\n            } else {\n                ans.push_back(s[i]);\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-adjacent-duplicates-in-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 907212564,
            "question_id": 1128,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677687424,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/907212564/",
            "is_pending": "Not Pending",
            "title": "Remove All Adjacent Duplicates In String",
            "memory": "11 MB",
            "code": "class Solution {\npublic:\n    string removeDuplicates(string s) {\n        string ans =\"\";\n        for(int i=0; i<s.length(); i++) {\n            if((ans.length() > 0) && s[i] == ans[ans.length()-1]) {\n                ans.pop_back();\n            } else {\n                ans.push_back(s[i]);\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-all-adjacent-duplicates-in-string",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 906663905,
            "question_id": 647,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677608889,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/906663905/",
            "is_pending": "Not Pending",
            "title": "Palindromic Substrings",
            "memory": "13.3 MB",
            "code": "class Solution {\npublic:\n    int expandAroundIndex(string s, int i, int j) {\n        int count = 0;\n        while(i>=0 && j<s.length() && s[i]==s[j]) {\n            count++;\n            i--;\n            j++;\n        }\n        return count;\n    }\n    int countSubstrings(string s) {\n        int count = 0;\n        int n = s.length();\n        \n        for(int i=0; i<n; i++) {\n            // Odd\n            int oddAns = expandAroundIndex(s,i,i);\n            count += oddAns;\n            \n            // Even\n            int evenAns = expandAroundIndex(s,i,i+1);\n            count += evenAns;\n        }\n        return count;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "palindromic-substrings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 906663740,
            "question_id": 647,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677608872,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/906663740/",
            "is_pending": "Not Pending",
            "title": "Palindromic Substrings",
            "memory": "13.3 MB",
            "code": "class Solution {\npublic:\n    int expandAroundIndex(string s, int i, int j) {\n        int count = 0;\n        while(i>=0 && j<s.length() && s[i]==s[j]) {\n            count++;\n            i--;\n            j++;\n        }\n        return count;\n    }\n    int countSubstrings(string s) {\n        int count = 0;\n        int n = s.length();\n        \n        for(int i=0; i<n; i++) {\n            // Odd\n            int oddAns = expandAroundIndex(s,i,i);\n            count += oddAns;\n            \n            // Even\n            int evenAns = expandAroundIndex(s,i,i+1);\n            count += evenAns;\n        }\n        return count;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "palindromic-substrings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 906663653,
            "question_id": 647,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677608863,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/906663653/",
            "is_pending": "Not Pending",
            "title": "Palindromic Substrings",
            "memory": "13.3 MB",
            "code": "class Solution {\npublic:\n    int expandAroundIndex(string s, int i, int j) {\n        int count = 0;\n        while(i>=0 && j<s.length() && s[i]==s[j]) {\n            count++;\n            i--;\n            j++;\n        }\n        return count;\n    }\n    int countSubstrings(string s) {\n        int count = 0;\n        int n = s.length();\n        \n        for(int i=0; i<n; i++) {\n            // Odd\n            int oddAns = expandAroundIndex(s,i,i);\n            count += oddAns;\n            \n            // Even\n            int evenAns = expandAroundIndex(s,i,i+1);\n            count += evenAns;\n        }\n        return count;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "palindromic-substrings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 906663569,
            "question_id": 647,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677608853,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/906663569/",
            "is_pending": "Not Pending",
            "title": "Palindromic Substrings",
            "memory": "13.1 MB",
            "code": "class Solution {\npublic:\n    int expandAroundIndex(string s, int i, int j) {\n        int count = 0;\n        while(i>=0 && j<s.length() && s[i]==s[j]) {\n            count++;\n            i--;\n            j++;\n        }\n        return count;\n    }\n    int countSubstrings(string s) {\n        int count = 0;\n        int n = s.length();\n        \n        for(int i=0; i<n; i++) {\n            // Odd\n            int oddAns = expandAroundIndex(s,i,i);\n            count += oddAns;\n            \n            // Even\n            int evenAns = expandAroundIndex(s,i,i+1);\n            count += evenAns;\n        }\n        return count;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "palindromic-substrings",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 906574140,
            "question_id": 54,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677599955,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/906574140/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "6.8 MB",
            "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& m) {\n        int sR = 0;\n        int eC = m[0].size();\n        int eR = m.size();\n        int sC = 0;\n        int tSize = eC*eR;\n        vector<int> v;\n        outer_loop:\n        while(tSize>0) {\n            // L -> R\n            for(int i=sR; i<=eC-1; i++) {\n                int temp = m[sR][i];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            ++sR;\n            // T -> B\n            for(int i=sR; i<=eR-1; i++) {\n                int temp = m[i][eC-1];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            --eC;\n            // R -> L\n            for(int i=eC-1; i>=sC; i--) {\n                int temp = m[eR-1][i];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            --eR;\n            // B -> T\n            for(int i=eR-1; i>=sR; i--) {\n                int temp = m[i][sC];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            ++sC;\n        }\n        \n        return v;\n    }\n};",
            "compare_result": "11111111111111111111111",
            "title_slug": "spiral-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 906574042,
            "question_id": 54,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677599943,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/906574042/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "6.9 MB",
            "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& m) {\n        int sR = 0;\n        int eC = m[0].size();\n        int eR = m.size();\n        int sC = 0;\n        int tSize = eC*eR;\n        vector<int> v;\n        outer_loop:\n        while(tSize>0) {\n            // L -> R\n            for(int i=sR; i<=eC-1; i++) {\n                int temp = m[sR][i];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            ++sR;\n            // T -> B\n            for(int i=sR; i<=eR-1; i++) {\n                int temp = m[i][eC-1];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            --eC;\n            // R -> L\n            for(int i=eC-1; i>=sC; i--) {\n                int temp = m[eR-1][i];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            --eR;\n            // B -> T\n            for(int i=eR-1; i>=sR; i--) {\n                int temp = m[i][sC];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    goto outer_loop;\n                }\n            }\n            ++sC;\n        }\n        \n        return v;\n    }\n};",
            "compare_result": "11111111111111111111111",
            "title_slug": "spiral-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 906547649,
            "question_id": 54,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677596882,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/906547649/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& m) {\n        int sR = 0;\n        int eC = m[0].size();\n        int eR = m.size();\n        int sC = 0;\n        int tSize = eC*eR;\n        vector<int> v;\n        while(tSize>0) {\n            // L -> R\n            for(int i=sR; i<=eC-1; i++) {\n                int temp = m[sR][i];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    break;\n                }\n            }\n            ++sR;\n            // T -> B\n            for(int i=sR; i<=eR-1; i++) {\n                int temp = m[i][eC-1];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    break;\n                }\n            }\n            --eC;\n            // R -> L\n            for(int i=eC-1; i>=sC; i--) {\n                int temp = m[eR-1][i];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    break;\n                }\n            }\n            --eR;\n            // B -> T\n            for(int i=eR-1; i>=sR; i--) {\n                int temp = m[i][sC];\n                v.push_back(temp);\n                tSize--;\n                if(tSize<=0) {\n                    break;\n                }\n            }\n            ++sC;\n        }\n        \n        return v;\n    }\n};",
            "compare_result": "10101001110011101011101",
            "title_slug": "spiral-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904802739,
            "question_id": 287,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677344991,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "112 ms",
            "url": "/submissions/detail/904802739/",
            "is_pending": "Not Pending",
            "title": "Find the Duplicate Number",
            "memory": "61.2 MB",
            "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // int ans=-1;\n        // for(int i=0; i<nums.size(); i++) {\n        //     int index = abs(nums[i]);\n        //     if(nums[index] < 0) {\n        //         ans = index;\n        //         break;\n        //     } else {\n        //         nums[index] *= -1;\n        //     }\n        // }\n        // return ans;\n        \n        while(nums[0] != nums[nums[0]]) {\n            swap(nums[0], nums[nums[0]]);\n        }\n        return nums[0];\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-duplicate-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904802661,
            "question_id": 287,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677344981,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "100 ms",
            "url": "/submissions/detail/904802661/",
            "is_pending": "Not Pending",
            "title": "Find the Duplicate Number",
            "memory": "61.4 MB",
            "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // int ans=-1;\n        // for(int i=0; i<nums.size(); i++) {\n        //     int index = abs(nums[i]);\n        //     if(nums[index] < 0) {\n        //         ans = index;\n        //         break;\n        //     } else {\n        //         nums[index] *= -1;\n        //     }\n        // }\n        // return ans;\n        \n        while(nums[0] != nums[nums[0]]) {\n            swap(nums[0], nums[nums[0]]);\n        }\n        return nums[0];\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-duplicate-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904802586,
            "question_id": 287,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677344973,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "114 ms",
            "url": "/submissions/detail/904802586/",
            "is_pending": "Not Pending",
            "title": "Find the Duplicate Number",
            "memory": "61.3 MB",
            "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // int ans=-1;\n        // for(int i=0; i<nums.size(); i++) {\n        //     int index = abs(nums[i]);\n        //     if(nums[index] < 0) {\n        //         ans = index;\n        //         break;\n        //     } else {\n        //         nums[index] *= -1;\n        //     }\n        // }\n        // return ans;\n        \n        while(nums[0] != nums[nums[0]]) {\n            swap(nums[0], nums[nums[0]]);\n        }\n        return nums[0];\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-duplicate-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904796943,
            "question_id": 287,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677344322,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "92 ms",
            "url": "/submissions/detail/904796943/",
            "is_pending": "Not Pending",
            "title": "Find the Duplicate Number",
            "memory": "61.3 MB",
            "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int ans=-1;\n        for(int i=0; i<nums.size(); i++) {\n            int index = abs(nums[i]);\n            if(nums[index] < 0) {\n                ans = index;\n                break;\n            } else {\n                nums[index] *= -1;\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-duplicate-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904796777,
            "question_id": 287,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677344302,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "105 ms",
            "url": "/submissions/detail/904796777/",
            "is_pending": "Not Pending",
            "title": "Find the Duplicate Number",
            "memory": "61.3 MB",
            "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int ans=-1;\n        for(int i=0; i<nums.size(); i++) {\n            int index = abs(nums[i]);\n            if(nums[index] < 0) {\n                ans = index;\n                break;\n            } else {\n                nums[index] *= -1;\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-duplicate-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904794199,
            "question_id": 287,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677344005,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/904794199/",
            "is_pending": "Not Pending",
            "title": "Find the Duplicate Number",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int ans;\n        for(int i=0; i<nums.size()-1; i++) {\n            if(nums[nums[i]] == 0) {\n                ans = nums[i];\n                break;\n            } else {\n                nums[i] = 0;\n            }\n        }\n        return ans;\n    }\n};",
            "compare_result": "1010101100110100011011000000011110011001000010000101000000",
            "title_slug": "find-the-duplicate-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904773544,
            "question_id": 287,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677341482,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/904773544/",
            "is_pending": "Not Pending",
            "title": "Find the Duplicate Number",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int ans = 0;\n        for(int i=0; i<nums.size(); i++) {\n            ans = ans ^ nums[i]  ^ i;\n        }\n        return ans;\n    }\n};",
            "compare_result": "1111111010001000010000000000110000000000000000000000111111",
            "title_slug": "find-the-duplicate-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904736732,
            "question_id": 75,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677336648,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/904736732/",
            "is_pending": "Not Pending",
            "title": "Sort Colors",
            "memory": "8.2 MB",
            "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        // for(int i=1; i<nums.size(); i++) {\n        //     int val = nums[i];\n        //     int j = i-1;\n        //     for(; j>=0; j--) {\n        //         if(nums[j] > val) {\n        //             nums[j+1] = nums[j];\n        //         } else {\n        //             break;\n        //         }\n        //     }\n        //     nums[j+1] = val;\n        // }\n        int l = 0, m = 0, h = nums.size()-1;\n        while(m<=h) {\n            if(nums[m] == 0) {\n                swap(nums[m],nums[l]);\n                l++;\n                m++;\n            } else if(nums[m]==1) {\n                m++;\n            } else {\n                swap(nums[m],nums[h]);\n                h--;\n            }\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "sort-colors",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 904727418,
            "question_id": 75,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 1 month",
            "timestamp": 1677335394,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/904727418/",
            "is_pending": "Not Pending",
            "title": "Sort Colors",
            "memory": "8.2 MB",
            "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        for(int i=1; i<nums.size(); i++) {\n            int val = nums[i];\n            int j = i-1;\n            for(; j>=0; j--) {\n                if(nums[j] > val) {\n                    nums[j+1] = nums[j];\n                } else {\n                    break;\n                }\n            }\n            nums[j+1] = val;\n        }\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "sort-colors",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 901123091,
            "question_id": 74,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676832292,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/901123091/",
            "is_pending": "Not Pending",
            "title": "Search a 2D Matrix",
            "memory": "9.4 MB",
            "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int s = 0, e = matrix.size()*matrix[0].size()-1;\n        int mid = s + (e-s)/2;\n        while(s<=e) {\n            int rInd = mid/matrix[0].size(), cInd = mid % matrix[0].size();\n            int element = matrix[rInd][cInd];\n            if(target == element) {\n                return 1;\n            } else if(target < element) {\n                e = mid-1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        return 0;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-a-2d-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 901122859,
            "question_id": 74,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676832263,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/901122859/",
            "is_pending": "Not Pending",
            "title": "Search a 2D Matrix",
            "memory": "9.6 MB",
            "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int s = 0, e = matrix.size()*matrix[0].size()-1;\n        int mid = s + (e-s)/2;\n        while(s<=e) {\n            int rInd = mid/matrix[0].size(), cInd = mid % matrix[0].size();\n            int element = matrix[rInd][cInd];\n            if(target == element) {\n                return 1;\n            } else if(target < element) {\n                e = mid-1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        return 0;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-a-2d-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 901115557,
            "question_id": 74,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676831356,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/901115557/",
            "is_pending": "Not Pending",
            "title": "Search a 2D Matrix",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int s = 0, e = matrix.size()*matrix[0].size();\n        int mid = s + (e-s)/2;\n        \n        while(s<=e) {\n            if(target == mid) {\n                return 1;\n            } else if(target < mid) {\n                e = mid-1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        return 0;\n    }\n};",
            "compare_result": "1101101001001010010101101010110101100101001001010110001010101011011011101110101001110010110000000010011000001110011110111110000100100",
            "title_slug": "search-a-2d-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 901110604,
            "question_id": 69,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676830789,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/901110604/",
            "is_pending": "Not Pending",
            "title": "Sqrt(x)",
            "memory": "5.9 MB",
            "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        int s=0, e=x, ans;\n        long long int mid = s + (e-s)/2;\n        \n        while(s<=e) {\n            if(mid*mid == x) {\n                return mid;\n            } else if(mid*mid > x) {\n                e = mid-1;\n            } else {\n                ans = mid;\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        \n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "sqrtx",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 901107304,
            "question_id": 69,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676830406,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/901107304/",
            "is_pending": "Not Pending",
            "title": "Sqrt(x)",
            "memory": "6.1 MB",
            "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        int s=0, e=x, ans;\n        long long int mid = s + (e-s)/2;\n        \n        while(s<=e) {\n            if(mid*mid == x) {\n                return mid;\n            } else if(mid*mid > x) {\n                e = mid-1;\n            } else {\n                ans = mid;\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        \n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "sqrtx",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 901107168,
            "question_id": 69,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676830391,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/901107168/",
            "is_pending": "Not Pending",
            "title": "Sqrt(x)",
            "memory": "5.9 MB",
            "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        int s=0, e=x, ans;\n        long long int mid = s + (e-s)/2;\n        \n        while(s<=e) {\n            if(mid*mid == x) {\n                return mid;\n            } else if(mid*mid > x) {\n                e = mid-1;\n            } else {\n                ans = mid;\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        \n        return ans;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "sqrtx",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 901094186,
            "question_id": 69,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676828967,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/901094186/",
            "is_pending": "Not Pending",
            "title": "Sqrt(x)",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        int s=0, e=x, ans;\n        int mid = s + (e-s)/2;\n        \n        while(s<=e) {\n            if(mid*mid == x) {\n                return mid;\n            } else if(mid*mid > x) {\n                e = mid-1;\n            } else {\n                ans = mid;\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        \n        return ans;\n    }\n};",
            "compare_result": "111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "sqrtx",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 900904550,
            "question_id": 33,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676803239,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/900904550/",
            "is_pending": "Not Pending",
            "title": "Search in Rotated Sorted Array",
            "memory": "11.4 MB",
            "code": "class Solution {\npublic:\n    int binarySearch(vector<int> arr, int s, int e, int target) {\n        int mid = s + (e-s)/2;\n        while(s<=e) {\n            if(arr[mid] == target) {\n                return mid;\n            } else if(arr[mid] < target) {\n                s = mid+1;\n            } else {\n                e = mid-1;\n            }\n            mid = s + (e-s)/2;\n        }\n        return -1;\n    }\n    int findPivotElement(vector<int> arr) {\n        int s = 0, e = arr.size()-1;\n        int mid = s + (e-s)/2;\n        while(s<e) {\n            if(mid+1 < arr.size() && arr[mid] > arr[mid+1]) {\n                return mid;\n            } else if(mid-1 >= 0 && arr[mid] < arr[mid-1]) {\n                return mid-1;\n            } else if(arr[s] >= arr[mid]) {\n                e = mid-1;\n            } else {\n                s = mid;\n            }\n            mid = s + (e-s)/2;\n        }\n        return s;\n    }\n    int search(vector<int>& nums, int target) {\n        int s = 0, e = nums.size()-1;\n        int pivot = findPivotElement(nums);\n        if(target >= nums[0] && target <= nums[pivot]) {\n            e = pivot;\n            return binarySearch(nums, s, e, target);\n        } \n        if(pivot+1 < nums.size() && target >= nums[pivot+1] && target <= nums[nums.size()-1]) {\n            s = pivot + 1;\n            return binarySearch(nums, s, e, target);\n        }\n        return -1;\n    }\n};",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-in-rotated-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 900304165,
            "question_id": 33,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676724280,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/900304165/",
            "is_pending": "Not Pending",
            "title": "Search in Rotated Sorted Array",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int binarySearch(vector<int> arr, int s, int e, int target) {\n        int mid = s + (e-s)/2;\n        while(s<=e) {\n            if(arr[mid] == target) {\n                return mid;\n            } else if(arr[mid] < target) {\n                s = mid+1;\n            } else {\n                e = mid-1;\n            }\n            mid = s + (e-s)/2;\n        }\n        return -1;\n    }\n    int findPivotElement(vector<int> arr) {\n        int s = 0, e = arr.size();\n        int mid = s + (e-s)/2;\n        while(s<e) {\n            if(mid+1 < arr.size() && arr[mid] > arr[mid+1]) {\n                return mid;\n            } else if(mid-1 >= 0 && arr[mid] < arr[mid-1]) {\n                return mid-1;\n            } else if(arr[s] >= arr[mid]) {\n                e = mid-1;\n            } else {\n                s = mid;\n            }\n            mid = s + (e-s)/2;\n        }\n        return s;\n    }\n    int search(vector<int>& nums, int target) {\n        int s = 0, e = nums.size()-1;\n        int pivot = findPivotElement(nums);\n        if(pivot == -1) {\n            return -1;\n        } else if(nums[pivot] == target) {\n            return pivot;\n        } else if(target > nums[0] && target < nums[pivot]) {\n            e = pivot;\n            return binarySearch(nums, s, e, target);\n        } else {\n            s = pivot + 1;\n            return binarySearch(nums, s, e, target);\n        }\n    }\n};",
            "compare_result": "111111011111111101111111101111111111110111111111011011111111111011110111111111111111111111111111111101111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-in-rotated-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 900301256,
            "question_id": 33,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 2 months",
            "timestamp": 1676723806,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/900301256/",
            "is_pending": "Not Pending",
            "title": "Search in Rotated Sorted Array",
            "memory": "N/A",
            "code": "class Solution {\npublic:\n    int binarySearch(vector<int> arr, int s, int e, int target) {\n        int mid = s + (e-s)/2;\n        while(s<=e) {\n            if(arr[mid] == target) {\n                return mid;\n            } else if(arr[mid] < target) {\n                s = mid+1;\n            } else {\n                e = mid-1;\n            }\n            mid = s + (e-s)/2;\n        }\n        return -1;\n    }\n    int findPivotElement(vector<int> arr) {\n        int s = 0, e = arr.size();\n        int mid = s + (e-s)/2;\n        while(s<e) {\n            if(mid+1 < arr.size() && arr[mid] > arr[mid+1]) {\n                return mid;\n            } else if(mid-1 >= 0 && arr[mid] < arr[mid-1]) {\n                return mid-1;\n            } else if(arr[s] >= arr[mid]) {\n                e = mid-1;\n            } else {\n                s = mid+1;\n            }\n            mid = s + (e-s)/2;\n        }\n        return -1;\n    }\n    int search(vector<int>& nums, int target) {\n        int s = 0, e = nums.size()-1;\n        int pivot = findPivotElement(nums);\n        if(pivot == -1) {\n            return -1;\n        } else if(nums[pivot] == target) {\n            return pivot;\n        } else if(target > nums[0] && target < nums[pivot]) {\n            e = pivot;\n            return binarySearch(nums, s, e, target);\n        } else {\n            s = pivot + 1;\n            return binarySearch(nums, s, e, target);\n        }\n    }\n};",
            "compare_result": "111011010111111101010111101111111111110111111011011011111101111011110111111011101111011111110111111101111111111011111110111110111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-in-rotated-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 872655339,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1673012204,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/872655339/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0, divd = dividend;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n            for(int i=2; i<=(dividend/2); i++) {\n                if(dividend-(i*divisor) >= divisor) {\n                    dividend -= (i*divisor);\n                    quo+=i;\n                } else {\n                    dividend -= divisor;\n                    quo++;\n                    break;\n                }\n            }\n        }\n        if(bool) {\n            if(divd == Integer.MIN_VALUE) {\n                quo++;\n            }\n            return -quo;\n        } else {\n            return quo;\n        }\n    }\n}",
            "compare_result": "1111111111111111111111111110110111101111011001100100001111111101010110101110101101110110011111110111111111110101010111111100110110111111101001101111110111110100001110101110001110111101111101001101011111001101111111010011010111111101101101001111110110100111000100100100111011101001111100010011111011011011000011110001110011110110010110111011110000100101111111010001011010000111100011011011110100101011011101111101010010101000100110101111001100111011101110100111100111010101000001011000001101111111111101000000000000000000000000010000000000000000101101100010111110000000011111110100000000000000000000000000000000000001000000001000001001000000000000000010000011011111111111111111111111110111111111111111101111111111111101111111111111111111011110111111111111110111011111111111110111111111101101111111011001010111111111111111111101111011111111001111111011001011101111111111110111110111111111111111111111111001110111111111111011000111111111111111110111111110111111010101100111111111001111111111111111",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 872653984,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1673012046,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/872653984/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0, divd = dividend;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            for(int i=2; i<=(dividend/2); i++) {\n                if(dividend-(i*divisor) >= divisor) {\n                    dividend -= (i*divisor);\n                    quo+=i;\n                } else {\n                    dividend -= divisor;\n                    quo++;\n                    break;\n                }\n            }\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) {\n            if(divd == Integer.MIN_VALUE) {\n                quo++;\n            }\n            return -quo;\n        } else {\n            return quo;\n        }\n    }\n}",
            "compare_result": "1111111111111110111111111110110111101110011001100100001111111101010110101110101101110110011111110111111111110101010111111100110110111111101001101111110111110100001110101110001110111101111101001101011111001101111111010011010111111101101101001111110110100111000100100100111011101001011000010010111011011011000011110001110011110110010110111011110000100101111111010001011010000111100011011011110100101011011101101101010010101000100110101111001100111011101110100111100111010101000001011000001101111111111101000000000000000000000000010000000000000000001100000010111110000000011111110100000000000000000000000000000000000001000000000000001001000000000000000010000011011111111111111111111111110111111111111111101111111111111101111111111111101111011110111111111111110111011111111111110111111111101101111101011001010111111111111111111101111011111111001111111011001011101111111111110111110111111111111111111111111001110111111111111011000101111111111111110111111110111111010101100111111111001111111111111111",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 872642474,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1673010668,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/872642474/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0, divd = dividend;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) {\n            if(divd == Integer.MIN_VALUE) {\n                quo++;\n            }\n            return -quo;\n        } else {\n            return quo;\n        }\n    }\n}",
            "compare_result": "1111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 872639568,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1673010311,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/872639568/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0, divd = dividend;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) {\n            if(divd == Integer.MIN_VALUE) {\n                quo++;\n            }\n            return -quo;\n        } else {\n            return quo;\n        }\n    }\n}",
            "compare_result": "1111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 872631503,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1673009277,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/872631503/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0, divd = dividend;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) {\n            // if(divd > Integer.MIN_VALUE) {\n            //     quo++;\n            // }\n            return -quo;\n        } else {\n            // if(divd < Integer.MAX_VALUE) {\n            //     quo++;\n            // }\n            return quo;\n        }\n    }\n}",
            "compare_result": "1111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 871907683,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672921901,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/871907683/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0, divd = dividend;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) {\n            if(divd > Integer.MIN_VALUE) {\n                quo++;\n            }\n            return -quo;\n        } else {\n            if(divd < Integer.MAX_VALUE) {\n                quo++;\n            }\n            return quo;\n        }\n    }\n}",
            "compare_result": "0000000000011100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000001010101000110001110100101100111110100100011100000100001111110101010011000011000000011100010010000100111001101001010100010110111100110111111111111111101111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 871898225,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672920650,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/871898225/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0, divd = dividend;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) {\n            if(divd == Integer.MIN_VALUE) {\n                quo++;\n            }\n            return -quo;\n        } else {\n            if(divd == Integer.MAX_VALUE) {\n                quo++;\n            }\n            return quo;\n        }\n    }\n}",
            "compare_result": "1111111111101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 871888785,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672919370,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/871888785/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            }\n            if(dividend < 0) {\n                bool = true;\n                if(dividend == Integer.MIN_VALUE) {\n                    if(divisor == 1)   return dividend;\n                    dividend = Integer.MAX_VALUE;\n                } else {\n                    dividend = Math.abs(dividend);\n                }\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) return -(quo);\n        return quo;\n    }\n}",
            "compare_result": "1111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 871883465,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672918645,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/871883465/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            if(divisor == Integer.MIN_VALUE) {\n                divisor = Integer.MAX_VALUE;\n            } else {\n                divisor = Math.abs(divisor);\n            }\n            if(dividend == Integer.MIN_VALUE) {\n                dividend = Integer.MAX_VALUE;\n            } else {\n                dividend = Math.abs(dividend);\n            }\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            divisor = Math.abs(divisor);\n            }\n            if(dividend < 0) {\n                bool = true;\n                dividend = Math.abs(dividend);\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) return -(quo);\n        return quo;\n    }\n}",
            "compare_result": "1111111111110101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 871876496,
            "question_id": 29,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672917702,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/871876496/",
            "is_pending": "Not Pending",
            "title": "Divide Two Integers",
            "memory": "N/A",
            "code": "class Solution {\n    public int divide(int dividend, int divisor) {\n        int quo=0, rem = 0;\n        boolean bool = false;\n        if(divisor < 0 && dividend < 0) {\n            bool = false;\n            divisor = Math.abs(divisor);\n            dividend = Math.abs(dividend);\n        } else {\n            if(divisor < 0) {\n            bool = true;\n            divisor = Math.abs(divisor);\n            }\n            if(dividend < 0) {\n                bool = true;\n                dividend = Math.abs(dividend);\n            }\n        }\n        while(dividend>=divisor) {\n            dividend -= divisor;\n            quo++;\n        }\n        if(bool) return -(quo);\n        return quo;\n    }\n}",
            "compare_result": "1111111111010101101110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "divide-two-integers",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 869099579,
            "question_id": 442,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672583351,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/869099579/",
            "is_pending": "Not Pending",
            "title": "Find All Duplicates in an Array",
            "memory": "50.4 MB",
            "code": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> li = new ArrayList<>();\n        for(int i=0; i<nums.length; i++) {\n            int index = Math.abs(nums[i]);\n            if(nums[index-1] > 0) {\n                nums[index-1] = -nums[index-1];\n            } else {\n                li.add(Math.abs(nums[i]));\n            }\n        }\n        return li;\n    }\n}",
            "compare_result": "1111111111111111111111111111",
            "title_slug": "find-all-duplicates-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 869098325,
            "question_id": 442,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672583165,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/869098325/",
            "is_pending": "Not Pending",
            "title": "Find All Duplicates in an Array",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> li = new ArrayList<>();\n        for(int i=0; i<nums.length; i++) {\n            int index = Math.abs(nums[i]);\n            if(nums[index-1] > 0) {\n                nums[index-1] = -nums[index-1];\n            } else {\n                li.add(Math.abs(nums[index-1]));\n            }\n        }\n        return li;\n    }\n}",
            "compare_result": "1111110010000000000000000000",
            "title_slug": "find-all-duplicates-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 869051410,
            "question_id": 442,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672576608,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1143 ms",
            "url": "/submissions/detail/869051410/",
            "is_pending": "Not Pending",
            "title": "Find All Duplicates in an Array",
            "memory": "51.2 MB",
            "code": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        List<Integer> li = new ArrayList<>();\n        for(int i=0; i<nums.length; i++) {\n            try {\n                map.put(nums[i], map.get(nums[i])+1);\n            } catch(Exception e) {\n                map.put(nums[i], 1);\n            }\n        }\n        for(Map.Entry<Integer,Integer> i : map.entrySet()) {\n            if(i.getValue() > 1) {\n                li.add(i.getKey());\n            }\n        }\n        return li;\n    }\n}",
            "compare_result": "1111111111111111111111111111",
            "title_slug": "find-all-duplicates-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 869049394,
            "question_id": 442,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672576284,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1167 ms",
            "url": "/submissions/detail/869049394/",
            "is_pending": "Not Pending",
            "title": "Find All Duplicates in an Array",
            "memory": "51.2 MB",
            "code": "class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        List<Integer> li = new ArrayList<>();\n        for(int i=0; i<nums.length; i++) {\n            try {\n                map.put(nums[i], map.get(nums[i])+1);\n            } catch(Exception e) {\n                map.put(nums[i], 1);\n            }\n        }\n        for(Map.Entry<Integer,Integer> i : map.entrySet()) {\n            if(i.getValue() > 1) {\n                li.add(i.getKey());\n            }\n        }\n        return li;\n    }\n}",
            "compare_result": "1111111111111111111111111111",
            "title_slug": "find-all-duplicates-in-an-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 866867506,
            "question_id": 136,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672221944,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/866867506/",
            "is_pending": "Not Pending",
            "title": "Single Number",
            "memory": "42.5 MB",
            "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int finalNum = 0;\n        for(int i=0; i<nums.length; i++) {\n            finalNum ^= nums[i];\n        }\n        return finalNum;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "single-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 866837340,
            "question_id": 198,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672217478,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/866837340/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\n    public int rob(int[] nums) {\n        int sum = 0, i = 0;\n\t    if(nums.length == 1) {\n\t        return nums[0];\n\t    }\n\t    else if(nums.length == 2) {\n\t        if(nums[0] < nums[1]) {\n\t            return nums[1];\n\t        } else {\n\t            return nums[0];\n\t        }\n\t    } else if(nums.length == 3) {\n\t        if(nums[0]+nums[2] > nums[1]) {\n\t            return nums[0]+nums[2];\n\t        } else {\n\t            return nums[1];\n\t        }\n\t    } else if(nums.length > 3) {\n\t        if(nums[0]+nums[2] > nums[1]+nums[3]) {\n\t            i = 0;\n\t        } else {\n\t            i = 1;\n\t        }\n            for(;i<nums.length; i+=2) {\n                sum += nums[i];\n            }\n\t    }\n        return sum;\n    }\n}",
            "compare_result": "1111111111111111111110111111100111010110001000000000000000000000000111",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 866835824,
            "question_id": 198,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 3 months",
            "timestamp": 1672217252,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/866835824/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\n    public int rob(int[] nums) {\n        int sum = 0, i = 0;\n\t    if(nums.length == 1) {\n\t        return nums[0];\n\t    }\n\t    else if(nums.length == 2) {\n\t        if(nums[0] < nums[1]) {\n\t            return nums[1];\n\t        } else {\n\t            return nums[0];\n\t        }\n\t    } else if(nums.length == 3) {\n\t        if(nums[0]+nums[2] > nums[1]) {\n\t            return nums[0]+nums[2];\n\t        } else {\n\t            return nums[1];\n\t        }\n\t    } else if(nums.length > 3) {\n\t        if(nums[0]+nums[2] > nums[1]+nums[3]) {\n\t            i = 0;\n\t        } else {\n\t            i = 1;\n\t        }\n            for(i=0;i<nums.length; i+=2) {\n                sum += nums[i];\n            }\n\t    }\n        return sum;\n    }\n}",
            "compare_result": "1111111111111111010100110100100111001111000000000000000000000000000101",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862603170,
            "question_id": 198,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671530006,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862603170/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\n    public int rob(int[] nums) {\n        int sum = 0, i = 0;\n\t    if(nums.length == 1) {\n\t        return nums[0];\n\t    }\n\t    else if(nums.length == 2) {\n\t        if(nums[0] < nums[1]) {\n\t            return nums[1];\n\t        } else {\n\t            return nums[0];\n\t        }\n\t    } else if(nums[1] > nums[0]) {\n\t        i = 1;\n\t    }\n        for(;i<nums.length; i+=2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}",
            "compare_result": "00111111111101111101101110110001110000110010000000000000000000000001",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862601188,
            "question_id": 198,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671529693,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862601188/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\n    public int rob(int[] nums) {\n        int sum = 0;\n        if(nums.length == 2) {\n\t        if(nums[0] < nums[1]) {\n\t            return nums[1];\n\t        } else {\n\t            return nums[0];\n\t        }\n\t    }\n        for(int i=0; i<nums.length; i+=2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}",
            "compare_result": "11111111111011110101001101001000110011110000000000000000000000000001",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862600325,
            "question_id": 198,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671529552,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862600325/",
            "is_pending": "Not Pending",
            "title": "House Robber",
            "memory": "N/A",
            "code": "class Solution {\n    public int rob(int[] nums) {\n        int sum = 0;\n        for(int i=0; i<nums.length; i+=2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}",
            "compare_result": "11111110111011110101001101001000010011110000000000000000000000000001",
            "title_slug": "house-robber",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862597815,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671529143,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/862597815/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "83.9 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n                continue;\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862597748,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671529133,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/862597748/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "76.6 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n                continue;\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862596376,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671528924,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/862596376/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "84 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862596185,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671528898,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/862596185/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "83.4 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862596007,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671528873,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/862596007/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "77.3 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862595953,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671528865,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/862595953/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "83.9 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862595905,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671528855,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/862595905/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "84.1 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862595746,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671528830,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/862595746/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "83.3 MB",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int leastBuyPrice = Integer.MAX_VALUE, overallProfit = 0, profitIfSoldToday = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] < leastBuyPrice) {\n                leastBuyPrice = prices[i];\n            }\n            profitIfSoldToday = prices[i] - leastBuyPrice;\n            if(overallProfit < profitIfSoldToday) {\n                overallProfit = profitIfSoldToday;\n            }\n        }\n        return overallProfit;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862585233,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671527205,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/862585233/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "N/A",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int[] arr1 = prices.clone();\n        int min=0, max=0, finalMax=0;\n        Arrays.sort(arr1);\n        List<Integer> li = new ArrayList<>();\n        for(int j=0; j<arr1.length; j++) {\n            min = arr1[j];\n            max = min;\n            int index = 0;\n            for(int i=0; i<prices.length; i++) {\n                if(prices[i] == min) {\n                    index = i;\n                    break;\n                }\n            }\n            for(int i=index+1; i<prices.length; i++) {\n                if(max<prices[i]) {\n                    max = prices[i];\n                }\n            }\n            li.add(max-min);\n        }\n        return Collections.max(li);\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862583269,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671526882,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862583269/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "N/A",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int[] arr1 = prices.clone();\n        int min=0, max=0, finalMax=0;\n        Arrays.sort(arr1);\n        List<Integer> li = new ArrayList<>();\n        for(int j=0; j<arr1.length; j++) {\n            min = arr1[j];\n            max = min;\n            int index = 0;\n            for(int i=0; i<prices.length; i++) {\n                if(prices[i] == min) index = i;\n            }\n            for(int i=index+1; i<prices.length; i++) {\n                if(max<prices[i]) {\n                    max = prices[i];\n                }\n            }\n            li.add(max-min);\n        }\n        return Collections.max(li);\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111010101111111101111110111101110100000000000",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862552759,
            "question_id": 121,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671522148,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862552759/",
            "is_pending": "Not Pending",
            "title": "Best Time to Buy and Sell Stock",
            "memory": "N/A",
            "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int[] arr = prices.clone();\n        Arrays.sort(arr);\n        int min = arr[0];\n        int max = min;\n        int index = 0;\n        for(int i=0; i<prices.length; i++) {\n            if(prices[i] == min) index = i;\n        }\n        for(int i=index+1; i<prices.length; i++) {\n            if(max<prices[i]) {\n                max = prices[i];\n            }\n        }\n        return max-min;\n    }\n}",
            "compare_result": "1111111110111110111110111111111100011100011101111111111111111111111111111111111100011100000000011111111100011100000000011111111100011100000000011111111100011100011101101010001110111101111110111101010101010100110",
            "title_slug": "best-time-to-buy-and-sell-stock",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862082543,
            "question_id": 35,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671450012,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/862082543/",
            "is_pending": "Not Pending",
            "title": "Search Insert Position",
            "memory": "41.7 MB",
            "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] > target && nums.length == 1) {\n\t        return 0;\n\t    } else if(nums[0] < target && nums.length == 1) {\n\t        return 1;\n\t    }\n        for(int i=0; i<nums.length; i++) {\n\t        if(nums[i] == target) {\n\t            return i;\n\t        } else if(i+1 < nums.length) {\n\t            if(nums[i] > target) {\n\t                return i;\n\t            } else if(nums[i] < target && nums[i+1] > target) {\n\t                return i+1;\n\t            }\n\t        }\n\t    }\n\t    return nums.length;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-insert-position",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862082025,
            "question_id": 35,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671449922,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/862082025/",
            "is_pending": "Not Pending",
            "title": "Search Insert Position",
            "memory": "43.3 MB",
            "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] > target && nums.length == 1) {\n\t        return 0;\n\t    } else if(nums[0] < target && nums.length == 1) {\n\t        return 1;\n\t    }\n        for(int i=0; i<nums.length; i++) {\n\t        if(nums[i] == target) {\n\t            return i;\n\t        } else if(i+1 < nums.length) {\n\t            if(nums[i] > target) {\n\t                return i;\n\t            } else if(nums[i] < target && nums[i+1] > target) {\n\t                return i+1;\n\t            }\n\t        }\n\t    }\n\t    return nums.length;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-insert-position",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862080941,
            "question_id": 35,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671449742,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862080941/",
            "is_pending": "Not Pending",
            "title": "Search Insert Position",
            "memory": "N/A",
            "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        for(int i=0; i<nums.length; i++) {\n\t        if(nums[i] == target) {\n\t            return i;\n\t        } else if(i+1 < nums.length) {\n\t            if(nums[i] > target) {\n\t                return i;\n\t            } else if(nums[i] < target && nums[i+1] > target) {\n\t                return i+1;\n\t            }\n\t        }\n\t    }\n\t    return nums.length;\n    }\n}",
            "compare_result": "1111011111111111111111111111111111111111111111111111111111111111",
            "title_slug": "search-insert-position",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862080276,
            "question_id": 35,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671449620,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862080276/",
            "is_pending": "Not Pending",
            "title": "Search Insert Position",
            "memory": "N/A",
            "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] != 0 && target == 0) {\n\t        return 0;\n\t    }\n        for(int i=0; i<nums.length; i++) {\n\t        if(nums[i] == target) {\n\t            return i;\n\t        } else if(i+1 < nums.length) {\n\t            if(nums[i] > target) {\n\t                return i;\n\t            } else if(nums[i] < target && nums[i+1] > target) {\n\t                return i+1;\n\t            }\n\t        }\n\t    }\n\t    return nums.length;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111100111",
            "title_slug": "search-insert-position",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862078614,
            "question_id": 35,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671449327,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862078614/",
            "is_pending": "Not Pending",
            "title": "Search Insert Position",
            "memory": "N/A",
            "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums[0] != 0 && target == 0) {\n\t        return 0;\n\t    }\n        for(int i=0; i<nums.length; i++) {\n\t        if(nums[i] == target) {\n\t            return i;\n\t        } else if(i+1 < nums.length) {\n\t            if(nums[i] < target && nums[i+1] > target) {\n\t                return i+1;\n\t            }\n\t        }\n\t    }\n\t    return nums.length;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111011111111111111101011111100110",
            "title_slug": "search-insert-position",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862077723,
            "question_id": 35,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671449154,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862077723/",
            "is_pending": "Not Pending",
            "title": "Search Insert Position",
            "memory": "N/A",
            "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        for(int i=0; i<nums.length; i++) {\n\t        if(nums[i] == target) {\n\t            return i;\n\t        } else if(i+1 < nums.length) {\n\t            if(nums[i] < target && nums[i+1] > target) {\n\t                return i+1;\n\t            }\n\t        }\n\t    }\n\t    return nums.length;\n    }\n}",
            "compare_result": "1110011011110111111011101110111111001111111111111101011111111110",
            "title_slug": "search-insert-position",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862071546,
            "question_id": 2585,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671448047,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/862071546/",
            "is_pending": "Not Pending",
            "title": "Delete Greatest Value in Each Row",
            "memory": "42.3 MB",
            "code": "class Solution {\n    public int deleteGreatestValue(int[][] grid) {\n        int sum = 0;\n        for(int i=0; i<grid.length; i++)\n            Arrays.sort(grid[i]);\n        for(int i=0; i<grid[0].length; i++){\n            int max = 0;\n            for(int j=0; j<grid.length; j++)    \n                max = Math.max(max, grid[j][i]);\n            sum += max;\n        }\n        return sum;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111",
            "title_slug": "delete-greatest-value-in-each-row",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862043845,
            "question_id": 2585,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671443230,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862043845/",
            "is_pending": "Not Pending",
            "title": "Delete Greatest Value in Each Row",
            "memory": "N/A",
            "code": "class Solution {\n    public int deleteGreatestValue(int[][] grid) {\n        int sum = 0, max = 0, x = 0, y = 0;\n        List<Integer> li = new ArrayList<>();\n        List<Integer> finalList = new ArrayList<>();\n        for(int z=0; z<grid[0].length; z++) {\n            for(int i=0; i<grid.length; i++) {\n                for(int j=0; j<grid[i].length; j++) {\n                    if(grid[i][j] > max) {\n                        max = grid[i][j];\n                        x = i;\n                        y = j;\n                    }\n                }\n                int[][] temp = new int[grid.length][grid[0].length];\n                for(int k=0; k<grid.length; k++) {\n                    for(int l=0; l<grid[k].length; l++) {\n                        if(grid[k][l] != grid[x][y]) {\n                            temp[k][l] = grid[k][l];\n                        }\n                        else {\n                            temp[k][l] = 0;\n                            x = y = 0;\n                        }\n                    }\n                }\n                grid = temp;\n                li.add(max);\n                max = 0;\n            }\n            int val = Collections.max(li);\n            finalList.add(val);\n            li.clear();\n        }\n        for(int i : finalList) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
            "compare_result": "1111111010000000000000000000000000000000000000001111001",
            "title_slug": "delete-greatest-value-in-each-row",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 862032072,
            "question_id": 2585,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671441248,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/862032072/",
            "is_pending": "Not Pending",
            "title": "Delete Greatest Value in Each Row",
            "memory": "N/A",
            "code": "class Solution {\n    public int deleteGreatestValue(int[][] grid) {\n        int sum = 0, max = 0, x = 0, y = 0;\n        List<Integer> li = new ArrayList<>();\n        List<Integer> finalList = new ArrayList<>();\n        for(int z=0; z<=grid.length; z++) {\n            for(int i=0; i<grid.length; i++) {\n                for(int j=0; j<grid[i].length; j++) {\n                    if(grid[i][j] > max) {\n                        max = grid[i][j];\n                        x = i;\n                        y = j;\n                    }\n                }\n                int[][] temp = new int[grid.length][grid[0].length];\n                for(int k=0; k<grid.length; k++) {\n                    for(int l=0; l<grid[k].length; l++) {\n                        if(grid[k][l] != grid[x][y]) {\n                            temp[k][l] = grid[k][l];\n                        }\n                        else {\n                            temp[k][l] = 0;\n                            x = y = 0;\n                        }\n                    }\n                }\n                grid = temp;\n                li.add(max);\n                max = 0;\n            }\n            int val = Collections.max(li);\n            finalList.add(val);\n            li.clear();\n        }\n        for(int i : finalList) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
            "compare_result": "1110111000000000000000000000000000000000000000000000001",
            "title_slug": "delete-greatest-value-in-each-row",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 861750742,
            "question_id": 1319,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671388185,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/861750742/",
            "is_pending": "Not Pending",
            "title": "Unique Number of Occurrences",
            "memory": "40.5 MB",
            "code": "class Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        HashMap<Integer, Integer> occr = new HashMap<Integer, Integer>();\n        for (int i = 0; i < arr.length; i++) {\n            if (occr.containsKey(arr[i])) {\n                occr.put(arr[i], occr.get(arr[i]) + 1);\n            } else {\n                occr.put(arr[i], 1);\n            }\n        }\n        int c = 0;\n        HashMap<Integer, Integer> occr1 = new HashMap<Integer, Integer>();\n        for(Map.Entry<Integer,Integer> val1 : occr.entrySet()) {\n            occr1.put(val1.getValue(), val1.getValue());\n            c++;\n        }\n        return occr.size() == occr1.size();\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "unique-number-of-occurrences",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 861750483,
            "question_id": 1319,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671388144,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/861750483/",
            "is_pending": "Not Pending",
            "title": "Unique Number of Occurrences",
            "memory": "40.5 MB",
            "code": "class Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        HashMap<Integer, Integer> occr = new HashMap<Integer, Integer>();\n        for (int i = 0; i < arr.length; i++) {\n            if (occr.containsKey(arr[i])) {\n                occr.put(arr[i], occr.get(arr[i]) + 1);\n            } else {\n                occr.put(arr[i], 1);\n            }\n        }\n        int c = 0;\n        HashMap<Integer, Integer> occr1 = new HashMap<Integer, Integer>();\n        for(Map.Entry<Integer,Integer> val1 : occr.entrySet()) {\n            occr1.put(val1.getValue(), val1.getValue());\n            c++;\n        }\n        return occr.size() == occr1.size();\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "unique-number-of-occurrences",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 861750419,
            "question_id": 1319,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671388132,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "6 ms",
            "url": "/submissions/detail/861750419/",
            "is_pending": "Not Pending",
            "title": "Unique Number of Occurrences",
            "memory": "42.4 MB",
            "code": "class Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        HashMap<Integer, Integer> occr = new HashMap<Integer, Integer>();\n        for (int i = 0; i < arr.length; i++) {\n            if (occr.containsKey(arr[i])) {\n                occr.put(arr[i], occr.get(arr[i]) + 1);\n            } else {\n                occr.put(arr[i], 1);\n            }\n        }\n        int c = 0;\n        HashMap<Integer, Integer> occr1 = new HashMap<Integer, Integer>();\n        for(Map.Entry<Integer,Integer> val1 : occr.entrySet()) {\n            occr1.put(val1.getValue(), val1.getValue());\n            c++;\n        }\n        return occr.size() == occr1.size();\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "unique-number-of-occurrences",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 861737435,
            "question_id": 1319,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671385361,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/861737435/",
            "is_pending": "Not Pending",
            "title": "Unique Number of Occurrences",
            "memory": "42.3 MB",
            "code": "class Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        HashMap<Integer, Integer> occr = new HashMap<Integer, Integer>();\n        for (int i = 0; i < arr.length; i++) {\n            if (occr.containsKey(arr[i])) {\n                occr.put(arr[i], occr.get(arr[i]) + 1);\n            } else {\n                occr.put(arr[i], 1);\n            }\n        }\n        for(Map.Entry<Integer,Integer> val1 : occr.entrySet()) {\n            for(Map.Entry<Integer,Integer> val2 : occr.entrySet()) {\n                if(val1.getKey() != val2.getKey() && val1.getValue() == val2.getValue()) {\n                    return false;\n                }   \n            }   \n        }\n        return true;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "unique-number-of-occurrences",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860750676,
            "question_id": 231,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671210789,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/860750676/",
            "is_pending": "Not Pending",
            "title": "Power of Two",
            "memory": "39.3 MB",
            "code": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        if(n==0) {\n            return false;\n        }\n        while(n!=1) {\n            if(n%2 != 0) {\n                return false;\n            }\n            n /= 2;\n        }\n        return true;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "power-of-two",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860650449,
            "question_id": 231,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671194172,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/860650449/",
            "is_pending": "Not Pending",
            "title": "Power of Two",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        if(n==0) {\n            return false;\n        }\n        if(n!=1) {\n            if(n%2 != 0) {\n                return false;\n            }\n            n /= 2;\n            isPowerOfTwo(n);\n        }\n        return true;\n    }\n}",
            "compare_result": "1111101110101011101010101010101110101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101110101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101110101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101011111111111111111111111111111111111111111111111111111111111111101101010101010101011010",
            "title_slug": "power-of-two",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860649372,
            "question_id": 231,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671193960,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/860649372/",
            "is_pending": "Not Pending",
            "title": "Power of Two",
            "memory": "39.5 MB",
            "code": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        if(n==0) {\n            return false;\n        }\n        while(n!=1) {\n            if(n%2 != 0) {\n                return false;\n            }\n            n /= 2;\n        }\n        return true;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "power-of-two",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860640975,
            "question_id": 1054,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671192341,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/860640975/",
            "is_pending": "Not Pending",
            "title": "Complement of Base 10 Integer",
            "memory": "39.4 MB",
            "code": "class Solution {\n    public int bitwiseComplement(int n) {\n        int m = n;\n\t    int mask = 0;\n        if(n==0) {\n            return 1;\n        }\n        while(m!=0) {\n            mask = mask << 1 | 1;\n            m = m>>1;\n        }\n        return (~n)&mask;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "complement-of-base-10-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860172091,
            "question_id": 58,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671108738,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/860172091/",
            "is_pending": "Not Pending",
            "title": "Length of Last Word",
            "memory": "40.5 MB",
            "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        s = s.replaceAll(\"\\\\s+\",\" \").trim();\n\t    int c = 0;\n\t    for(int i=s.length()-1; i>=0; i--) {\n\t        if(Character.compare(s.charAt(i), ' ') != 0) {\n\t            c++;\n\t        } else {\n\t            if(c > 0) return c;\n\t        }\n\t    }\n\t    return c;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "length-of-last-word",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860133257,
            "question_id": 58,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671101470,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/860133257/",
            "is_pending": "Not Pending",
            "title": "Length of Last Word",
            "memory": "40.9 MB",
            "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        s = s.replaceAll(\"\\\\s+\",\" \").trim();\n\t    int c = 0;\n\t    for(int i=s.length()-1; i>=0; i--) {\n\t        if(Character.compare(s.charAt(i), ' ') == 0) {\n\t            return c;\n\t        } else {\n\t            c++;\n\t        }\n\t    }\n\t    return c;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "length-of-last-word",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860131193,
            "question_id": 58,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671101078,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/860131193/",
            "is_pending": "Not Pending",
            "title": "Length of Last Word",
            "memory": "41 MB",
            "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        s = s.replaceAll(\"\\\\s+\",\" \").trim();\n\t    String[] splittedStr = s.split(\"\\\\s+\");\n\t    return splittedStr[splittedStr.length-1].length();\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "title_slug": "length-of-last-word",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860113501,
            "question_id": 20,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671097749,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/860113501/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "40.4 MB",
            "code": "class Solution {\n    public boolean isValid(String s) {\n        if(s.length() <= 1) {\n\t\t    return false;\n\t\t}\n\t\tList<Character> li = new ArrayList<Character>();\n        for(int i=0; i<s.length(); i++) {\n            if(i+1 <= s.length()) {\n                if(Character.compare(s.charAt(i),'(') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'[') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'{') == 0) {\n                    li.add(s.charAt(i));\n                }\n                if(Character.compare(s.charAt(i),')') == 0 || Character.compare(s.charAt(i),']') == 0 || Character.compare(s.charAt(i),'}') == 0) {\n                    if(i < s.length()) {\n                        if(i-1 >= 0 && li.size() > 0) {\n                            if(Character.compare(s.charAt(i),')') == 0 && Character.compare(li.get(li.size()-1),'(') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),']') == 0 && Character.compare(li.get(li.size()-1),'[') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),'}') == 0 && Character.compare(li.get(li.size()-1),'{') == 0) {\n                                li.remove(li.size()-1);\n                            } else {\n                                return false;\n                            }\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return li.size() == 0;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860112722,
            "question_id": 20,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671097619,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/860112722/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "40.1 MB",
            "code": "class Solution {\n    public boolean isValid(String s) {\n        if(s.length() <= 1) {\n\t\t    return false;\n\t\t}\n\t\tList<Character> li = new ArrayList<Character>();\n        for(int i=0; i<s.length(); i++) {\n            if(i+1 <= s.length()) {\n                if(Character.compare(s.charAt(i),'(') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'[') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'{') == 0) {\n                    li.add(s.charAt(i));\n                }\n                if(Character.compare(s.charAt(i),')') == 0 || Character.compare(s.charAt(i),']') == 0 || Character.compare(s.charAt(i),'}') == 0) {\n                    if(i < s.length()) {\n                        if(i-1 >= 0 && li.size() > 0) {\n                            if(Character.compare(s.charAt(i),')') == 0 && Character.compare(li.get(li.size()-1),'(') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),']') == 0 && Character.compare(li.get(li.size()-1),'[') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),'}') == 0 && Character.compare(li.get(li.size()-1),'{') == 0) {\n                                li.remove(li.size()-1);\n                            } else {\n                                return false;\n                            }\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        if(li.size() == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860111751,
            "question_id": 20,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671097455,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/860111751/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean isValid(String s) {\n        if(s.length() <= 1) {\n\t\t    return false;\n\t\t}\n\t\tList<Character> li = new ArrayList<Character>();\n        for(int i=0; i<s.length(); i++) {\n            if(i+1 <= s.length()) {\n                if(Character.compare(s.charAt(i),'(') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'[') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'{') == 0) {\n                    li.add(s.charAt(i));\n                }\n                if(Character.compare(s.charAt(i),')') == 0 || Character.compare(s.charAt(i),']') == 0 || Character.compare(s.charAt(i),'}') == 0) {\n                    if(i < s.length()) {\n                        if(i-1 >= 0 && li.size() > 0) {\n                            if(Character.compare(s.charAt(i),')') == 0 && Character.compare(li.get(li.size()-1),'(') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),']') == 0 && Character.compare(li.get(li.size()-1),'[') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),'}') == 0 && Character.compare(li.get(li.size()-1),'{') == 0) {\n                                li.remove(li.size()-1);\n                            }\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        if(li.size() == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
            "compare_result": "11111111111111111111110111011111111011111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860109530,
            "question_id": 20,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671097057,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/860109530/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean isValid(String s) {\n        if(s.length() <= 1) {\n\t\t    return false;\n\t\t}\n\t\tList<Character> li = new ArrayList<Character>();\n        for(int i=0; i<s.length(); i++) {\n            if(i+1 <= s.length()) {\n                if(Character.compare(s.charAt(i),'(') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'[') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'{') == 0) {\n                    li.add(s.charAt(i));\n                }\n                if(Character.compare(s.charAt(i),')') == 0 || Character.compare(s.charAt(i),']') == 0 || Character.compare(s.charAt(i),'}') == 0) {\n                    if(i < s.length()) {\n                        if(i-1 >= 0 && li.size() > 0) {\n                            if(Character.compare(s.charAt(i),')') == 0 && Character.compare(li.get(li.size()-1),'(') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),']') == 0 && Character.compare(li.get(li.size()-1),'[') == 0) {\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),'}') == 0 && Character.compare(li.get(li.size()-1),'{') == 0) {\n                                li.remove(li.size()-1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(li.size() == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
            "compare_result": "11111111111111101011110011001111011011111111111111111111111111111111111111111111111111111111",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 860106048,
            "question_id": 20,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1671096424,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/860106048/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean isValid(String s) {\n        if(s.length() <= 1) {\n\t\t    return false;\n\t\t}\n\t\tList<Character> li = new ArrayList<Character>();\n        for(int i=0; i<s.length(); i++) {\n            System.out.println(\"li: \" + li);\n            if(i+1 <= s.length()) {\n                if(Character.compare(s.charAt(i),'(') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'[') == 0) {\n                    li.add(s.charAt(i));\n                } else if(Character.compare(s.charAt(i),'{') == 0) {\n                    li.add(s.charAt(i));\n                }\n                if(Character.compare(s.charAt(i),')') == 0 || Character.compare(s.charAt(i),']') == 0 || Character.compare(s.charAt(i),'}') == 0) {\n                    if(i < s.length()) {\n                        if(i-1 >= 0) {\n                            if(Character.compare(s.charAt(i),')') == 0 && Character.compare(li.get(li.size()-1),'(') == 0) {\n                                System.out.println(\"li: \" + li);\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),']') == 0 && Character.compare(li.get(li.size()-1),'[') == 0) {\n                                System.out.println(\"li: \" + li);\n                                li.remove(li.size()-1);\n                            } else if(Character.compare(s.charAt(i),'}') == 0 && Character.compare(li.get(li.size()-1),'{') == 0) {\n                                System.out.println(\"li: \" + li);\n                                li.remove(li.size()-1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(li.size() == 0) {\n            System.out.println(\"true\");\n            return true;\n        } else {\n            System.out.println(\"false\");\n            return false;\n        }\n    }\n}",
            "compare_result": "11111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 859539479,
            "question_id": 20,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670999407,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/859539479/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean isValid(String s) {\n        for(int i=0; i<s.length(); i+=2) {\n            if(Character.compare(s.charAt(i),'(') == 0) {\n                if((Character.compare(s.charAt(i+1),')')) != 0) {\n                    return false;\n                }\n            } else if(Character.compare(s.charAt(i+1),'[') == 0) {\n                if((Character.compare(s.charAt(i),']')) != 0) {\n                    return false;\n                }\n            } else if(Character.compare(s.charAt(i+1),'{') == 0) {\n                if((Character.compare(s.charAt(i),'}')) != 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
            "compare_result": "11110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 859530437,
            "question_id": 20,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670998168,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/859530437/",
            "is_pending": "Not Pending",
            "title": "Valid Parentheses",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean isValid(String s) {\n        for(int i=0; i<s.length(); i+=2) {\n            if((Character.compare(s.charAt(i),s.charAt(i+1))) == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
            "compare_result": "11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "valid-parentheses",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 859474695,
            "question_id": 7,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670989792,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/859474695/",
            "is_pending": "Not Pending",
            "title": "Reverse Integer",
            "memory": "39.9 MB",
            "code": "class Solution {\n    public int reverse(int x) {\n        int sum = 0;\n        int rem = 0;\n        while(x != 0) {\n            rem = x%10;\n            if((sum > Integer.MAX_VALUE/10) || (sum < Integer.MIN_VALUE/10)) {\n                return 0;\n            }\n            sum = Math.addExact(Math.multiplyExact(sum, 10), rem);\n            x /= 10;\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 859134331,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670932451,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "12 ms",
            "url": "/submissions/detail/859134331/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "45.5 MB",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        if(strs.length < 2) {\n            return strs[0];\n        }\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    } else if(!lngCmnPrefix.equals(strs[j].substring(0,lngCmnPrefix.length()))) {\n                        return lngCmnPrefix.substring(0,lngCmnPrefix.length()-1);\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 859134272,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670932440,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "16 ms",
            "url": "/submissions/detail/859134272/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "44.8 MB",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        if(strs.length < 2) {\n            return strs[0];\n        }\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    } else if(!lngCmnPrefix.equals(strs[j].substring(0,lngCmnPrefix.length()))) {\n                        return lngCmnPrefix.substring(0,lngCmnPrefix.length()-1);\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 859132786,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670932182,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/859132786/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "44.8 MB",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        if(strs.length < 2) {\n            return strs[0];\n        }\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    } else if(!lngCmnPrefix.equals(strs[j].substring(0,lngCmnPrefix.length()))) {\n                        return lngCmnPrefix.substring(0,lngCmnPrefix.length()-1);\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 859130558,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670931790,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/859130558/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "N/A",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        if(strs.length < 2) {\n            return strs[0];\n        }\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    } else {\n                        if(i==0) {\n                            if(!lngCmnPrefix.equals((Character.toString(strs[j].charAt(i))))) {\n                                return \"\";\n                            }   \n                        }\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111101111111011111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 857059840,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670577626,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/857059840/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "N/A",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        if(strs.length < 2) {\n            return strs[0];\n        }\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        // if(finalLngCmnPrefix.length() == 1) {\n        //     finalLngCmnPrefix = \"\";\n        // }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1111111111111111111111111111111110011110111111111101111110011111101111111011111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 857059139,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670577497,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/857059139/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "N/A",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        if(strs.length < 2) {\n            return strs[0];\n        }\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        if(finalLngCmnPrefix.length() == 1) {\n            finalLngCmnPrefix = \"\";\n        }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1111110011010010001110111111111111111011100100111011111111111111100010010011000000000111111111111111111111111111111111101111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 857051379,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670576091,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/857051379/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "N/A",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        if(finalLngCmnPrefix.length() == 1) {\n            finalLngCmnPrefix = \"\";\n        }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1110110011010010001110111111111111111011100100111011111111111111100010010011000000000111111111111111111111111111111111101111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 857048817,
            "question_id": 14,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670575623,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/857048817/",
            "is_pending": "Not Pending",
            "title": "Longest Common Prefix",
            "memory": "N/A",
            "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        String lngCmnPrefix = \"\";\n        String finalLngCmnPrefix = \"\";\n        loop:\n        for(int i=0; i<strs[0].length(); i++) {\n\t\t\tlngCmnPrefix = lngCmnPrefix.concat(Character.toString(strs[0].charAt(i)));\n            for(int j=1; j<strs.length; j++) {\n                    if(!strs[j].contains(lngCmnPrefix)) {\n                        break loop;\n                    }\n            }\n            finalLngCmnPrefix = lngCmnPrefix;\n        }\n        return finalLngCmnPrefix;\n    }\n}",
            "compare_result": "1111111111111111111111111111111110011110111111111101111110011111101111111011111111111111111111111111111111111111111111111111",
            "title_slug": "longest-common-prefix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 856497343,
            "question_id": 7,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670482025,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/856497343/",
            "is_pending": "Not Pending",
            "title": "Reverse Integer",
            "memory": "41.7 MB",
            "code": "class Solution {\n    public int reverse(int x) {\n        int sum = 0;\n        int rem = 0;\n        while(x != 0) {\n            rem = x%10;\n            try {\n                sum = Math.addExact(Math.multiplyExact(sum, 10), rem);\n                x /= 10;\n            } catch (ArithmeticException ex) {\n                return 0;\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 856484995,
            "question_id": 7,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670480348,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/856484995/",
            "is_pending": "Not Pending",
            "title": "Reverse Integer",
            "memory": "41.9 MB",
            "code": "class Solution {\n    public int reverse(int x) {\n        int sum = 0;\n        int rem = 0;\n        while(x != 0) {\n            rem = x%10;\n            try {\n                sum = Math.addExact(Math.multiplyExact(sum, 10), rem);\n                x /= 10;\n            } catch (ArithmeticException ex) {\n                return 0;\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 856483292,
            "question_id": 7,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1670480124,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/856483292/",
            "is_pending": "Not Pending",
            "title": "Reverse Integer",
            "memory": "41.5 MB",
            "code": "class Solution {\n    public int reverse(int x) {\n        int sum = 0;\n        while(x != 0) {\n            int rem = x%10;\n            try {\n                sum = Math.addExact(Math.multiplyExact(sum, 10), rem);\n                x /= 10;\n            } catch (ArithmeticException ex) {\n                return 0;\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reverse-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 851111358,
            "question_id": 7,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1669629148,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/851111358/",
            "is_pending": "Not Pending",
            "title": "Reverse Integer",
            "memory": "N/A",
            "code": "class Solution {\n    public int reverse(int x) {\n        int sum = 0;\n        while(x != 0) {\n            int rem = x%10;\n            sum = (sum*10) + rem;\n            x /= 10;\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110011111010",
            "title_slug": "reverse-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 850571763,
            "question_id": 191,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1669540077,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/850571763/",
            "is_pending": "Not Pending",
            "title": "Number of 1 Bits",
            "memory": "40.9 MB",
            "code": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int count = 0;\n        for(int i=0; i<32; i++) {\n            count += (n&1);\n            n>>>=1;\n        }\n        return count;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-1-bits",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 850564531,
            "question_id": 191,
            "lang": "cpp",
            "lang_name": "C++",
            "time": "1 year, 4 months",
            "timestamp": 1669538789,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/850564531/",
            "is_pending": "Not Pending",
            "title": "Number of 1 Bits",
            "memory": "6 MB",
            "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int count = 0;\n        while(n!=0) {\n            if(n&1) {\n                count++;\n            }\n            n = n >> 1;\n        }\n        return count;\n    }\n};",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-1-bits",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 850564297,
            "question_id": 191,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1669538749,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/850564297/",
            "is_pending": "Not Pending",
            "title": "Number of 1 Bits",
            "memory": "N/A",
            "code": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int count = 0;\n        while(n!=0) {\n            Integer temp = n&1;\n            if(temp == 1) {\n                count++;\n            }\n            n = n>>1;\n        }\n        return count;\n    }\n}",
            "compare_result": "1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "number-of-1-bits",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 850552873,
            "question_id": 1406,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1669536650,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/850552873/",
            "is_pending": "Not Pending",
            "title": "Subtract the Product and Sum of Digits of an Integer",
            "memory": "40.8 MB",
            "code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        int prod = 1, sum = 0;\n        while(n!=0) {\n            int rem = n%10;\n            prod *= rem;\n            sum += rem;\n            n /= 10;\n        }\n        return prod - sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 850552432,
            "question_id": 1406,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 4 months",
            "timestamp": 1669536575,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/850552432/",
            "is_pending": "Not Pending",
            "title": "Subtract the Product and Sum of Digits of an Integer",
            "memory": "40.9 MB",
            "code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        int prod = 1, sum = 0;\n        while(n!=0) {\n            int rem = n%10;\n            prod = prod * rem;\n            sum = sum + rem;\n            n = n / 10;\n        }\n        return prod - sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 843086213,
            "question_id": 13,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 5 months",
            "timestamp": 1668405952,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/843086213/",
            "is_pending": "Not Pending",
            "title": "Roman to Integer",
            "memory": "48.3 MB",
            "code": "class Solution {\n    public int romanToInt(String s) {\n        int sum = 0;\n        List<String> list = new ArrayList<String>();\n        for(int i=0; i<s.length(); i++) {\n            String ch = Character.toString(s.charAt(i));\n            String ch1 = \"\";\n            if(i+1 < s.length()) {\n                ch1 = Character.toString(s.charAt(i+1));\n            }\n            if(ch.equals(\"I\") && i+1 < s.length() && ch1.equals(\"V\")) {\n                sum += 4;\n                i+=1;\n            } else if(ch.equals(\"I\") && i+1 < s.length() && ch1.equals(\"X\")) {\n                sum += 9;\n                i+=1;\n            } else if(ch.equals(\"X\") && i+1 < s.length() && ch1.equals(\"L\")) {\n                sum += 40;\n                i+=1;\n            } else if(ch.equals(\"X\") && i+1 < s.length() && ch1.equals(\"C\")) {\n                sum += 90;\n                i+=1;\n            } else if(ch.equals(\"C\") && i+1 < s.length() && ch1.equals(\"D\")) {\n                sum += 400;\n                i+=1;\n            } else if(ch.equals(\"C\") && i+1 < s.length() && ch1.equals(\"M\")) {\n                sum += 900;\n                i+=1;\n            }\n            else if(ch.equals(\"I\")) {\n                sum += 1;\n            } else if(ch.equals(\"II\")) {\n                sum += 2;\n            } else if(ch.equals(\"III\")) {\n                sum += 3;\n            } else if(ch.equals(\"V\")) {\n                sum += 5;\n            } else if(ch.equals(\"X\")) {\n                sum += 10;\n            } else if(ch.equals(\"L\")) {\n                sum += 50;\n            } else if(ch.equals(\"C\")) {\n                sum += 100;\n            } else if(ch.equals(\"D\")) {\n                sum += 500;\n            } else if(ch.equals(\"M\")) {\n                sum += 1000;\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "roman-to-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 843084234,
            "question_id": 13,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 5 months",
            "timestamp": 1668405695,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "27 ms",
            "url": "/submissions/detail/843084234/",
            "is_pending": "Not Pending",
            "title": "Roman to Integer",
            "memory": "54.2 MB",
            "code": "class Solution {\n    public int romanToInt(String s) {\n        int sum = 0;\n        List<String> list = new ArrayList<String>();\n        for(int i=0; i<s.length(); i++) {\n            char ch = s.charAt(i);\n            char ch1 = 'I';\n            if(i+1 < s.length()) {\n                ch1 = s.charAt(i+1);\n            }\n            if(Character.toString(ch).equals(\"I\") && i+1 < s.length() && Character.toString(ch1).equals(\"V\")) {\n                sum += 4;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"I\") && i+1 < s.length() && Character.toString(ch1).equals(\"X\")) {\n                sum += 9;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"X\") && i+1 < s.length() && Character.toString(ch1).equals(\"L\")) {\n                sum += 40;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"X\") && i+1 < s.length() && Character.toString(ch1).equals(\"C\")) {\n                sum += 90;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"C\") && i+1 < s.length() && Character.toString(ch1).equals(\"D\")) {\n                sum += 400;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"C\") && i+1 < s.length() && Character.toString(ch1).equals(\"M\")) {\n                sum += 900;\n                i+=1;\n            }\n            else if(Character.toString(ch).equals(\"I\")) {\n                sum += 1;\n            } else if(Character.toString(ch).equals(\"II\")) {\n                sum += 2;\n            } else if(Character.toString(ch).equals(\"III\")) {\n                sum += 3;\n            } else if(Character.toString(ch).equals(\"V\")) {\n                sum += 5;\n            } else if(Character.toString(ch).equals(\"X\")) {\n                sum += 10;\n            } else if(Character.toString(ch).equals(\"L\")) {\n                sum += 50;\n            } else if(Character.toString(ch).equals(\"C\")) {\n                sum += 100;\n            } else if(Character.toString(ch).equals(\"D\")) {\n                sum += 500;\n            } else if(Character.toString(ch).equals(\"M\")) {\n                sum += 1000;\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "roman-to-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 843084055,
            "question_id": 13,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 5 months",
            "timestamp": 1668405672,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "24 ms",
            "url": "/submissions/detail/843084055/",
            "is_pending": "Not Pending",
            "title": "Roman to Integer",
            "memory": "54.1 MB",
            "code": "class Solution {\n    public int romanToInt(String s) {\n        int sum = 0;\n        List<String> list = new ArrayList<String>();\n        for(int i=0; i<s.length(); i++) {\n            char ch = s.charAt(i);\n            char ch1 = 'I';\n            if(i+1 < s.length()) {\n                ch1 = s.charAt(i+1);\n            }\n            if(Character.toString(ch).equals(\"I\") && i+1 < s.length() && Character.toString(ch1).equals(\"V\")) {\n                sum += 4;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"I\") && i+1 < s.length() && Character.toString(ch1).equals(\"X\")) {\n                sum += 9;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"X\") && i+1 < s.length() && Character.toString(ch1).equals(\"L\")) {\n                sum += 40;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"X\") && i+1 < s.length() && Character.toString(ch1).equals(\"C\")) {\n                sum += 90;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"C\") && i+1 < s.length() && Character.toString(ch1).equals(\"D\")) {\n                sum += 400;\n                i+=1;\n            } else if(Character.toString(ch).equals(\"C\") && i+1 < s.length() && Character.toString(ch1).equals(\"M\")) {\n                sum += 900;\n                i+=1;\n            }\n            else if(Character.toString(ch).equals(\"I\")) {\n                sum += 1;\n            } else if(Character.toString(ch).equals(\"II\")) {\n                sum += 2;\n            } else if(Character.toString(ch).equals(\"III\")) {\n                sum += 3;\n            } else if(Character.toString(ch).equals(\"V\")) {\n                sum += 5;\n            } else if(Character.toString(ch).equals(\"X\")) {\n                sum += 10;\n            } else if(Character.toString(ch).equals(\"L\")) {\n                sum += 50;\n            } else if(Character.toString(ch).equals(\"C\")) {\n                sum += 100;\n            } else if(Character.toString(ch).equals(\"D\")) {\n                sum += 500;\n            } else if(Character.toString(ch).equals(\"M\")) {\n                sum += 1000;\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "roman-to-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 843070857,
            "question_id": 13,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 5 months",
            "timestamp": 1668403935,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "20 ms",
            "url": "/submissions/detail/843070857/",
            "is_pending": "Not Pending",
            "title": "Roman to Integer",
            "memory": "47.5 MB",
            "code": "class Solution {\n    public int romanToInt(String s) {\n        int sum = 0;\n        List<String> list = new ArrayList<String>();\n        for(int i=0; i<s.length(); i++) {\n            char ch = s.charAt(i); \n            list.add(Character.toString(ch));\n        }\n        for(int i=0; i<list.size(); i++) {\n            if(list.get(i).equals(\"I\") && i+1 < list.size() && list.get(i+1).equals(\"V\")) {\n                sum += 4;\n                i+=1;\n            } else if(list.get(i).equals(\"I\") && i+1 < list.size() && list.get(i+1).equals(\"X\")) {\n                sum += 9;\n                i+=1;\n            } else if(list.get(i).equals(\"X\") && i+1 < list.size() && list.get(i+1).equals(\"L\")) {\n                sum += 40;\n                i+=1;\n            } else if(list.get(i).equals(\"X\") && i+1 < list.size() && list.get(i+1).equals(\"C\")) {\n                sum += 90;\n                i+=1;\n            } else if(list.get(i).equals(\"C\") && i+1 < list.size() && list.get(i+1).equals(\"D\")) {\n                sum += 400;\n                i+=1;\n            } else if(list.get(i).equals(\"C\") && i+1 < list.size() && list.get(i+1).equals(\"M\")) {\n                sum += 900;\n                i+=1;\n            }\n            else if(list.get(i).equals(\"I\")) {\n                sum += 1;\n            } else if(list.get(i).equals(\"II\")) {\n                sum += 2;\n            } else if(list.get(i).equals(\"III\")) {\n                sum += 3;\n            } else if(list.get(i).equals(\"V\")) {\n                sum += 5;\n            } else if(list.get(i).equals(\"X\")) {\n                sum += 10;\n            } else if(list.get(i).equals(\"L\")) {\n                sum += 50;\n            } else if(list.get(i).equals(\"C\")) {\n                sum += 100;\n            } else if(list.get(i).equals(\"D\")) {\n                sum += 500;\n            } else if(list.get(i).equals(\"M\")) {\n                sum += 1000;\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "roman-to-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823966657,
            "question_id": 26,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665951926,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/823966657/",
            "is_pending": "Not Pending",
            "title": "Remove Duplicates from Sorted Array",
            "memory": "47.8 MB",
            "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int x=1;\n        for(int i=1; i<nums.length; i++) {\n            if(nums[i-1] != nums[i]) {\n                nums[x] = nums[i];\n                x++;\n            }\n        }\n        return x;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-duplicates-from-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823959858,
            "question_id": 26,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665951073,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1150 ms",
            "url": "/submissions/detail/823959858/",
            "is_pending": "Not Pending",
            "title": "Remove Duplicates from Sorted Array",
            "memory": "48.2 MB",
            "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int k = nums.length;\n        for(int i=0; i<nums.length; i++) {\n            if(i+1 <= nums.length-1) {\n                if(nums[i] == nums[i+1]) {\n                    if(nums[i+1] == -101) break;\n                    nums[i] = -101;\n                    k--;\n                    for(int j=i; j<nums.length; j++) {\n                        if(j+1 <= nums.length-1) {\n                            if(nums[j+1] == -101) break;\n                            int n = nums[j];\n                            nums[j] = nums[j+1];\n                            nums[j+1] = n;\n                        }\n                    }\n                    i--;\n                }\n            }\n        }\n        return k;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "remove-duplicates-from-sorted-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823676105,
            "question_id": 66,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665918663,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/823676105/",
            "is_pending": "Not Pending",
            "title": "Plus One",
            "memory": "40.3 MB",
            "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length-1;\n        if(n == 0 && digits[n] == 9) {\n            return new int[]{1,0};\n        } else if(!(digits[n] == 9)) {\n            digits[n] = digits[n] + 1;\n            return digits;\n        } else {\n            digits[n] = 0;\n            n = n-1;\n            while(n>=0) {\n                if((n == 0) && (digits[n] == 9)) {\n                    int[] dig = new int[digits.length+1];\n                    dig[0] = 1;\n                    for(int i=1; i<digits.length; i++) {\n                        dig[i+1] = digits[i];\n                    }\n                    return dig;\n                } else if(!(digits[n] == 9)) {\n                    digits[n] = digits[n] + 1;\n                    return digits;\n                } else {\n                    digits[n] = 0;\n                    n = n-1;\n                }  \n            }\n        }\n        return digits;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "plus-one",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823633799,
            "question_id": 566,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665912871,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/823633799/",
            "is_pending": "Not Pending",
            "title": "Reshape the Matrix",
            "memory": "43.4 MB",
            "code": "class Solution {\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\n        int [][] newArr = new int[r][c];\n        int rows=0, cols=0;\n        if((mat.length)*(mat[0].length) == r*c) {\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    newArr[rows][cols] = mat[i][j];\n                    if(cols<c-1) {\n                        cols++;\n                    } else {\n                        rows++;\n                        cols = 0;\n                    }\n                }\n            }\n            return newArr;\n        }\n        return mat;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reshape-the-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823633746,
            "question_id": 566,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665912864,
            "status": 20,
            "status_display": "Compile Error",
            "runtime": "N/A",
            "url": "/submissions/detail/823633746/",
            "is_pending": "Not Pending",
            "title": "Reshape the Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\n        int [][] newArr = new int[r][c];\n        int rows=0, cols=0;\n        if((mat.length)*(mat[0].length) == r*c) {\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    newArr[rows][cols] = mat[i][j];\n                    if(cols<c-1) {\n                        cols++;\n                    } else {\n                        rows++;\n                        cols = 0;\n                    }\n                }\n            }\n            return nArr;\n        }\n        return mat;\n    }\n}",
            "compare_result": null,
            "title_slug": "reshape-the-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823632969,
            "question_id": 566,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665912761,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/823632969/",
            "is_pending": "Not Pending",
            "title": "Reshape the Matrix",
            "memory": "50.6 MB",
            "code": "class Solution {\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\n        int [][] nArr = new int[r][c];\n        int rows=0, cols=0;\n        if((mat.length)*(mat[0].length) == r*c) {\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    nArr[rows][cols] = mat[i][j];\n                    if(cols<c-1) {\n                        cols++;\n                    } else {\n                        rows++;\n                        cols = 0;\n                    }\n                }\n            }\n            return nArr;\n        }\n        return mat;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111",
            "title_slug": "reshape-the-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823628836,
            "question_id": 566,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665912200,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/823628836/",
            "is_pending": "Not Pending",
            "title": "Reshape the Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\n        int [][] nArr = new int[r][c];\n        int rows=0, cols=0;\n        if((mat.length)*(mat[0].length) == r*c) {\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    nArr[rows][cols] = mat[i][j];\n                    if(cols<c) {\n                        cols++;\n                    } else if(cols<c-1) {\n                        rows++;\n                        cols = 0;\n                    }\n                }\n            }\n            return nArr;\n        }\n        return mat;\n    }\n}",
            "compare_result": "110000000000000000000000000000000000000000000000000000000",
            "title_slug": "reshape-the-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823173044,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665858827,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/823173044/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "52 MB",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            if(sum > maxsum) {\n                maxsum = sum;\n            }\n            if(sum < 0) {\n                sum = 0;\n            }\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823172709,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665858797,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/823172709/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "74 MB",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            maxsum = sum>maxsum ? sum : maxsum;\n            if(sum < 0) sum = 0;\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823172632,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665858788,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/823172632/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "82.2 MB",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            maxsum = sum>maxsum ? sum : maxsum;\n            if(sum < 0) sum = 0;\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823172490,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665858774,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/823172490/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "73.7 MB",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            maxsum = sum>maxsum ? sum : maxsum;\n            if(sum < 0) sum = 0;\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823171752,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665858703,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/823171752/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "N/A",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum, sum;\n        maxsum = sum = nums[0];\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            maxsum = sum>maxsum ? sum : maxsum;\n            if(sum < 0) sum = 0;\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "10011111100111000010110011011000110110111111111110110110010101101101101100110001110110111011101110110001011010011101110101111011100011010111110101101101011001011010001000111000111011110110011110101111111111101",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823167203,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665858274,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/823167203/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "51.4 MB",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        int sum = 0;\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            if(sum > maxsum) {\n                maxsum = sum;\n            }\n            if(sum < 0) {\n                sum = 0;\n            }\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823149328,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665856589,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/823149328/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "N/A",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        for(int i=0; i<nums.length; i++) {\n            int sum = 0;\n            for(int j=i; j<nums.length; j++) {\n                sum += nums[j];\n                if(sum > maxsum) {\n                    maxsum = sum;\n                }\n            }\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 823068434,
            "question_id": 53,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665849267,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/823068434/",
            "is_pending": "Not Pending",
            "title": "Maximum Subarray",
            "memory": "N/A",
            "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum = nums[0];\n        for(int i=0; i<nums.length; i++) {\n            for(int j=i; j<nums.length; j++) {\n                int sum = 0;\n                for(int k=i; k<=j; k++) {\n                    sum += nums[k];\n                    maxsum = maxsum<sum ? sum : maxsum;\n                }\n            }\n        }\n        return maxsum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000",
            "title_slug": "maximum-subarray",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 819574070,
            "question_id": 1496,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665427418,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/819574070/",
            "is_pending": "Not Pending",
            "title": "Lucky Numbers in a Matrix",
            "memory": "42.6 MB",
            "code": "class Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        int min = 0;\n        int max = 0;\n        List<Integer> rows = new ArrayList<Integer>();\n        List<Integer> cols = new ArrayList<Integer>();\n        for(int i=0; i<matrix.length; i++) {\n            min = matrix[i][0];\n            for(int j=0; j<matrix[i].length; j++) {\n                if(matrix[i][j] < min) {\n                    min = matrix[i][j];\n                }\n                if(cols.size() < matrix[0].length) {\n                    max = matrix[0][j];\n                    for(int k=0; k<matrix.length; k++) {\n                        if(matrix[k][j] > max) {\n                            max = matrix[k][j];\n                        }\n                    }\n                    cols.add(max);\n                }\n            }\n            rows.add(min);\n        }\n        rows.retainAll(cols);\n        return rows;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "lucky-numbers-in-a-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 819573804,
            "question_id": 1496,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665427395,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/819573804/",
            "is_pending": "Not Pending",
            "title": "Lucky Numbers in a Matrix",
            "memory": "50 MB",
            "code": "class Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        int min = 0;\n        int max = 0;\n        List<Integer> rows = new ArrayList<Integer>();\n        List<Integer> cols = new ArrayList<Integer>();\n        for(int i=0; i<matrix.length; i++) {\n            min = matrix[i][0];\n            for(int j=0; j<matrix[i].length; j++) {\n                if(matrix[i][j] < min) {\n                    min = matrix[i][j];\n                }\n                if(cols.size() < matrix[0].length) {\n                    max = matrix[0][j];\n                    for(int k=0; k<matrix.length; k++) {\n                        if(matrix[k][j] > max) {\n                            max = matrix[k][j];\n                        }\n                    }\n                    cols.add(max);\n                }\n            }\n            rows.add(min);\n        }\n        rows.retainAll(cols);\n        return rows;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "lucky-numbers-in-a-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 819563757,
            "question_id": 1496,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665426582,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/819563757/",
            "is_pending": "Not Pending",
            "title": "Lucky Numbers in a Matrix",
            "memory": "50.6 MB",
            "code": "class Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        int min = 0;\n        int max = 0;\n        List<Integer> rows = new ArrayList<Integer>();\n        List<Integer> cols = new ArrayList<Integer>();\n        for(int i=0; i<matrix.length; i++) {\n            min = matrix[i][0];\n            for(int j=0; j<matrix[i].length; j++) {\n                if(matrix[i][j] < min) {\n                    min = matrix[i][j];\n                }\n            }\n            rows.add(min);\n        }\n        for(int i=0; i<matrix[0].length; i++) {\n            max = matrix[0][i];\n            for(int j=0; j<matrix.length; j++) {\n                if(matrix[j][i] > max) {\n                    max = matrix[j][i];\n                }\n            }\n            cols.add(max);\n        }\n        rows.retainAll(cols);\n        return rows;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "lucky-numbers-in-a-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 819530317,
            "question_id": 1496,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665423981,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/819530317/",
            "is_pending": "Not Pending",
            "title": "Lucky Numbers in a Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> luckyNumbers (int[][] matrix) {\n        int min = 0;\n        int max = 0;\n        List<Integer> rows = new ArrayList<Integer>();\n        List<Integer> cols = new ArrayList<Integer>();\n        for(int i=0; i<matrix.length; i++) {\n            min = matrix[i][0];\n            max = matrix[i][0];\n            for(int j=0; j<matrix.length; j++) {\n                if(matrix[i][j] < min) {\n                    min = matrix[i][j];\n                }\n                if(matrix[j][i] > max) {\n                    max = matrix[j][i];\n                }\n            }\n            rows.add(min);\n            cols.add(max);\n        }\n        rows.retainAll(cols);\n        return rows;\n    }\n}",
            "compare_result": "10100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "lucky-numbers-in-a-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 819124506,
            "question_id": 1426,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665379566,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/819124506/",
            "is_pending": "Not Pending",
            "title": "Find N Unique Integers Sum up to Zero",
            "memory": "42.8 MB",
            "code": "class Solution {\n    public int[] sumZero(int n) {\n        int[] arr = new int[n];\n        if(n%2==0) {\n            for(int i=0; i<n; i+=2) {\n                arr[i] = i+1;\n                arr[i+1] = -(i+1);\n            }\n        } else {\n            for(int i=0; i<n-1; i+=2) {\n                arr[i] = i+1;\n                arr[i+1] = -(i+1);\n            }\n            arr[n-1] = 0;\n        }\n        return arr;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111",
            "title_slug": "find-n-unique-integers-sum-up-to-zero",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 817240574,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665153219,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/817240574/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "41.3 MB",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        for(int i=0; i<4; i++) {\n            if(checkIfEqual(mat, target)) {\n                return true;\n            } else {\n                mat = transposeAndSwap(mat);\n            }\n        }\n        return false;\n    }\n    public static boolean checkIfEqual(int[][] mat, int[][] target) {\n        for(int i=0; i<mat.length; i++) {\n            for(int j=0; j<mat[i].length; j++) {\n                if(mat[i][j]!=target[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    public static int[][] transposeAndSwap(int[][] mat) {\n        for(int i=0; i<mat.length; i++) {\n            for(int j=0; j<i; j++) {\n                int temp = mat[i][j];\n                mat[i][j] = mat[j][i];\n                mat[j][i] = temp;\n            }\n        }\n        int start = 0, end = mat.length-1;\n        while(start < end) {\n            for(int i=0; i<mat.length; i++) {\n                int temp = mat[i][start];\n                mat[i][start] = mat[i][end];\n                mat[i][end] = temp;\n            }\n            start++;\n            end--;\n        }\n        return mat;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 817239968,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1665153152,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/817239968/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "42.6 MB",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        for(int i=0; i<4; i++) {\n            if(checkIfEqual(mat, target)) {\n                return true;\n            } else {\n                mat = transposeAndSwap(mat);\n            }\n        }\n        return false;\n    }\n    public static boolean checkIfEqual(int[][] mat, int[][] target) {\n        for(int i=0; i<mat.length; i++) {\n            for(int j=0; j<mat[i].length; j++) {\n                if(mat[i][j]!=target[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    public static int[][] transposeAndSwap(int[][] mat) {\n        for(int i=0; i<mat.length; i++) {\n            for(int j=0; j<i; j++) {\n                int temp = mat[i][j];\n                mat[i][j] = mat[j][i];\n                mat[j][i] = temp;\n            }\n        }\n        int start = 0, end = mat.length-1;\n        while(start < end) {\n            for(int i=0; i<mat.length; i++) {\n                int temp = mat[i][start];\n                mat[i][start] = mat[i][end];\n                mat[i][end] = temp;\n            }\n            start++;\n            end--;\n        }\n        return mat;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 813644881,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1664732797,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/813644881/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "41.7 MB",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    int k = mat.length-j-1;\n                    arr[i][j] = mat[k][i];\n                }\n            }\n            mat = arr;\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n        }\n        return bool;\n    }\n    static int areSame(int A[][], int B[][])\n    {\n        int i, j;\n        for (i = 0; i < A.length; i++)\n            for (j = 0; j < A[i].length; j++)\n                if (A[i][j] != B[i][j])\n                    return 0;\n            return 1;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 813644715,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1664732783,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/813644715/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    int k = mat.length-j-1;\n                    arr[i][j] = mat[k][i];\n                }\n            }\n            mat = arr;\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n        }\n        return bool;\n    }\n    static int areSame(int A[][], int B[][])\n    {\n        int i, j;\n        for (i = 0; i < A.length; i++)\n            for (j = 0; j < A[i].length; j++)\n                if (A[i][j] != B[i][j])\n                    return 0;\n            return 1;\n    }\n}",
            "compare_result": "11111111111111111111011110111111111011110110011111111110111101101111011011111111111111111111101111111110110111010",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 813644293,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1664732739,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/813644293/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "42.9 MB",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    int k = mat.length-j-1;\n                    arr[i][j] = mat[k][i];\n                }\n            }\n            mat = arr;\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n        }\n        return bool;\n    }\n    static int areSame(int A[][], int B[][])\n    {\n        int i, j;\n        for (i = 0; i < A.length; i++)\n            for (j = 0; j < A[i].length; j++)\n                if (A[i][j] != B[i][j])\n                    return 0;\n            return 1;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 813640344,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1664732347,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/813640344/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = false;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    int k = mat.length-j-1;\n                    arr[i][j] = mat[k][i];\n                }\n            }\n            mat = arr;\n        }\n        return bool;\n    }\n    static int areSame(int A[][], int B[][])\n    {\n        int i, j;\n        for (i = 0; i < A.length; i++)\n            for (j = 0; j < A[i].length; j++)\n                if (A[i][j] != B[i][j])\n                    return 0;\n            return 1;\n    }\n}",
            "compare_result": "11111111011111111111110111111011111111111011111100010101110110111111111111001101100110111111010111111101111111111",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 813634909,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1664731832,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/813634909/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    int k = mat.length-j-1;\n                    arr[i][j] = mat[k][i];\n                }\n            }\n            mat = arr;\n            if(x!=3) {\n                bool = true;\n            } else if(x==3) {\n                break ool;\n            }\n        }\n        return bool;\n    }\n    static int areSame(int A[][], int B[][])\n    {\n        int i, j;\n        for (i = 0; i < A.length; i++)\n            for (j = 0; j < A[i].length; j++)\n                if (A[i][j] != B[i][j])\n                    return 0;\n            return 1;\n    }\n}",
            "compare_result": "10110011101111100011111111101111101110001111101011101111101111111010101110111011011101100011111110101111101000101",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 813576850,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 6 months",
            "timestamp": 1664725926,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/813576850/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    int k = mat.length-j-1;\n                    arr[i][j] = mat[k][i];\n                }\n            }\n            mat = arr;\n            if(x!=3) {\n                bool = true;\n            } else if(x==3) {\n                break ool;\n            }\n            if (areSame(mat, target) == 1) {\n                bool = true;\n                return bool;\n            } else {\n                bool = false;\n            }\n        }\n        return bool;\n    }\n    static int areSame(int A[][], int B[][])\n    {\n        int i, j;\n        for (i = 0; i < A.length; i++)\n            for (j = 0; j < A[i].length; j++)\n                if (A[i][j] != B[i][j])\n                    return 0;\n            return 1;\n    }\n}",
            "compare_result": "11111111111111111111011110111111111011110110011111111110111101101111011011111111111111111111101111111110110111010",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 806329037,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663874981,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/806329037/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    arr[i][j] = mat[mat.length-j-1][i];\n                }\n            }\n            if(x!=3) {\n                bool = true;\n            } else {\n                break ool;\n            }\n            mat = arr;\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    if(mat[i][j]!=target[i][j]) {\n                        bool = false;\n                        break;\n                    }\n                }\n            }\n        }\n        return bool;\n    }\n}",
            "compare_result": "11011100110100111110001000110100010011110100011111111010111001000111010001111110111011111100101011110010010111010",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 806321898,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663874276,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/806321898/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            arr = new int[mat.length][mat.length];\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    arr[i][j] = mat[mat.length-j-1][i];\n                }\n            }\n            mat = arr;\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    if(mat[i][j]!=target[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return bool;\n    }\n}",
            "compare_result": "01011100010000111100000000110000010011110000011100010000110000000111010001001100100010111100000011110000010111010",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 805851604,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663824607,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/805851604/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        ool:\n        for(int x=0; x<3; x++) {\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    arr[i][j] = mat[mat.length-j-1][i];\n                    if(!(target[i][j] == mat[mat.length-j-1][i])) {\n                        bool = false;\n                        break ol;      \n                    }\n                }\n            }\n            if(x!=3) {\n                bool = true;\n            } else {\n                break ool;\n            }\n            mat = arr;\n        }\n        return bool;\n    }\n}",
            "compare_result": "10110011101111100011111111101111101110001111101011101111101111111010101110111011011101100011111110101111101000101",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 804740948,
            "question_id": 2015,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663702436,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/804740948/",
            "is_pending": "Not Pending",
            "title": "Determine Whether Matrix Can Be Obtained By Rotation",
            "memory": "N/A",
            "code": "class Solution {\n    public boolean findRotation(int[][] mat, int[][] target) {\n        boolean bool = true;\n        int[][] arr = new int[mat.length][mat.length];\n        for(int x=0; x<3; x++) {\n            ol:\n            for(int i=0; i<mat.length; i++) {\n                for(int j=0; j<mat[i].length; j++) {\n                    arr[i][j] = mat[mat.length-j-1][i];\n                    if(!(target[i][j] == mat[mat.length-j-1][i])) {\n                        bool = false;\n                        break ol;      \n                    }\n                }\n            }\n            if(x!=3) {\n                bool = true;\n            } else {\n                return bool;\n            }\n            mat = arr;\n        }\n        return bool;\n    }\n}",
            "compare_result": "10110011101111100011111111101111101110001111101011101111101111111010101110111011011101100011111110101111101000101",
            "title_slug": "determine-whether-matrix-can-be-obtained-by-rotation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 804714093,
            "question_id": 1983,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663700092,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "37 ms",
            "url": "/submissions/detail/804714093/",
            "is_pending": "Not Pending",
            "title": "Maximum Population Year",
            "memory": "45.1 MB",
            "code": "class Solution {\n    public int maximumPopulation(int[][] logs) {\n        int year=0;\n        TreeMap<Integer,Integer> map=new TreeMap<Integer,Integer>();\n        for(int i=0; i<logs.length; i++) {\n            for(int j=logs[i][0]; j<logs[i][1]; j++) {\n                if(!map.containsKey(j)) {\n                    map.put(j,1);\n                } else {\n                   map.replace(j,map.get(j)+1);\n                }\n            }\n        }\n        for(Map.Entry<Integer,Integer> m: map.entrySet()) {\n            if(m.getValue() == (Collections.max(map.values()))) {\n                year = m.getKey();\n                break;\n            }\n        }\n        return year;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-population-year",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 804713772,
            "question_id": 1983,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663700065,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "61 ms",
            "url": "/submissions/detail/804713772/",
            "is_pending": "Not Pending",
            "title": "Maximum Population Year",
            "memory": "45.1 MB",
            "code": "class Solution {\n    public int maximumPopulation(int[][] logs) {\n        int year=0;\n        TreeMap<Integer,Integer> map=new TreeMap<Integer,Integer>();\n        for(int i=0; i<logs.length; i++) {\n            for(int j=logs[i][0]; j<logs[i][1]; j++) {\n                if(!map.containsKey(j)) {\n                    map.put(j,1);\n                } else {\n                   map.replace(j,map.get(j)+1);\n                }\n            }\n        }\n        for(Map.Entry<Integer,Integer> m: map.entrySet()) {\n            if(m.getValue() == (Collections.max(map.values()))) {\n                year = m.getKey();\n                break;\n            }\n        }\n        return year;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-population-year",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 804712667,
            "question_id": 1983,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663699970,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "37 ms",
            "url": "/submissions/detail/804712667/",
            "is_pending": "Not Pending",
            "title": "Maximum Population Year",
            "memory": "44.6 MB",
            "code": "class Solution {\n    public int maximumPopulation(int[][] logs) {\n        int year=0;\n        TreeMap<Integer,Integer> map=new TreeMap<Integer,Integer>();\n        for(int i=0; i<logs.length; i++) {\n            for(int j=logs[i][0]; j<logs[i][1]; j++) {\n                if(!map.containsKey(j)) {\n                    map.put(j,1);\n                } else {\n                   int x = map.get(j);\n                   x++;\n                   map.replace(j,x);\n                }\n            }\n        }\n        for(Map.Entry<Integer,Integer> m: map.entrySet()) {\n            if(m.getValue() == (Collections.max(map.values()))) {\n                year = m.getKey();\n                break;\n            }\n        }\n        return year;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111",
            "title_slug": "maximum-population-year",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 804705681,
            "question_id": 1983,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663699407,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/804705681/",
            "is_pending": "Not Pending",
            "title": "Maximum Population Year",
            "memory": "N/A",
            "code": "class Solution {\n    public int maximumPopulation(int[][] logs) {\n        int year=0;\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        for(int i=0; i<logs.length; i++) {\n            for(int j=logs[i][0]; j<logs[i][1]; j++) {\n                if(!map.containsKey(j)) {\n                    map.put(j,1);\n                } else {\n                   int x = map.get(j);\n                   x++;\n                   map.replace(j,x);\n                }\n            }\n        }\n        for(Map.Entry<Integer,Integer> m: map.entrySet()) {\n            if(m.getValue() == (Collections.max(map.values()))) {\n                year = m.getKey();\n                break;\n            }\n        }\n        return year;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111011101101",
            "title_slug": "maximum-population-year",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 798841211,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663080336,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "76 ms",
            "url": "/submissions/detail/798841211/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "61.4 MB",
            "code": "class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int len = num.length-1;\n        while(len>=0 || k>0) {\n            int rem = 0;\n            if(len>=0) {\n                    num[len]=num[len]+k;\n                    rem = (num[len])%10;\n                k = (num[len])/10;\n                len--;\n                list.add(0,rem);\n            } else {\n                rem = k%10;\n                k /= 10;\n                list.add(0,rem);\n            }\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 798764887,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663073360,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "83 ms",
            "url": "/submissions/detail/798764887/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "61.2 MB",
            "code": "import java.math.BigInteger;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int len = num.length-1;\n        while(len>=0 || k>0) {\n            int rem = 0;\n            if(len>=0) {\n                    num[len]=num[len]+k;\n                    rem = (num[len])%10;\n                k = (num[len])/10;\n                len--;\n                list.add(0,rem);\n            } else {\n                rem = k%10;\n                k /= 10;\n                list.add(0,rem);\n            }\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 798764709,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663073342,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "75 ms",
            "url": "/submissions/detail/798764709/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "61.8 MB",
            "code": "import java.math.BigInteger;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int len = num.length-1;\n        while(len>=0 || k>0) {\n            int rem = 0;\n            if(len>=0) {\n                    num[len]=num[len]+k;\n                    rem = (num[len])%10;\n                k = (num[len])/10;\n                len--;\n                list.add(0,rem);\n            } else {\n                rem = k%10;\n                k /= 10;\n                list.add(0,rem);\n            }\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 798763712,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663073233,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "30 ms",
            "url": "/submissions/detail/798763712/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "43.6 MB",
            "code": "import java.math.BigInteger;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int len = num.length-1;\n        while(len>=0 || k>0) {\n            int rem = 0;\n            if(len>=0) {\n                    num[len]=num[len]+k;\n                    rem = (num[len])%10;\n                k = (num[len])/10;\n                len--;\n                list.add(0,rem);\n            } else {\n                int temp;\n                temp = 0 + k;\n                rem = temp%10;\n                k = temp/10;\n                list.add(0,rem);\n            }\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 798763519,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663073211,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "106 ms",
            "url": "/submissions/detail/798763519/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "62.3 MB",
            "code": "import java.math.BigInteger;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int len = num.length-1;\n        while(len>=0 || k>0) {\n            int rem = 0;\n            if(len>=0) {\n                    num[len]=num[len]+k;\n                    rem = (num[len])%10;\n                k = (num[len])/10;\n                len--;\n                list.add(0,rem);\n            } else {\n                int temp;\n                temp = 0 + k;\n                rem = temp%10;\n                k = temp/10;\n                list.add(0,rem);\n            }\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 798763295,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663073185,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "69 ms",
            "url": "/submissions/detail/798763295/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "61.8 MB",
            "code": "import java.math.BigInteger;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int len = num.length-1;\n        while(len>=0 || k>0) {\n            int rem = 0;\n            if(len>=0) {\n                    num[len]=num[len]+k;\n                    rem = (num[len])%10;\n                k = (num[len])/10;\n                len--;\n                list.add(0,rem);\n            } else {\n                int temp;\n                temp = 0 + k;\n                rem = temp%10;\n                k = temp/10;\n                list.add(0,rem);\n            }\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 798748659,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1663071541,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/798748659/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "N/A",
            "code": "import java.math.BigInteger;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int len = num.length-1;\n        while(len>=0) {\n            if(len>=0) {\n                int rem = 0;\n                    num[len]=num[len]+k;\n                    rem = (num[len])%10;\n                k = (num[len])/10;\n                len--;\n                list.add(0,rem);\n            }\n        }\n        return list;\n    }\n}",
            "compare_result": "11000100100000001000000011011000111110101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 797053750,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662894656,
            "status": 14,
            "status_display": "Time Limit Exceeded",
            "runtime": "N/A",
            "url": "/submissions/detail/797053750/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "N/A",
            "code": "import java.math.BigInteger;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        BigInteger a = new BigInteger(Arrays.toString(num).replaceAll(\"[^\\\\dA-Za-z]\",\"\"));\n        BigInteger b = new BigInteger(String.valueOf(k));\n        for(int i=0; i<(a.add(b)).toString().length(); i++) {\n            list.add(i,Integer.parseInt(String.valueOf((a.add(b)).toString().charAt(i))));\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 796957733,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662883688,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/796957733/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        Long sum;\n        sum = Long.parseLong(Arrays.toString(num).replaceAll(\"[^\\\\dA-Za-z]\",\"\")) + k;\n        for(int i=0; i<Long.toString(sum).length(); i++) {\n            list.add(i,Integer.parseInt(String.valueOf(Long.toString(sum).charAt(i))));\n        }\n        return list;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 796937394,
            "question_id": 1031,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662881445,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/796937394/",
            "is_pending": "Not Pending",
            "title": "Add to Array-Form of Integer",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int sum = 0;\n        sum = Integer.parseInt(Arrays.toString(num).replaceAll(\"[^\\\\dA-Za-z]\",\"\")) + k;\n        for(int i=0; i<Integer.toString(sum).length(); i++) {\n            list.add(i,Integer.parseInt(String.valueOf(Integer.toString(sum).charAt(i))));\n        }\n        return list;\n    }\n}",
            "compare_result": "11100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "title_slug": "add-to-array-form-of-integer",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 796513203,
            "question_id": 898,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662836764,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/796513203/",
            "is_pending": "Not Pending",
            "title": "Transpose Matrix",
            "memory": "48.1 MB",
            "code": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] mat = new int[matrix[0].length][matrix.length];\n        for(int i=0; i<matrix[0].length; i++) {\n            for(int j=0; j<matrix.length; j++) {\n                mat[i][j] = matrix[j][i];\n            }\n        }\n        return mat;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111",
            "title_slug": "transpose-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 796421558,
            "question_id": 898,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662829089,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/796421558/",
            "is_pending": "Not Pending",
            "title": "Transpose Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] mat = new int[matrix.length][matrix.length];\n        for(int i=0; i<matrix.length; i++) {\n            for(int j=0; j<matrix.length; j++) {\n                mat[i][j] = matrix[j][i];\n            }\n        }\n        return mat;\n    }\n}",
            "compare_result": "101000000000000000000000000000000000",
            "title_slug": "transpose-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 796312148,
            "question_id": 1421,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662818429,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/796312148/",
            "is_pending": "Not Pending",
            "title": "Find Numbers with Even Number of Digits",
            "memory": "44.9 MB",
            "code": "class Solution {\n    public int findNumbers(int[] nums) {\n        int noOfDigits = 0;\n        for(int i=0; i<nums.length; i++) {\n            if(((String.valueOf(nums[i])).length()) % 2 == 0)   noOfDigits++;\n        }\n        return noOfDigits;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-numbers-with-even-number-of-digits",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 796289518,
            "question_id": 1677,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662816035,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/796289518/",
            "is_pending": "Not Pending",
            "title": "Matrix Diagonal Sum",
            "memory": "48 MB",
            "code": "class Solution {\n    public int diagonalSum(int[][] mat) {\n        int sum = 0;\n        for(int i=0; i<mat.length; i++) {\n            if(mat.length-1-i != i) {\n                sum += mat[i][i] + mat[i][mat.length-1-i];\n            } else {\n                sum += mat[i][i];\n            }\n        }\n        return sum;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "matrix-diagonal-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 796268256,
            "question_id": 1378,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662813600,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/796268256/",
            "is_pending": "Not Pending",
            "title": "Cells with Odd Values in a Matrix",
            "memory": "42.6 MB",
            "code": "class Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        int[][] matrix = new int[m][n];\n        for(int i=0; i<indices.length; i++) {\n            int whichRow = indices[i][0];\n            int whichCol = indices[i][1];\n            for(int j=0; j<n; j++) {\n                ++matrix[whichRow][j];\n            }\n            for(int k=0; k<m; k++) {\n                ++matrix[k][whichCol];\n            }\n        }\n        int c = 0;\n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                if((matrix[i][j]%2)!=0) {\n                    c++;\n                }\n            }\n        }\n        return c;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111",
            "title_slug": "cells-with-odd-values-in-a-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 795214457,
            "question_id": 1378,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662693322,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/795214457/",
            "is_pending": "Not Pending",
            "title": "Cells with Odd Values in a Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        int[][] matrix = {\n            {0,0,0},\n            {0,0,0}\n        };\n        for(int i=0; i<indices.length; i++) {\n            int whichRow = indices[i][0];\n            int whichCol = indices[i][1];\n            for(int j=0; j<n; j++) {\n                ++matrix[whichRow][j];\n            }\n            for(int k=0; k<m; k++) {\n                ++matrix[k][whichCol];\n            }\n        }\n        int c = 0;\n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                if((matrix[i][j]%2)!=0) {\n                    c++;\n                }\n            }\n        }\n        return c;\n    }\n}",
            "compare_result": "11100000000000000000000000000000000000000000",
            "title_slug": "cells-with-odd-values-in-a-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 795214271,
            "question_id": 1378,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662693302,
            "status": 15,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/795214271/",
            "is_pending": "Not Pending",
            "title": "Cells with Odd Values in a Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public int oddCells(int m, int n, int[][] indices) {\n        int[][] matrix = {\n            {0,0,0},\n            {0,0,0}\n        };\n        for(int i=0; i<indices.length; i++) {\n            int whichRow = indices[i][0];\n            int whichCol = indices[i][1];\n            for(int j=0; j<n; j++) {\n                ++matrix[whichRow][j];\n            }\n            for(int k=0; k<m; k++) {\n                ++matrix[k][whichCol];\n            }\n        }\n        int c = 0;\n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                if((matrix[i][j]%2)!=0) {\n                    c++;\n                }\n            }\n        }\n        return c;\n    }\n}",
            "compare_result": "11100000000000000000000000000000000000000000",
            "title_slug": "cells-with-odd-values-in-a-matrix",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 793315534,
            "question_id": 861,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662495685,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/793315534/",
            "is_pending": "Not Pending",
            "title": "Flipping an Image",
            "memory": "45.1 MB",
            "code": "class Solution {\n    public int[][] flipAndInvertImage(int[][] image) {\n        for(int i=0; i<image.length; i++) {\n            int[] temp = new int[image[i].length];\n            for(int j=0; j<image[i].length; j++) {\n                temp[j] = (image[i][image[i].length-j-1]) == 1 ? 0 : 1;\n            }\n            image[i] = temp;\n        }\n        return image;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "flipping-an-image",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792417791,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407641,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/792417791/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "40.3 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        return Arrays.stream(alt.stream().mapToInt(Integer::intValue).toArray()).max().getAsInt();\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792417695,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407634,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "12 ms",
            "url": "/submissions/detail/792417695/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "41.9 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        return Arrays.stream(alt.stream().mapToInt(Integer::intValue).toArray()).max().getAsInt();\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792417590,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407624,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/792417590/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "42.2 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        return Arrays.stream(alt.stream().mapToInt(Integer::intValue).toArray()).max().getAsInt();\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792417519,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407619,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "15 ms",
            "url": "/submissions/detail/792417519/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "42 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        return Arrays.stream(alt.stream().mapToInt(Integer::intValue).toArray()).max().getAsInt();\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792417388,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407607,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/792417388/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "41.9 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        return Arrays.stream(alt.stream().mapToInt(Integer::intValue).toArray()).max().getAsInt();\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792417202,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407591,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "12 ms",
            "url": "/submissions/detail/792417202/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "42.1 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        return Arrays.stream(alt.stream().mapToInt(Integer::intValue).toArray()).max().getAsInt();\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792416190,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407503,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "7 ms",
            "url": "/submissions/detail/792416190/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "42 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        return Arrays.stream(alt.stream().mapToInt(Integer::intValue).toArray()).max().getAsInt();\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792415052,
            "question_id": 1833,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662407407,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "14 ms",
            "url": "/submissions/detail/792415052/",
            "is_pending": "Not Pending",
            "title": "Find the Highest Altitude",
            "memory": "42.2 MB",
            "code": "class Solution {\n    public int largestAltitude(int[] gain) {\n        List<Integer> alt = new ArrayList<Integer>();\n        alt.add(0);\n        for(int i=1; i<=gain.length; i++) {\n            int temp = 0;\n            for(int j=0; j<=i-1; j++) {\n                temp += gain[j];\n            }\n            alt.add(i,temp);\n        }\n        int[] arr = alt.stream().mapToInt(Integer::intValue).toArray();\n        int max = Arrays.stream(arr).max().getAsInt();\n        return max;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "find-the-highest-altitude",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792212119,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392531,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/792212119/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "47.1 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\")) {\n                if(ruleValue.equals((items.get(i)).get(0))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"color\")) {\n                if(ruleValue.equals((items.get(i)).get(1))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"name\")) {\n                if(ruleValue.equals((items.get(i)).get(2))) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792211931,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392517,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/792211931/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "57 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\")) {\n                if(ruleValue.equals((items.get(i)).get(0))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"color\")) {\n                if(ruleValue.equals((items.get(i)).get(1))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"name\")) {\n                if(ruleValue.equals((items.get(i)).get(2))) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792211719,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392502,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/792211719/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "56.4 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\")) {\n                if(ruleValue.equals((items.get(i)).get(0))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"color\")) {\n                if(ruleValue.equals((items.get(i)).get(1))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"name\")) {\n                if(ruleValue.equals((items.get(i)).get(2))) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792211345,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392472,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/792211345/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "56.7 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\") && ruleValue.equals(items.get(i).get(0))) {\n                count++;\n            } else if(ruleKey.equals(\"color\") && ruleValue.equals(items.get(i).get(1))) {\n                count++;\n            } else if(ruleKey.equals(\"name\") && ruleValue.equals(items.get(i).get(2))) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792210906,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392436,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "10 ms",
            "url": "/submissions/detail/792210906/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "56.7 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\") && ruleValue.equals(items.get(i).get(0))) count++;\n            else if(ruleKey.equals(\"color\") && ruleValue.equals(items.get(i).get(1))) count++;\n            else if(ruleKey.equals(\"name\") && ruleValue.equals(items.get(i).get(2))) count++;\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792210776,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392427,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "21 ms",
            "url": "/submissions/detail/792210776/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "57 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\") && ruleValue.equals(items.get(i).get(0))) count++;\n            else if(ruleKey.equals(\"color\") && ruleValue.equals(items.get(i).get(1))) count++;\n            else if(ruleKey.equals(\"name\") && ruleValue.equals(items.get(i).get(2))) count++;\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792210696,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392420,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "12 ms",
            "url": "/submissions/detail/792210696/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "56.3 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\") && ruleValue.equals(items.get(i).get(0))) count++;\n            else if(ruleKey.equals(\"color\") && ruleValue.equals(items.get(i).get(1))) count++;\n            else if(ruleKey.equals(\"name\") && ruleValue.equals(items.get(i).get(2))) count++;\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792210532,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662392408,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "12 ms",
            "url": "/submissions/detail/792210532/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "57 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\") && ruleValue.equals(items.get(i).get(0))) count++;\n            else if(ruleKey.equals(\"color\") && ruleValue.equals(items.get(i).get(1))) count++;\n            else if(ruleKey.equals(\"name\") && ruleValue.equals(items.get(i).get(2))) count++;\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 792205164,
            "question_id": 1899,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1662391976,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/792205164/",
            "is_pending": "Not Pending",
            "title": "Count Items Matching a Rule",
            "memory": "57.5 MB",
            "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;\n        for(int i=0; i<items.size(); i++) {\n            if(ruleKey.equals(\"type\")) {\n                if(ruleValue.equals((items.get(i)).get(0))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"color\")) {\n                if(ruleValue.equals((items.get(i)).get(1))) {\n                    count++;\n                }\n            } else if(ruleKey.equals(\"name\")) {\n                if(ruleValue.equals((items.get(i)).get(2))) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "count-items-matching-a-rule",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 788230238,
            "question_id": 1960,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1661971925,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "4 ms",
            "url": "/submissions/detail/788230238/",
            "is_pending": "Not Pending",
            "title": "Check if the Sentence Is Pangram",
            "memory": "42.8 MB",
            "code": "class Solution {\n    public boolean checkIfPangram(String sentence) {\n        boolean[] found = new boolean[256];\n        StringBuilder sb = new StringBuilder();\n        for(char c: sentence.toCharArray()) {\n            if(!found[c]) {\n                found[c] = true;\n                sb.append(c);\n            }\n        }\n        return sb.toString().length() == 26;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "check-if-the-sentence-is-pangram",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 788153547,
            "question_id": 1013,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1661965942,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "8 ms",
            "url": "/submissions/detail/788153547/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "41.9 MB",
            "code": "class Solution {\n    public int fib(int n) {\n        if(n==0) \n            return 0;\n        if(n==1 || n==2) \n            return 1;\n        return fib(n-2) + fib(n-1);\n    }\n}",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 788152170,
            "question_id": 1013,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1661965830,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "16 ms",
            "url": "/submissions/detail/788152170/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "41.2 MB",
            "code": "class Solution {\n    public int fib(int n) {\n        if(n<=1) \n            return n;\n        return fib(n-2) + fib(n-1);\n    }\n}",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 788030011,
            "question_id": 1013,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 7 months",
            "timestamp": 1661954956,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "14 ms",
            "url": "/submissions/detail/788030011/",
            "is_pending": "Not Pending",
            "title": "Fibonacci Number",
            "memory": "41.2 MB",
            "code": "class Solution {\n    public int fib(int n) {\n        if(n==0)\n            return 0;\n        if(n==1 || n==2) \n            return 1;\n        return fib(n-2) + fib(n-1);\n    }\n}",
            "compare_result": "1111111111111111111111111111111",
            "title_slug": "fibonacci-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 774867283,
            "question_id": 1505,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 8 months",
            "timestamp": 1660625931,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/774867283/",
            "is_pending": "Not Pending",
            "title": "Create Target Array in the Given Order",
            "memory": "42.2 MB",
            "code": "class Solution {\n    public int[] createTargetArray(int[] nums, int[] index) {\n        List<Integer> arr = new ArrayList<>(nums.length);\n        for(int i=0; i<nums.length; i++) {\n            arr.add(index[i], nums[i]);\n        }\n        int[] arr1 = new int[nums.length];\n        for(int i=0; i<nums.length; i++) {\n            arr1[i] = arr.get(i);\n        }\n        return arr1;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111",
            "title_slug": "create-target-array-in-the-given-order",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 774866417,
            "question_id": 1505,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 8 months",
            "timestamp": 1660625849,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/774866417/",
            "is_pending": "Not Pending",
            "title": "Create Target Array in the Given Order",
            "memory": "42 MB",
            "code": "class Solution {\n    public int[] createTargetArray(int[] nums, int[] index) {\n        List<Integer> arr = new ArrayList<>(nums.length);\n        for(int i=0; i<nums.length; i++) {\n            arr.add(index[i], nums[i]);\n        }\n        int[] arr1 = new int[nums.length];\n        for(int i=0; i<nums.length; i++) {\n            arr1[i] = arr.get(i);\n        }\n        // return arr.stream().mapToInt((Integer i) -> i.intValue()).toArray();\n        return arr1;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111",
            "title_slug": "create-target-array-in-the-given-order",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 774865667,
            "question_id": 1505,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 8 months",
            "timestamp": 1660625781,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "5 ms",
            "url": "/submissions/detail/774865667/",
            "is_pending": "Not Pending",
            "title": "Create Target Array in the Given Order",
            "memory": "42.4 MB",
            "code": "class Solution {\n    public int[] createTargetArray(int[] nums, int[] index) {\n        List<Integer> arr = new ArrayList<>(nums.length);\n        for(int i=0; i<nums.length; i++) {\n            arr.add(index[i], nums[i]);\n        }\n        // int[] arr1 = new int[nums.length];\n        // for(int i=0; i<nums.length; i++) {\n        //     arr1[i] = arr.get(i);\n        // }\n        return arr.stream().mapToInt((Integer i) -> i.intValue()).toArray();\n        // return arr1;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111",
            "title_slug": "create-target-array-in-the-given-order",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 761785062,
            "question_id": 1505,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 8 months",
            "timestamp": 1659299718,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/761785062/",
            "is_pending": "Not Pending",
            "title": "Create Target Array in the Given Order",
            "memory": "N/A",
            "code": "class Solution {\n    public int[] createTargetArray(int[] nums, int[] index) {\n        List<Integer> arr = new ArrayList<>(nums.length);\n        for(int i=0; i<nums.length; i++) {\n            arr.add(index[index[i]], nums[i]);\n        }\n        return arr.stream().mapToInt((Integer i) -> i.intValue()).toArray();\n    }\n}",
            "compare_result": "111110100010000000000000000000000000000000011",
            "title_slug": "create-target-array-in-the-given-order",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 761441843,
            "question_id": 1482,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 8 months",
            "timestamp": 1659267286,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "17 ms",
            "url": "/submissions/detail/761441843/",
            "is_pending": "Not Pending",
            "title": "How Many Numbers Are Smaller Than the Current Number",
            "memory": "44.8 MB",
            "code": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] arr = new int[nums.length];\n        for(int i=0; i<nums.length; i++) {\n            for(int j=0; j<nums.length; j++) {\n                if(nums[i]>nums[j]) {\n                    arr[i]++;\n                }\n            }\n        }\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "how-many-numbers-are-smaller-than-the-current-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 761439465,
            "question_id": 1482,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 8 months",
            "timestamp": 1659267026,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "19 ms",
            "url": "/submissions/detail/761439465/",
            "is_pending": "Not Pending",
            "title": "How Many Numbers Are Smaller Than the Current Number",
            "memory": "44.6 MB",
            "code": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] arr = new int[nums.length];\n        for(int i=0; i<nums.length; i++) {\n            int k=0;\n            for(int j=0; j<nums.length; j++) {\n                if(nums[i]>nums[j]) {\n                    k++;\n                }\n                arr[i] = k;\n            }\n        }\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "how-many-numbers-are-smaller-than-the-current-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755691552,
            "question_id": 1635,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658690246,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/755691552/",
            "is_pending": "Not Pending",
            "title": "Number of Good Pairs",
            "memory": "41.5 MB",
            "code": "class Solution {\n    public int numIdenticalPairs(int[] nums) {\n        int goodPairs = 0, count[] = new int[101];\n        // for(int i=0; i<nums.length; i++) {\n        //     for(int j=0; j<nums.length; j++) {\n        //         if((nums[i]==nums[j]) && i<j) {\n        //             goodPairs++;\n        //         }\n        //     }\n        // }\n        for(int i: nums) {\n            goodPairs += count[i]++;\n        }\n        return goodPairs;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-good-pairs",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755691183,
            "question_id": 1635,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658690212,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/755691183/",
            "is_pending": "Not Pending",
            "title": "Number of Good Pairs",
            "memory": "42.1 MB",
            "code": "class Solution {\n    public int numIdenticalPairs(int[] nums) {\n        int goodPairs = 0, count[] = new int[101];\n        // for(int i=0; i<nums.length; i++) {\n        //     for(int j=0; j<nums.length; j++) {\n        //         if((nums[i]==nums[j]) && i<j) {\n        //             goodPairs++;\n        //         }\n        //     }\n        // }\n        for(int i: nums) {\n            goodPairs += count[i]++;\n        }\n        return goodPairs;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-good-pairs",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755683490,
            "question_id": 1635,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658689554,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/755683490/",
            "is_pending": "Not Pending",
            "title": "Number of Good Pairs",
            "memory": "41.6 MB",
            "code": "class Solution {\n    public int numIdenticalPairs(int[] nums) {\n        int goodPairs = 0;\n        for(int i=0; i<nums.length; i++) {\n            for(int j=0; j<nums.length; j++) {\n                if((nums[i]==nums[j]) && i<j) {\n                    goodPairs++;\n                }\n            }\n        }\n        return goodPairs;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111",
            "title_slug": "number-of-good-pairs",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755659008,
            "question_id": 1528,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658687568,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/755659008/",
            "is_pending": "Not Pending",
            "title": "Kids With the Greatest Number of Candies",
            "memory": "42.8 MB",
            "code": "class Solution {\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\n        Boolean max = false;\n        List<Boolean> arr = new ArrayList<Boolean>(candies.length);\n        for(int i=0; i<candies.length; i++) {\n            for(int j=0; j<candies.length; j++) {\n                if(candies[i]+extraCandies >= candies[j])\n                    max = true;\n                else {\n                    max = false;\n                    break;\n                }\n            }\n            arr.add(max);\n        }\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "kids-with-the-greatest-number-of-candies",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755657769,
            "question_id": 1528,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658687469,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "3 ms",
            "url": "/submissions/detail/755657769/",
            "is_pending": "Not Pending",
            "title": "Kids With the Greatest Number of Candies",
            "memory": "43.4 MB",
            "code": "class Solution {\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\n        Boolean max = false;\n        List<Boolean> arr = new ArrayList<Boolean>(candies.length);\n        for(int i=0; i<candies.length; i++) {\n            int total = candies[i]+extraCandies;\n            for(int j=0; j<candies.length; j++) {\n                if(total >= candies[j])\n                    max = true;\n                else {\n                    max = false;\n                    break;\n                }   \n            }\n            arr.add(max);\n        }\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "kids-with-the-greatest-number-of-candies",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755628617,
            "question_id": 1580,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658685319,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/755628617/",
            "is_pending": "Not Pending",
            "title": "Shuffle the Array",
            "memory": "45.6 MB",
            "code": "class Solution {\n    public int[] shuffle(int[] nums, int n) {\n        int[] arr = new int[nums.length];\n        int x=0;\n        for(int i=0; i<n; i++) {\n            arr[x] = nums[i];\n            for(int j=n+i; j<=n+i; j++) {\n                arr[x+1] = nums[j];   \n            }\n            x+=2;\n        }\n        return arr;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "title_slug": "shuffle-the-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755498274,
            "question_id": 1791,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658674356,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/755498274/",
            "is_pending": "Not Pending",
            "title": "Richest Customer Wealth",
            "memory": "41.7 MB",
            "code": "class Solution {\n    public int maximumWealth(int[][] accounts) {\n        int maxWealth = 0;\n        for(int i=0; i<accounts.length; i++) {\n            int sum = 0;\n            for(int j=0; j<accounts[i].length; j++) {\n                sum += accounts[i][j];\n            }\n            if(sum>maxWealth)\n                maxWealth = sum;\n        }\n        return maxWealth;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111",
            "title_slug": "richest-customer-wealth",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755451801,
            "question_id": 1603,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658669976,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/755451801/",
            "is_pending": "Not Pending",
            "title": "Running Sum of 1d Array",
            "memory": "43.5 MB",
            "code": "class Solution {\n    public int[] runningSum(int[] nums) {\n        int[] arr = new int[nums.length];\n        arr[0] = nums[0];\n        for(int i=1; i<nums.length; i++) {\n            arr[i] = arr[i-1] + nums[i];\n        }\n        return arr;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "title_slug": "running-sum-of-1d-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755437310,
            "question_id": 2058,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658668511,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/755437310/",
            "is_pending": "Not Pending",
            "title": "Concatenation of Array",
            "memory": "49.9 MB",
            "code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        // return Stream.of(nums, nums).flatMapToInt(Arrays::stream).toArray();\n        \n        // int[] arr = new int[nums.length*2];\n        // System.arraycopy(nums,0,arr,0,nums.length);\n        // System.arraycopy(nums,0,arr,nums.length,nums.length);\n        // return arr;\n        \n        int[] arr = new int[(nums.length)*2];\n        for(int i=0; i<nums.length; i++) {\n            arr[i] = arr[nums.length+i] = nums[i];   \n        }\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "concatenation-of-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755437182,
            "question_id": 2058,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658668501,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "2 ms",
            "url": "/submissions/detail/755437182/",
            "is_pending": "Not Pending",
            "title": "Concatenation of Array",
            "memory": "50.2 MB",
            "code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        // return Stream.of(nums, nums).flatMapToInt(Arrays::stream).toArray();\n        \n        // int[] arr = new int[nums.length*2];\n        // System.arraycopy(nums,0,arr,0,nums.length);\n        // System.arraycopy(nums,0,arr,nums.length,nums.length);\n        // return arr;\n        \n        int[] arr = new int[(nums.length)*2];\n        for(int i=0; i<nums.length; i++) {\n            arr[i] = arr[nums.length+i] = nums[i];   \n        }\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "concatenation-of-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755431031,
            "question_id": 2058,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658667871,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/755431031/",
            "is_pending": "Not Pending",
            "title": "Concatenation of Array",
            "memory": "50.7 MB",
            "code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        // return Stream.of(nums, nums).flatMapToInt(Arrays::stream).toArray();\n        int[] arr = new int[nums.length*2];\n        System.arraycopy(nums,0,arr,0,nums.length);\n        System.arraycopy(nums,0,arr,nums.length,nums.length);\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "concatenation-of-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755420662,
            "question_id": 2058,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658666808,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/755420662/",
            "is_pending": "Not Pending",
            "title": "Concatenation of Array",
            "memory": "50.6 MB",
            "code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        return Stream.of(nums, nums).flatMapToInt(Arrays::stream).toArray();\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "concatenation-of-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755420571,
            "question_id": 2058,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658666799,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "13 ms",
            "url": "/submissions/detail/755420571/",
            "is_pending": "Not Pending",
            "title": "Concatenation of Array",
            "memory": "50.4 MB",
            "code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        return Stream.of(nums, nums).flatMapToInt(Arrays::stream).toArray();\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "concatenation-of-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755418781,
            "question_id": 2058,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658666610,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "11 ms",
            "url": "/submissions/detail/755418781/",
            "is_pending": "Not Pending",
            "title": "Concatenation of Array",
            "memory": "49.8 MB",
            "code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        return Stream.of(nums, nums).flatMapToInt(Arrays::stream).toArray();\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "concatenation-of-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755372445,
            "question_id": 2058,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658661763,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/755372445/",
            "is_pending": "Not Pending",
            "title": "Concatenation of Array",
            "memory": "50.8 MB",
            "code": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        int[] arr = new int[(nums.length)*2];\n        for(int i=0; i<nums.length; i++) {\n            arr[i] = arr[nums.length+i] = nums[i];   \n        }\n        return arr;\n    }\n}",
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "concatenation-of-array",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755362554,
            "question_id": 2048,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658660735,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/755362554/",
            "is_pending": "Not Pending",
            "title": "Build Array from Permutation",
            "memory": "42.7 MB",
            "code": "import java.util.ArrayList;\n\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        int[] arr = new int[nums.length];\n        for(int i=0; i<nums.length; i++) {\n            arr[i] = nums[nums[i]];\n        }\n        return arr;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "build-array-from-permutation",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755349798,
            "question_id": 9,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658659448,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "14 ms",
            "url": "/submissions/detail/755349798/",
            "is_pending": "Not Pending",
            "title": "Palindrome Number",
            "memory": "44.7 MB",
            "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        int rem = 0, temp, sum=0;\n        temp = x;\n        while(x>0) {\n            rem = x%10;\n            sum = (sum*10) + rem;\n            x = x/10;\n        }\n        return (sum==temp);\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "title_slug": "palindrome-number",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755287061,
            "question_id": 1,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658653038,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "119 ms",
            "url": "/submissions/detail/755287061/",
            "is_pending": "Not Pending",
            "title": "Two Sum",
            "memory": "44.3 MB",
            "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i <= nums.length - 1; i++) {\n\t\t\tfor (int j = i+1; j <= nums.length - 1; j++) {\n\t\t\t\tint sum = nums[i] + nums[j];\n\t\t\t\tif (sum == target) {\n\t\t\t\t\treturn new int[] { i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return null;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111",
            "title_slug": "two-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755281973,
            "question_id": 1,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658652515,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "117 ms",
            "url": "/submissions/detail/755281973/",
            "is_pending": "Not Pending",
            "title": "Two Sum",
            "memory": "44.9 MB",
            "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int arr[] = new int[2];\n        outerloop:\n        for (int i = 0; i <= nums.length - 1; i++) {\n\t\t\tfor (int j = i+1; j <= nums.length - 1; j++) {\n\t\t\t\tint sum = nums[i] + nums[j];\n\t\t\t\tif (sum == target) {\n\t\t\t\t\tarr[0] = i;\n\t\t\t\t\tarr[1] = j;\n\t\t\t\t\tbreak outerloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return arr;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111",
            "title_slug": "two-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755281556,
            "question_id": 1,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658652472,
            "status": 10,
            "status_display": "Accepted",
            "runtime": "121 ms",
            "url": "/submissions/detail/755281556/",
            "is_pending": "Not Pending",
            "title": "Two Sum",
            "memory": "45 MB",
            "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int arr[] = new int[2];\n        outerloop:\n        for (int i = 0; i <= nums.length - 1; i++) {\n\t\t\tfor (int j = i+1; j <= nums.length - 1; j++) {\n\t\t\t\tint sum = nums[i] + nums[j];\n\t\t\t\tif (sum == target) {\n\t\t\t\t\tarr[0] = i;\n\t\t\t\t\tarr[1] = j;\n\t\t\t\t\tbreak outerloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return arr;\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111",
            "title_slug": "two-sum",
            "has_notes": false,
            "flag_type": 1
        },
        {
            "id": 755280356,
            "question_id": 1,
            "lang": "java",
            "lang_name": "Java",
            "time": "1 year, 9 months",
            "timestamp": 1658652349,
            "status": 11,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/755280356/",
            "is_pending": "Not Pending",
            "title": "Two Sum",
            "memory": "N/A",
            "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int arr[] = new int[2];\n        outerloop:\n        for (int i = 0; i <= nums.length - 1; i++) {\n\t\t\tfor (int j = 1; j <= nums.length - 1; j++) {\n\t\t\t\tint sum = nums[i] + nums[j];\n\t\t\t\tif (sum == target) {\n\t\t\t\t\tarr[0] = i;\n\t\t\t\t\tarr[1] = j;\n\t\t\t\t\tbreak outerloop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        return arr;\n    }\n}",
            "compare_result": "111101111111111010101111111111111111111111111111111111111",
            "title_slug": "two-sum",
            "has_notes": false,
            "flag_type": 1
        }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%221157354449%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222024-01-26T12%3A01%3A35.908862%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%227158577%22%7D%7D"
}